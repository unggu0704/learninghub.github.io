[
  
  {
    "title": "Vison control",
    "url": "/learninghub/study/mit6.005-%20software%20construction/Vison-Control/",
    "categories": "Study, MIT6.005- Software Construction",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Objectives  version control이 무엇이고 왜 사용하는지 파악합니다.  어떻게 git이 version history를 그래프로 저장하는지 이해합니다.  version history를 사용하고 읽고 만드는것을 연습합니다.Introduction  Version control 시스템은 소프트웨어 공학에선 필수적인 도구입니다. 대부분의 오픈...",
    "content": "Objectives  version control이 무엇이고 왜 사용하는지 파악합니다.  어떻게 git이 version history를 그래프로 저장하는지 이해합니다.  version history를 사용하고 읽고 만드는것을 연습합니다.Introduction  Version control 시스템은 소프트웨어 공학에선 필수적인 도구입니다. 대부분의 오픈, 취미 등등에서 사용합니다.  version control 없이 팀원의 모든 코드를 조절하는 것은 매우 어렵다.version control 없는 버전 제어  드롭박스  undo/redo  파일에 번호를 붙여 저장Inventing version control(버전 컨트롤의 발명)엘리스 혼자서 개발할때  version control 없이 혼자 개발할경우 백업파일을 만든다고 가정  Hello.java1, Hello.java2….  그리고 이걸 Cloud에 올린다.  만약 노트북에서 작업한 HelloL.java 와 데스크탑에서 작업한 HelloD.java  만약 실수로 파일을 덮어 쓴다면…? (ex: HelloL.java → HelloD.java)  데스크탑에서 작업한 소중한 파일을 잃어버렸다…앨리스와 밥이 개발할때  서로 다른 컴퓨터에서 작업하기에 클라우드 서버에 엄격한 규율을 적용  또한 효율적인 관리를 위해 로그 작성Muliple branches  새로운 기능을 추가하기 위해 브랜치에서 작업  기능이 완전하게 작업되기 전까지 pull 되는건 누구도 원하지 않음  혼자 개발하더라도 이러한것은 동일함  이러한 기능은 높은 유연성을 제공Distributed vs centralized  중앙집중식          마스터 서버 하나에서 관리      모든 사용자는 마스터서버와 작업을 공유        분산식          개인적인 사용자가 개인 저장소를 가지고 있음      개인 저장소에서 변경된다면 팀 저장소는 그에 대한 변경 내용을 결정해야함      Version control 용어  Repository : 로컬 또는 원격 저장소  Working copy : 작업 또는 프로젝트의 편집 가능한 복사본  File : 단일 파일  Version : 프로젝트의 한 시점을 기록  diff : 두 버전간의 차이  Head : 현재 버전version control system의 특징  Realibable : 안전하게 백업  Multiple files : 프로젝트의 여러 버전을 추적  Meaningful Version : 어떤 변화가 있고 어디서 만들어졌는지  Revert : 이전 버전으로 복원  Compare version  Review history : 전체 프로젝트 또는 개인 파일에 대한 컴토  Not just for code : 산문, 이미지….  Merge : 이전 버전과 다른 버전을 결합  Track respnsibillity : 누가 변화를 가지고, 누가 코드 라인을 만졌는지  Work in parallel : 한명의 프로그래머가 다른 사람에 상관없이 혼자 버전관리 가능하다.  Work-In-Progress : 다수의 프로그래머가 서로 완료되지 않은 작업을 공유 가능Git  Command Line에서 작동  자세한 내용은 PS0에서…git object graph  git에서 수행하는 모든 작업은 우리의 프로젝트 안 파일에 그래프 형식으로 저장된다.  git clone은 이러한 그래프를 로컬로 가져오는것  일반적으로 directed acyclic graph(DAG) 형태  커밋은 일반적으로 16진수로 표시되는 고유 ID로 식별  각 커밋에는 부모 커밋에 대한 포인터가 있다.  부모가 둘인 커밋도 있을수 있음git commit  작업 디렉토리 내용을 기반으로 커밋을 생성 그래서 편집을 하면 스냅샷에 변경 사항 포함  git은 마지막 준비 영역이 staging area에 저장  staging area는 프로토 커밋과 같다. git add 를 사용하여 새로운 스냅샷을 만드는것은 다음과 같다.      작업 디렉토리와 스테이징 영역 Head commit 모두 같다.    파일을 변경    git add 를 사용해서 Stage 변경    git commit 을 사용해서 새 커밋 만들기  Sequences, trees, and graphs  단일 컴퓨터에서 혼자 작업할 경우 DAG는 일반적인 시퀸스로 보임 (commit1 → commit2 → commit3…)  하지만 다수의 프로그래머가 동시에 변화를 만든다면? ( 여러 커밋이 하나의 부모 커밋을 가리킬때)  이러한 과정으로 git push, git pull이 있음merging  A라는 파일을 각자 다른 두 사람이 B 와 C파일을 생성  B가 업데이트된 A를 push  C가 업데이트된 A를 push할 경우 push가 거절됨  C는 B로 인해 업데이트 된 A를 pull 하고 자신의 업데이트된 A를 병합하여 새로운 A+를 생성  C는 A+를 push하고 B또한 A+를 pull 한다.  이러한 방식은 서로 다른 파일을 수정했기에 가능하다…"
  },
  
  {
    "title": "Mutability & immutability",
    "url": "/learninghub/study/mit6.005-software%20construction/Mutability-&-Immutability/",
    "categories": "Study, MIT6.005-Software Construction",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Object  가변 객체와 가변성에 대해 이핸다.  allasing(별명 짓기)를 Identify 성과 가변성의 위험을 이해  불변성을 사용해 정확성, 명확성,등을 개선한다.**Mutability**  Java의 일부 객체는 불변성을 가지고 있다.  한번 생성되면 → 항상 동일한 값을 가지고 있다. [Immutability]  한번 생성되면 → 추후 ...",
    "content": "Object  가변 객체와 가변성에 대해 이핸다.  allasing(별명 짓기)를 Identify 성과 가변성의 위험을 이해  불변성을 사용해 정확성, 명확성,등을 개선한다.**Mutability**  Java의 일부 객체는 불변성을 가지고 있다.  한번 생성되면 → 항상 동일한 값을 가지고 있다. [Immutability]  한번 생성되면 → 추후 값을 변경하는 메소드가 있다. [Mutability]      String 은 불변 타입의 가장 큰 예시이다. 같은 객체는 항상 동일한 문자열만을 나타낸다.      String s = \"a\";  s = s.concat(\"b\"); // s+=\"b\" and s=s+\"b\" also mean the same thing              s 라는 String 객체는 언제나 “a” 만을 담고 있다.      하지만 concat 을 통해 이어 붙일 시에 새로운 ab라는 객체를 만들어 저장한다.      s가 가르키는 주소가 변경되는 형태                StringBuilder 는 가변 타입의 예시이다. 문자열을 일부 삭제, 삽입등을 방법을 가지고 있다.      StringBuilder sb = new StringBuilder(\"a\");  sb.append(\"b\");              하지만 StringBuiler 는 다르다.              하나의 sb 객체에 값을 직접 수정하는 식으로 변경한다.                    String t = s;t = t + \"c\";StringBuilder tb = sb;tb.append(\"c\");  일반적인 String 에서 t 와 s 는 같은 객체를 가르킨다. 물론 tb 와 sb 또한 같은 객체를 가르킨다.  하지만 값의 변경이 이루어질 때 t 는 새로운 객체인 abc 를 생성해서 가르키지만, tb 는 sb 와 함께 가르키는 객체를 수정해 sb 또한 같이 값이 변경된다.      String 의 사용이 일부 코드에서 지양되는 이유      String s = \"\";  for (int i = 0; i &lt; n; ++i) {      s = s + n;  }      ///////////////////////////////////  String s = \"\";  for (int i = 0; i &lt; n; ++i) {  \t  StringBuilder sb = new StringBuilder();      for (int j = 0; j &lt; s.length; j++) { // 기존 문자열 n -1 번 반복  \t\t\t\tsb.append(s.charAt(j);// 기존의 s의 문자열을 하나하나 새로운 값에 넣어야함   \t\t}  \t\tsb.append(n);  \t\ts = sb;  }              String 에 대한 많은 변경이 이루어질 때 너무나 많은 임시적 복사본이 생성된다.      위 코드에서는 n 개의 String 객체가 생성될 위험을 가진다.      시간 복잡도 면에서도  O($n^2$)를 가진다            StringBuilder 객체는 이러한 문제를 해결 할 수 있다.      StringBuilder sb = new StringBuilder();  for (int i = 0; i &lt; n; ++i) {    sb.append(String.valueOf(n));  }  String s = sb.toString();              StringBuilder 는 이러한 복사본을 최소화한다.      마지막 까지 복사본을 만들지 않고 계속해서 객체 내부의 값만 수정한다.      가변 객체는 객체를 공유함으로써 더 성능 좋은 통신이 가능하다.      Risks of mutation  가변 타입을 불변 타입보다 강력하게 보인다.  그러면 왜 불변 타입을 사용하는걸까…?  불변 타입은 버그로부터 안전하고, 이해하기 쉬우며, 변화에 준비됬다.  가변성은 코드를 이해하기 어렵게 만든다 두가지 예시**Risky example #1: passing mutable values**/** @return the sum of the numbers in the list */public static int sum(List&lt;Integer&gt; list) {    int sum = 0;    for (int x : list)        sum += x;    return sum;}  단순히 리스트의 값을 모두 더하는 코드  만약 절대 값도 처리하고 싶다면 다음과 같이 코드를 변경한다./** @return the sum of the absolute values of the numbers in the list */public static int sumAbsolute(List&lt;Integer&gt; list) {    // let's reuse sum(), because DRY, so first we take absolute values    for (int i = 0; i &lt; list.size(); ++i)        list.set(i, Math.abs(list.get(i)));    return sum(list);}  이 코드는 list를 직접 변경하여 사용한다.  얼핏 보면 효율적인 코드로 보인다. (DRY 우수)  하지만 이 코드는 잠재적인 버그를 가지고 있다. → 가변객체를 통과시키는것 , 추후에 디버깅 난이도 상승/** @return the sum of the absolute values of the numbers in the new list */public static int sumAbsolute(List&lt;Integer&gt; list) {    List&lt;Integer&gt; absoluteValues = new ArrayList&lt;&gt;();    for (int num : list) {        absoluteValues.add(Math.abs(num));    }    return sum(absoluteValues);}  가변 객체를 넘기는것보단 새로운 리스트를 생성해서 넘기는 것이 조금더 안전하다.**Risky example #2: returning mutable values**  우리가 가변 객체를 함수에 전달하면 생기는 문제를 보았다. 가변 객체를 return 하는 것은?  Date 를 고려해보자. 이건 가변 타입이다. 우리가 만약 첫번 째 날이 봄날인지 가정하는 코드를 쓴다면?/** @return the first day of spring this year */public static Date startOfSpring() {    return askGroundhog();}  Groundhog 알고리즘을 사용하여 봄의 시작을 계산하는 코드// somewhere else in the code...public static void partyPlanning() {    Date partyDate = startOfSpring();    // ...}  전체적인 코드는 작동하지만 두가지 수정 사항이 생겼다.                  매번 코드에 대한 질문을 대답해야 하기에 추후에 대답을 위해서 코드를 수정한다.          /** @return the first day of spring this year */  public static Date startOfSpring() {      if (groundhogAnswer == null) groundhogAnswer = askGroundhog();      return groundhogAnswer;  }  private static Date groundhogAnswer = null;                            봄의 날씨가 너무 춥기에 봄의 시작일에서 한달 뒤로 코드를 수정해야한다.          // somewhere else in the code...  public static void partyPlanning() {      // let's have a party one month after spring starts!      Date partyDate = startOfSpring();      partyDate.setMonth(partyDate.getMonth() + 1);      // ... uh-oh. what just happened?  }                    partyDate의 Month 를 1 올렸지만, groundHogAnswer도 1 오르는 문제가 발생한다.      또한 11(12월)의 경우 잘못된 값을 내보낼 수 있다        결과적으로 이 코드는…          잠재적 버그를 가지고 있다.      변화를 위한 준비는 좋지만 이것이 버그를 도입하지 않고 바꾸는것이 중요하다…        각 두 예제에서 List&lt;Integer&gt; 와 Date 를 불변 유형이였다면 이러한 문제를 피할 수 있을것이다.  물론 Java.time , LocalDateTime 같은 불변 타입을 사용한다면 버그를 피할 수 있다.  이런 예제는 왜 가변 타입이 나쁜 성능을 보이는지 알려줍니다.  이런 버그를 피하는 간단한 방법은 명세나 메소드 시그니처의 변경을 피하는 것이다          startOfSpring() 에서 항상 복사본을 return 한다.      return new Date(groundhogAnswer.getTime());        이러한 패턴을 defensive copying 이라고 한다.  이는 추상적인 데이터 타입이며 기존의 값에 영향을 주지 않고 자유롭게 사용이 가능하다. → 캡슐화 달성  그러나 이러한 방어적 복사는 이용자가 추가적인 공간과 작업이 요구 된다. 즉 99%의 사용자가 날짜를 변경하지 않더라도 이런 오버헤드는 발생한다.  불변성은 이런 오버헤드가 없다. 즉 이런 상황에서는 불변성이 더욱 이득이 되는 상황**Aliasing is what makes mutable types risky**  일반적으로 가변 객체를 지역적으로 사용하는 것은 괜찮다.  하지만 다양한 객체에 aliases 라고 불리는 여러개의 참조를 가지는것에 문제가 있다.                  List 객체를 사용하는 sum , sumAbsolute 이건 다양한 사람이 협업하는 과정에서 문제가 발생        (한 프로그래머는 sumAbsolute 만을 수정하면서 sum 은 유지되기를 희망할 때)                    Date 같은 경우 groundhogAnswer 와 partyDate 를 가리키는데 이 또한 각자 같은 객체를 참조하지만 다른 곳에 위치 되어 있어 코드를 읽기 어렵게 한다.            **Specifications for mutating methods**  가변성 있는 메소드의 수행에 대해 명세에 포함하는 것은 중요합니다.  우리는 앞서 가변성이 버그의 원인이 됨을 확인하였다.static void sort(List&lt;String&gt; lst)requires: nothingeffects:  puts lst in sorted order, i.e. lst[i] &lt;= lst[j]              for all 0 &lt;= i &lt; j &lt; lst.size()  가변성을 제거한 명세static List&lt;String&gt; toLowerCase(List&lt;String&gt; lst)requires: nothingeffects:  returns a new list t where t[i] = lst[i].toLowerCase()  변이는 결국 끔찍한 버그로 이어지는 것을 언제나 명심할것**Iterating over arrays and lists**  가변 객체중에 Iterator 를 확인해보자.  Collections의 요소들을 순차적으로 확인하는 객체로써 자바에서는 List의 loop에서 주로 사용된다.List&lt;String&gt; lst = ...;for (String str : lst) {    System.out.println(str);}  이걸 컴파일러는 이렇게 해석한다…List&lt;String&gt; lst = ...;Iterator iter = lst.iterator();while (iter.hasNext()) {String str = iter.next();    System.out.println(str);}  iterator가 가지고 있는 두가지 메소드          next() returns the next element in the collection      hasNext() tests whether the iterator has reached the end of the collection.        주목할 것은 next() 는 가변 메소드로써 단순히 요소를 리턴할 뿐만 아니라 다음 값을 찾는다MyIterator      MyIterator의 구현      /**   * A MyIterator is a mutable object that iterates over   * the elements of an ArrayList&lt;String&gt;, from first to last.   * This is just an example to show how an iterator works.   * In practice, you should use the ArrayList's own iterator   * object, returned by its iterator() method.   */  public class MyIterator {          private final ArrayList&lt;String&gt; list;      private int index;      // list[index] is the next element that will be returned      //   by next()      // index == list.size() means no more elements to return          /**       * Make an iterator.       * @param list list to iterate over       */      public MyIterator(ArrayList&lt;String&gt; list) {          this.list = list;          this.index = 0;      }          /**       * Test whether the iterator has more elements to return.       * @return true if next() will return another element,       *         false if all elements have been returned       */      public boolean hasNext() {          return index &lt; list.size();      }          /**       * Get the next element of the list.       * Requires: hasNext() returns true.       * Modifies: this iterator to advance it to the element       *           following the returned element.       * @return next element of the list       */      public String next() {          final String element = list.get(index);          ++index;          return element;      }  }        Instance varibles : 자바에서 필드라고 불리는 인스턴스 변수로써 매개변수와 로컬 변수와는 차이가 있다. 객체의 인스턴스에 저장되고 일반적인 로컬 변수보다는 더 오래 가는것을 명심  Constructor : 객체를 생성  this : 인스턴스 변수를 참조하는데 사용  etc…  list 는 final 로 선언되어져 있다.          이는 불변 객체로 선언되어 관리됨을 알 수 있다…      이런 일반적인 반복자의 개념은 다양한 언어에서 사용된다. (디자인 패턴)      **Mutation undermines an iterator**      아래 코드는 iterator를 사용하는 예 이다.      /**   * Drop all subjects that are from Course 6.   * Modifies subjects list by removing subjects that start with \"6.\"   *   * @param subjects list of MIT subject numbers   */  public static void dropCourse6(ArrayList&lt;String&gt; subjects)        dropCourse6 은 클라이언트에게 인수가 변경될 것을 경고한다.      테스트를 위해서 입력을 분할한다.      // Testing strategy:  //   subjects.size: 0, 1, n  //   contents: no 6.xx, one 6.xx, all 6.xx  //   position: 6.xx at start, 6.xx in middle, 6.xx at end      // Test cases:  //   [] =&gt; []  //   [\"8.03\"] =&gt; [\"8.03\"]  //   [\"14.03\", \"9.00\", \"21L.005\"] =&gt; [\"14.03\", \"9.00\", \"21L.005\"]  //   [\"2.001\", \"6.01\", \"18.03\"] =&gt; [\"2.001\", \"18.03\"]  //   [\"6.045\", \"6.005\", \"6.813\"] =&gt; []          public static void dropCourse6(ArrayList&lt;String&gt; subjects) {      MyIterator iter = new MyIterator(subjects);      while (iter.hasNext()) {          String subject = iter.next();          if (subject.startsWith(\"6.\")) {              subjects.remove(subject);          }      }  }            테스트 결과      // dropCourse6([\"6.045\", \"6.005\", \"6.813\"])  //   expected [], actual [\"6.005\"]              마지막은 실패했다.        이건 모든 Iterator 를 사용하는 모든 곳에서 나타나는 문제for (String subject : subjects) {    if (subject.startsWith(\"6.\")) {        subjects.remove(subject);    }}  이건 결과적으로 [Concurrent­Modification­Exception](http://docs.oracle.com/javase/8/docs/api/?java/util/ConcurrentModificationException.html)를 유발한다.      이 문제를 해결할려면…      Iterator iter = subjects.iterator();  while (iter.hasNext()) {      String subject = iter.next();      if (subject.startsWith(\"6.\")) {  \t\t\titer.remove(subject);      }  }              iter.remove() 로 변경한다.      기존의 subjects.remove() 는 리스트에서 해당 요소를 다시 찾아서 제거 한다. (예외발생)      iter.remove() 는 현재 순회 중에 요소를 삭제 할 수 있는 유일한 방법…        이렇게 해서 전체 문제를 해결했다고는 볼 수 없다.          만약 같은 Iterator를 다른 프로그램이 실행중이라면..?’            이 문제에 대한 스냅샷 다이어그램      **Mutation and contracts****Mutable objects can make simple contracts very complex**  가변 데이터 구조체에 대한 기능적 이슈입니다.  같은 가변 객체에 대한 다양한 참조(aliasese 라고도 불림)  다양한 위치에 있는 참조가 한 객체를 의존하고 있는 상태  이러한 경우 다양한 곳에 위치한 참조자 들끼리 서로 가변 객체를 좋은 방식으로 다루기를 기도하는 방법뿐…  이러한 방식의 대표적은 Java의 Collections          Collections 은 이러한 방식에 대해서 어떻게 기록하고 있는가?      수정 (List 를 추가하거나 삭제)할때 어떤 식으로 책임은 Collections , List , Iterator  중에 누가 책임지나?        Solution                  synchronizing 사용 → Concurrency 보장        List list = Collections.synchronizedList(new ArrayList(...));                    Stram() ,  parallelStream() 활용          List&lt;String&gt; list = Arrays.asList(\"one\", \"two\", \"three\", \"four\", \"five\");  list.parallelStream().forEach(element -&gt; {  // 동시성으로 요소 처리  });                      이와 같이 가변 속성은 추론에 대한 비용이 들어가기 때문에, 프로그램과 데이터 구조에 대한 이해가 더 어렵다.  가변성은 편의성과 성능에 큰 이점을 주기에 버그 안정성과 비교해서 잘 비교해 사용하자.**Mutable objects reduce changeability**  가변 객체는 구현자와 사용자 사이에서 높은 복잡한 제약을 요구하고 변경에 대한 높은 비용을 요구합니다.  즉 Object 를 사용한다는 것은 코드의 변경을 힘들게 하는 것이라고도 말할 수 있다.      Example (MIT에서 사용자의 이름을 검색하고 9자리 식별번호를 반환)      /**   * @param username username of person to look up   * @return the 9-digit MIT identifier for username.   * @throws NoSuchUserException if nobody with username is in MIT's database   */  public static char[] getMitId(String username) throws NoSuchUserException {      // ... look up username in MIT's database and return the 9-digit ID  }              해당 명세에 따라 클라이언트가 이렇게 요청한다.          char[] id = getMitId(\"bitdiddle\");  System.out.println(id);              이 상태에서 유저의 개인정보 보호를 위해 구현자와 사용자는 id 앞 5글자에 *****로 가리기로 한다.          char[] id = getMitId(\"bitdiddle\");  for (int i = 0; i &lt; 5; ++i) {      id[i] = '*';  }  System.out.println(id);              구현자는 캐쉬를 추가한다.          private static Map&lt;String, char[]&gt; cache = new HashMap&lt;String, char[]&gt;();      public static char[] getMitId(String username) throws NoSuchUserException {      // see if it's in the cache already      if (cache.containsKey(username)) {          return cache.get(username);      }          // ... look up username in MIT's database ...          // store it in the cache for future lookups      cache.put(username, id);      return id;  }              이러한 방식에 대해서 발생하는 문제가 있다.      id 는 가변 객체(aliased)에 * 를 추가한다면 cache의 배열까지 수정한다.      가변 객체를 공유 하는 것은 또다시 누구의 책임이 있는지 애매해진다.                  구현자는 return 값을 고정해야만 하는가?          사용자는 return 값을 수정하면 안되는가?                          새로 적은 명세      public static char[] getMitId(String username) throws NoSuchUserException     requires: nothing    effects: returns an array containing the 9-digit MIT identifier of username,               or throws NoSuchUserException if nobody with username is in MIT’s               database. Caller may never modify the returned array.              여전히 문제가 존재한다.      이 코드의 문제는 이러한 제약이 프로그램 전체에 미친다는 것이다.                  array를 절대 수정하지 말것                    기존의 precondition과 postcondition들은 메소드의 주변만 생각했지 다른 곳에서까지 생각할 필요가 없었다는 것을 떠올리면 매우 큰 제약.            비슷한 문제를 가진 예제      public static char[] getMitId(String username) throws NoSuchUserException     requires: nothing    effects: returns a new array containing the 9-digit MIT identifier of username,               or throws NoSuchUserException if nobody with username is in MIT’s               database.              새로운 배열을 return 한다고 해서 완전한 문제를 해결할 수 있는것은 아니다.      여전히 구현자는 새로운 array를 alias 하지 않는다고 보장하지 못한다.            더 나은 예제      public static String getMitId(String username) throws NoSuchUserException     requires: nothing    effects: returns the 9-digit MIT identifier of username, or throws               NoSuchUserException if nobody with username is in MIT’s database.              String 을 return 함으로써 불변성을 보장한다.      또한 불변성이 보장 받았기에 cache를 자유롭게 사용할 수 있다.  → 성능 향상      **Useful immutable types**  일반적으로 immutable은 다양한 문제를 피할 수 있기에, Java API에서의 일반적인 불변 유형 열거          primitive type, primitive는 immutable 입니다.      BigInteger , BigDecimal 또한 immutable 입니다.      mutable한 Date 의 사용을 지양하세요. 시간을 기록할 때 에는 java.time 을 사용하세요.      자바 Collections의 구현에 있어서 모두 mutable 입니다. immutable 하게 할려면 아래를 활용하세요                  Collections.unmodifiableList          Collections.unmodifiableSet          Collections.unmodifiableMap                    mutable한 collection을 다른 프로그램에 전달하기 전에 이 collection을 수정할수 없도록 wrapper 할 수 있습니다.      final 참조는 Object에서는 수정이 가능합니다.      Collections 는 Collections.emptyList 를 통해서 빈 불변 리스트를 생성할 수 있습니다.                  이 빈 리스트는 null 을 사용하는 것을 줄일 수 있는 장점이 있습니다.                    Summary  mutability는 성능과 편의성에 우위를 가지지만, 버그의 위험성을 가진다. 또한 정확성을 추론하기에 높은 비용을 요구한다.  immutable 객체의 차이에 대해서 String 은 immutable 객체, final 은 불변 참조를 이해한다.  immutablility는 결과적으로 버그로부터 안전하고 이해하기 쉬우며, 변화에 준비된 것을 확인 할 수 있다.          물론 비용에 대한 단점도 존재한다…      "
  },
  
  {
    "title": "Debugguing",
    "url": "/learninghub/study/mit6.005-%20software%20construction/Debugguing/",
    "categories": "Study, MIT6.005- Software Construction",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "  Objects          체계적인 디버깅      디버깅이 선택되어 질 때가 있다. (전체 시스템이 함께 연결되거나, 배포 후에 사용자 보고)      버그가 현지화가 불가능 할때에는 디버깅이 좋은 전략이 될 수도 있다.      Reproduce the Bug  고장을 야기하는 테스트케이스를 반복해서 시도한다.  regression tesi...",
    "content": "  Objects          체계적인 디버깅      디버깅이 선택되어 질 때가 있다. (전체 시스템이 함께 연결되거나, 배포 후에 사용자 보고)      버그가 현지화가 불가능 할때에는 디버깅이 좋은 전략이 될 수도 있다.      Reproduce the Bug  고장을 야기하는 테스트케이스를 반복해서 시도한다.  regression tesing을 통해 버그를 찾는데 성공 했다면, 운이 좋은편  사용자가 버그를 제보 했다면 이에 반해 약간의 노력이 필요하다.  하지만 이 환경이 그래픽 사용 인터페이스 또는 멀티 스레드 환경이라면 버그를 찾는 것은 더 어려워진다.  물론 작은 테스트 케이스를 만들어 반복적으로 실행하는 것은 도움이 된다.  반복해서 실행 하고 버그를 찾아 수정하고 이를 통해 regression test에 추가하는 것은 추후 이러한 버그를 지속해서 방지할 수 있기 때문이다.      다음과 같은 예시를 보자      /**   * Find the most common word in a string.   * @param text string containing zero or more words, where a word   *     is a string of alphanumeric characters bounded by nonalphanumerics.   * @return a word that occurs maximally often in text, ignoring alphabetic case.   */  public static String mostCommonWord(String text) {      ...  }        유저에게 세익스피어의 텍스트를 전달하는 메소드이다.  \"the\" 나\"a\" 를 반환 하는 대신에 \"e\" 를 반환 해버리는 문제가 발생한다면?  세익스피어는 100,000 줄과 800.000개의 단어가 있다.  일반적인 디버깅 방식으로는 매우 디버깅 난이도가 높음  만약에 버그가 작은 범위에서도 유의미하게 발생한다면..?          세익스피어의 전반부에서도 발생하는가?      연극 하나에도 같은 버그가 발생하는가?      하나의 문장에서도 같은 버그가 발생하는가?        작은 테스트 케이스를 찾았다면 이를 통해 수정한 후 전체에서도 같은 버그가 발생하는지 확인한다!**Understand the Location and Cause of the Bug**  버그를 지역화 하는데 사용할 수 있는 과학적 방법          Study the data : 버그를 야기시키는 테스트 케이스를 확인하고 잘못된 결과로부터 재추적      Hypothesize : 버그가 어디에서 발생할 수 있는지, 어디서 발생할 일은 없는지에 대한 데이터에 기반한 가설을 세운다.      Experiment : 가설을 검증하는 실험을 생각한다. 프로그램을 최소한으로 방해하지 않으면서 정보를 수집한 뒤 이를 관찰한다.      Repeat : 실험에서 데이터를 수집하고 이를 바탕으로 새로운 가설을 만든다. 반복을 통해 버그가 발생할 곳을 점차적으로 줄여 나간다.            이러한 방식을 바탕으로 다음과 같은 예시      /**   * Find the most common word in a string.   * @param text string containing zero or more words,   *     where a word is a string of alphanumeric   *     characters bounded by nonalphanumerics.   * @return a word that occurs maximally often in text,   *         ignoring alphabetic case.   */  public static String mostCommonWord(String text) {      ... words = splitIntoWords(text); ...      ... frequencies = countOccurrences(words); ...      ... winner = findMostCommon(frequencies); ...      ... return winner;  }      /** Split a string into words ... */  private static List&lt;String&gt; splitIntoWords(String text) {      ...  }      /** Count how many times each word appears ... */  private static Map&lt;String,Integer&gt; countOccurrences(List&lt;String&gt; words) {      ...  }      /** Find the word with the highest frequency count ... */  private static String findMostCommon(Map&lt;String,Integer&gt; frequencies) {      ...  }      Study the Data  Data의 중요한 것 중 하나는 exceoption으로 부터 발생한 Stack trace이다.  Stack trace하는 능력을 연습한다면 버그를 찾을 수 있는 엄청난 능력을 갖게 되는것  작은 테스트 케이스를 조정하는 사이에 특정 입력에 대한 버그의 발생 차이를 알게 될 수도 있다.          mostCommonWords(\"c c, b\") → 버그 발생      mostCommonWords(\"c c b\") → 버그가 발생하지 않음      **Hypothesize**  프로그램을 모듈로써 생각하고 알고리즘의 단계로 생각하는 것은 프로그램의 나머지 전체를 배제하는데 도움이 된다.      전체적인 데이터의 흐름              버그의 증상이 countOccurrences() 의 Exception인 경우 findMostFrequent() 가 배제 가능하다.      그렇다면 splitIntoWords() 에 버그가 있다고 가정하고 실험을 진행해볼 수도 있다.      만약 위의 가정이 true라면 countOccurrences() 또한 배제가 가능하다.      만약 false 라면 splitIntoWords() 를 배제 가능하다.      Experiment  좋은 experiment는 최대한 시스템을 방해하지 않고 진행한다.          Run a different test case : 윗 단계에서 진행 한것이 테스트 케이스를 감소시키는 과정      Insert a print statement or assertion : 프로그램 실행중에 내부 상태를 체크      Set a breakpoint : 중단점을 설정해 코드를 한 단계씩 체크(내부 변수 값, 개체 값)        증명 없이 가설에 기반한 수정을 사용하는 것은 매우 매력적이다  하지만 이러한 시도는 결과적으로 이해하기 어려운 코드를 생성하는 원인이 된다.  설사 버그가 수정되어 진 것처럼 보이더라도 이는 전체적인 수정이 아니라 버그가 단순히 숨었을 수도 있다.  ArrayOutOfBoundsException 의 버그 발생 시 실제 문제를 해결하지 않고 단순히 exception을 피할 수 있는 코드만을 추가하는 것과 비슷한 문제Other tips  Bug localization by binary search          버그를 찾는것 또한 결과적으로 search라고 볼 수 있다.      binary search를 사용한다면 이러한 속도를 높일 수 있다.      mostCommonWords 를 예로 든다면 workflow를 절반으로 나누고 버그가 발생 되는 부분을 다시 한번 반으로 나누는 식으로 속도를 증가 시킬 수 있다.        Prioritize your hypotheses          가설의 우선순위를 세우는 것은 중요하다      테스트가 오래 진행된 예전의 코드에 비해 새로 추가된 코드에서 버그가 발생 할 확률이 높다.      또한 자바 라이브러리는 일반적으로 사용자가 적는 코드 보다는 신뢰성이 높다      마찬가지로 자바의 컴파일러, 운영체제, 하드웨어 등도 버그의 가능성은 낮다.        Swap components          모듈을 만족하는 다른 구현이 있다면 swap 또한 좋은 시도가 될 수 있다.      예를 들어 binary search()에서 문제가 발생했다면 단순한 linear search()로 대체도 가능하다.      마찬가지로 java.util.ArrayList가 문제가 발생한 경우 java.util.LinkedList로 대체도 가능하다.      여전히 문제가 발생한다면 Java 버전을 변경해보고, OS 자체가 의심된다면 다른 OS 환경에서도 테스트 해볼 수 있다.      하지만 이러한 방식은 많은 시간을 요구하기에 충분한 이유가 있어야하다.        Make sure your source code and object code are up to date          git 등을 통해 최신 버전을 새로 받아오고 새로 컴파일한다      Clean  명령어도 비슷한 기능을 실행한다.        Get help          다른 사람에게 문제를 설명하고 도움을 요청해본다.        Sleep on it          자고 내일 다시 본다.      **Fix the Bug**  버그를 발견한다면 어떻게 해결해야할까  단순히 빨리 패치를 하지 않고 버그가 코딩 에러인지 잘못된 오타인지 생각해보자  디자인 에러, 불충분한 인터페이스 등등 다른 문제가 있을 수도 있다는걸 명심하자  또한 비슷한 버그가 있는지도 항상 명심하자  이러한 방법은 미래의 버그를 방지할 수 있는 기회를 제공한다.  마지막으로 회귀 테스트를 통해 해당 버그가 다음에 나타나지 않도록 주의한다.Summary  효율적인 디버깅을 위해서는          버그를 회귀테스트 케이스에 추가      과학적 방법 및 신중한 버그 수정      "
  },
  
  {
    "title": "Abstraction functions & rep invariants",
    "url": "/learninghub/study/mit6.005-%20software%20construction/Abstraction-Functions-&-Rep-Invariants/",
    "categories": "Study, MIT6.005- Software Construction",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Objectives  Invariants  representation exposure  abstraction functions      representation Invariants    추상화 함수 그리고 Invariants(상수)의 개념을 통해 class에 ADT를 구현하는것이 무엇을 의미하는지에 대해 공부한다.  이러한 수학적 개념은 소프트웨어 ...",
    "content": "Objectives  Invariants  representation exposure  abstraction functions      representation Invariants    추상화 함수 그리고 Invariants(상수)의 개념을 통해 class에 ADT를 구현하는것이 무엇을 의미하는지에 대해 공부한다.  이러한 수학적 개념은 소프트웨어 디자인에 있어 매우 실용적이다.  추상함수는 데이터 유형에 따른 equality를 정의하는 방법을 제공한다.  rep invariant는 데이터 구조로 인해 발생되는 버그를 더 쉽게 찾을 수 있게 제공한다.Invariants  좋은 ADT를 만드는것에 대한 논의에 대해서 가장 중요한 속성은 그 자체로 불변성을 보존하는 것이다.  불변성이란? → 프로그램의 런타임 상황에서 항상 True를 유지하는 상태  불변의 대상은 lifeTime 내내 같은 값을 유지해야한다.  ADT가 고유 불변량을 보존한다는 것은 그에 대한 책임이 있다는 말입니다.  ADT가 자신의 불변성을 보장할때 코드는 더 쉬워집니다. String 같은 불변 객체를 다룰 때에는 대게 String을 배제합니다.Immutability      첫번째 예시      /**   * This immutable data type represents a tweet from Twitter.   */  public class Tweet {          public String author;      public String text;      public Date timestamp;          /**       * Make a Tweet.       * @param author    Twitter user who wrote the tweet.       * @param text      text of the tweet       * @param timestamp date/time when the tweet was sent       */      public Tweet(String author, String text, Date timestamp) {          this.author = author;          this.text = text;          this.timestamp = timestamp;      }  }        어떻게 해당 Tweet 객체를 불변으로 할 수 있을까요?      immutabiliy에 대한 첫 번째 위협으로 뽑자면 누군가가 해당 객체를 수정하는데 있습니다.      Tweet t = new Tweet(\"justinbieber\",                      \"Thanks to all those beliebers out there inspiring me every day\",                      new Date());  t.author = \"rbmllr\";        이런 클래스 변수를 노출하는 것은 representaion exposure 의 한 예이다.  이런 representation exposure는 오직 invariants 뿐만 아니라 representation independence까지 위협한다.      접근 제어자를 사용한 예      public class Tweet {          private final String author;      private final String text;      private final Date timestamp;          public Tweet(String author, String text, Date timestamp) {          this.author = author;          this.text = text;          this.timestamp = timestamp;      }          /** @return Twitter user who wrote the tweet */      public String getAuthor() {          return author;      }          /** @return text of the tweet */      public String getText() {          return text;      }          /** @return date/time when the tweet was sent */      public Date getTimestamp() {          return timestamp;      }      }        public private 같은 접근 제어자는 외부에서 접근 할 수 있는 필드를 나타낸다.  앞전에 배웠던 final 도 마찬가지.      그러나 여전히 노출 된곳은 존재한다…      /** @return a tweet that retweets t, one hour later*/  public static Tweet retweetLater(Tweet t) {      Date d = t.getTimestamp();      d.setHours(d.getHours()+1);      return new Tweet(\"rbmllr\", t.getText(), d);  }        retweetLater 는 리트윗을 시도하는 코드입니다. ( 한시간 뒤에 )  d 는 mutable 객체라는 것을 명심하자. → d를 수정시 t까지 수정함  해당 코드는 객체 Tweet에 대한 불변성이 깨진 상태      이건 앞에서 배운 defensive copying으로 조절 가능      public Date getTimestamp() {      return new Date(Date.getTime());  }        clone()  은 가변객체를 복제하는 기능을 제공한다.      defensive copying으로도 여전히 문제되는 부분이 존재한다.      /** @return a list of 24 inspiring tweets, one per hour today */  public static List&lt;Tweet&gt; tweetEveryHourToday () {      List&lt;Tweet&gt; list = new ArrayList&lt;Tweet&gt;();      Date date = new Date();      for (int i=0; i &lt; 24; i++) {          date.setHours(i);          list.add(new Tweet(\"rbmllr\", \"keep it up! you can do it\", date));      }      return list;  }        이 코드는 24시간 마다 새로운 Date 객체를 만들어 매 시간마다 트윗한다.  하지만 이 코드는 모든 Tweet이 하나의 Date 객체를 참조한다…      defensive copying을 활용해서 이를 해결      public Tweet(String author, String text, Date timestamp) {      this.author = author;      this.text = text;      this.timestamp = new Date(timestamp.getTime());  }        일반적으로 모든 인자 타입과 리턴 타입을 주의 깊게 검사해야한다.  유형 중에 하나라도 mutable 한 경우 직접 그 참조를 반환하지 않도록 주의한다… 노출이 생기지 않게 주의하자      그렇다면 이렇게 코드로 하지 말고 상세한 명세로 회피 할순 없는걸까?      /**   * Make a Tweet.   * @param author    Twitter user who wrote the tweet.   * @param text      text of the tweet   * @param timestamp date/time when the tweet was sent. Caller must never   *                   mutate this Date object again!   */  public Tweet(String author, String text, Date timestamp) {        이러한 접근은 다른 대안이 없을때 주로 사용된다.  예를들어 가변 객체가 너무 클 경우가 있다.  하지만 이러한 방식은 프로그램을 추론하는데 들어가는 비용이 너무 큼을 명시하자.  불변성을 보장하는 것은 항상 가치가 높다는 것을 명심하자.  물론 처음부터 불변 유형을 고르는게 가장 합리적이다.**Immutable Wrappers Around Mutable Data Types**  자바 collections는 immutable wrappers라는 걸 제공한다.  Collections.unmodifiableList() 를 사용하면 일반적인 List로 보이지만 불변 개체로 wrapping한다.  하지만 여전히 runTime의 불변성은 보장되지만 Compile 시간에는 불변성이 보장 되지 못한다.Rep Invariant and Abstraction Function  추상 데이터에 대한 기초가 되는 이론을 더 자세히 공부  밑의 이론은 그 자체로 추상 유형의 설계와 구현에 도움을 준다.  추상 유형을 생각할 때 두 개체의 관계를 고려하는건 도움이 된다.  rep values(표현 값 공간)은 실제 개체의 값으로 구성된다.  rep values 값의 공간은 설계된 값으로 구성된다. → 추상 값 공간 (플라토닉 엔티티)  그들은 정신적 객체로써 실존하진 않는다. 그러나 추상적인 타입으로써 클라이언트가 보기 원하는 방식이다.  예를 들어 일반적인 경계가 없는 정수의 경우는 수학정 정수 전체가 추상 값의 공간(AF)이다.  하지만 경계가 있는 정수 배열은 이러한 정수의 경계는 중요하지 않다.      물론 추상 유형의 생성자는 실제 경계를 생각을 해야한다.      public class CharSet {      private String s;      ...  }              표현공간 R(문자열) 그리고 추상공간 A(수학적 문자 집합)이다.      R &gt;- A 라고 볼 수 있다.      몇가지 주의할 점                  모든 추상값은 어떤 참조 값에 의해 mapped된다.          일분 추상 값은 둘 이상의 참조 값에 의해 mapped된다. {”abc”, “bac”} → {a, b, c}          모든 참조 값이 mapped된건 아니다. {”aabbcc” → x } → 중복을 허용하지 않는다면…                      우리는 몇개의 요소와 관게를 설명한다.                  참조 값을 추상값에 매핑하는 추상화 함수                  $AF : R → A$                      이 관계가 일대일 대응이라고는 볼수 없지만… 종종 부분적이라고는 말할 수 있다.                                      참조 값을 booleans에 매핑하는 rep invariant                  $RI : R → boolean$                      참조 값 r 같은 경우 r이 AF에 의해서 매핑될 때만 RI(r)가 참이다.            즉 주어진 참조 값이 잘 형성되었는지 여부를 알인다.                                    rep invariant와 추상화 함수는 코드 옆에 문서화 되어야함을 기억하자      public class CharSet {      private String s;      // Rep invariant:      //    s contains no repeated characters      // Abstraction Function:      //   represents the set of characters found in s      ...  }        추상 함수와 rep invariants의 일반적인 혼란은 그들이 참조와 추상 값의 공간에 대해서 결정된다는 것이다.  추상 값의 공간 만으로는 AF와 RI를 결정할 순 없다.  동일한 추상 타입에 대해 여러 표현 기능이 가능할 수 있다. 예를 들어 문자 집합은 문자열 또는 bit vector와 동일하게 표현될 수도 있다.  두 공간의 AF와 RI를 결정하지 않은 이유는 덜 명확할 수 있다.  표현 값 공간에 대한 유형을 정의하고 그것을 선택한다고 해서 그중 어떤 표현 값이 유요하다고 판단 될것이고 유효한 값중에는 어떻게 해석할지가 결정되지 않는다는 것이다.      위 처럼 문자열에 중복이 없다고 결정하는 대신 중복을 허용하지만 비 내림차순으로 나타난다고 요구하는것도 가능하다.      public class CharSet {      private String s;      // Rep invariant:      //    s[0] &lt;= s[1] &lt;= ... &lt;= s[s.length()-1]      // Abstraction Function:      //   represents the set of characters found in s      ...  }        각각의 가능성 있는 문자들은 서로 다른 추상함수로 매핑 될수 도 있다.  동일한 rep value를 가지더라도 다른 AF를 가진다.  RI 가 모든 문자열을 가진다고 가정한다면 위에서처럼 AF를 정의해 배열 요소의 집합 요소로 해석 가능하다.  $AF(s)={[s1−s1],[s2−s2],…,[sn−sn]}$  연속된 문자 쌍을 부분범위로 해석해 “acgg” sms {a-c}, {g-g}로 해석이 가능한 형태로 {a,b,c,g} 로 나타낼수 있다.  $RI(s)=true for any string s$      RI 가 같더라도 다양한 추상화함수가 아래와 같이 정의 가능하다.      public class CharSet {      private String s;      // Rep invariant:      //    s.length is even      //    s[0] &lt;= s[1] &lt;= ... &lt;= s[s.length()-1]      // Abstraction Function:      //   represents the union of the ranges      //   {s[i]...s[i+1]} for each adjacent pair of characters      //   in s      ...  }        추상 타입을 설계한다는 것은 두 공간(추상 값 공간, 대표 값 공간)을 선택하는것 뿐만 아니라, 어떤 rep values를 결정하고 그거를 해석할지를 결정 한다는 것이다.Example: Rational Numberspublic class RatNum {    private final int numer;    private final int denom;    // Rep invariant:    //   denom &gt; 0    //   numer/denom is in reduced form    // Abstraction Function:    //   represents the rational number numer / denom    /** Make a new Ratnum == n. */    public RatNum(int n) {        numer = n;        denom = 1;        checkRep();    }    /**     * Make a new RatNum == (n / d).     * @param n numerator     * @param d denominator     * @throws ArithmeticException if d == 0     */    public RatNum(int n, int d) throws ArithmeticException {        // reduce ratio to lowest terms        int g = gcd(n, d);        n = n / g;        d = d / g;        // make denominator positive        if (d &lt; 0) {            numer = -n;            denom = -d;        } else {            numer = n;            denom = d;        }        checkRep();    }}  RI 는 numerator/denominator가 감소된 상태, (2,4), (18,12) 같은 쌍은 RI 외부에 그린다.  더 많은 허용적인 RI로 동일한 ADT를 구현하는 것이 훨씬 합리적이다.Checking the Rep Invariant  RI 는 단순하게 깔끔한 수학적 아이디어라곤 볼 수 없다.  RI 불변성을 초기에 주장하는 경우 버그를 조기에 발견 할 수도 있다.      RatNum의 RI를 테스트 하는 방법      // Check that the rep invariant is true  // *** Warning: this does nothing unless you turn on assertion checking  // by passing -enableassertions to Java  private void checkRep() {      assert denom &gt; 0;      assert gcd(numer, denom) == 1;  }        전체적으로 checkRep() 을 호출하여 모든 생성과 변형 작업에서 RI 불변성을 주장해야한다.  위 코드는 각각의 constructors의 끝에 checkRep()을 호출하고 있다.  Obersver methods는 일반적으로 checkRep() 을 호출할 필요는 없지만 이렇게 하는 방식은 좀더 defensive 한 방식입니다.  왜?  모든 방향에서 checkRep() 을 호출하는것은 당신이 RI를 조금더 잘 잡을수 있다는 것입니다.  왜 checkRep이 private인가? → RI를 체크하고 RI를 확인할 책임은 누가져야하는가? clients? 구현자?No Null Values in the Rep  이전 파트에서 읽었듯이 null values는 여러가지 문제를 일으킨다.  null은 우리 공부에서 언제나 가장 제거해야하는 항목이다.  우리는 추상 데이터 타입에 또한  null 참조를 금지할것입니다.class CharSet {    String s;}  s 는 당연히 null이 아닙니다!  하지만 checkRep() 을 구현 할때 여러분은 여전히 s != null 이라는걸 체크해야합니다.  s 가 null 이라면 바로 실패해야하죠      자바에서 기본으로 제공해주는 s를 null 인지 알려주는 예시      private void checkRep() {      assert s.length() % 2 == 0;      ...  }              assert가 있는데 이렇게 굳이 할 필요는 없지..        assert s != null 매우 명시적이다.**Documenting the AF, RI, and Safety from Rep Exposure**  class 안의 RI 와 AF를 문서화하는 것을 매우 좋습니다.  또다른 논쟁은 Rep Exposure argument safety 입니다. 이는 rep의 각 부분을 조사하고 코드에에서 rep를 다루는 부분에서(특히 파라미터와 return값)을 살펴보고 rep가 노출하지 않은 이유를 서술      Tweet 은 Invariant, abstraction function 안정성이 완전히 문서화된 예      // Immutable type representing a tweet.  public class Tweet {          private final String author;      private final String text;      private final Date timestamp;          // Rep invariant:      //   author is a Twitter username (a nonempty string of letters, digits, underscores)      //   text.length &lt;= 140      // Abstraction Function:      //   represents a tweet posted by author, with content text, at time timestamp      // Safety from rep exposure:      //   All fields are private;      //   author and text are Strings, so are guaranteed immutable;      //   timestamp is a mutable Date, so Tweet() constructor and getTimestamp()      //        make defensive copies to avoid sharing the rep's Date object with clients.          // Operations (specs and method bodies omitted to save space)      public Tweet(String author, String text, Date timestamp) { ... }      public String getAuthor() { ... }      public String getText() { ... }      public Date getTimestamp() { ... }  }        우리는 어떠한 명시적인 불변 조건도 timestamp 에 가지고 있지 않다는 점을 명심하십시오. timestamp != null 그러나 여전히 timestamp 의 전체 유형의 불변성 속성은 변경되지 않은 immutability입니다.  왜냐하면 전체 내부 argument에서 이것을 변경할 것이 없기 떄문입니다.      RatNum 의 argument      // Immutable type representing a rational number.  public class RatNum {      private final int numer;      private final int denom;          // Rep invariant:      //   denom &gt; 0      //   numer/denom is in reduced form, i.e. gcd(|numer|,denom) = 1      // Abstraction Function:      //   represents the rational number numer / denom      // Safety from rep exposure:      //   All fields are private, and all types in the rep are immutable.          // Operations (specs and method bodies omitted to save space)      public RatNum(int n) { ... }      public RatNum(int n, int d) throws ArithmeticException { ... }      ...  }      How to Establish Invariants  Invariant는 프로그램 전체에 대해서 True인 특성으로, 객체에 대한 invariant의 경우 객체 전체 수명을 감소시킵니다.  Invariant를 유지하기 위해선 다음을 수행해야합니다.          객체의 초기 상태를 invariant True로 만듭니다.      객체의 모든 변경상항에 대해 invariant True로 만듭니다.        ADT 연산자로 이를 변환하면 다음과 같은 의미를 가집니다.          creators와 producers는 새로운 객체 인스턴스에 대한 invariant를 설정해야합니다.      mutators 와 observers는 invariant를 보존해야합니다.        rep exposure는 언제나 상황을 더 복잡하게 만듭니다. 만약 노출 된다면 ADT의 연산 뿐만 아니라 프로그램 어디서든지 객체가 변경되어질 수 있습니다.  이러한 현상은 invariant를 보장할 수 없어집니다.  Structural Induction 추상 데이터 타입의 invariant가 다음과 같은 경우          creators와 producers에 의해 설립됨      mutators와 observers에 보존됨      rep exposure가 노출되지 않음      **ADT invariants replace preconditions**  지금까지 공부한것을 합쳐 잘 설계된 추상 타입은 규정해야할 전제 조건을 캡슐화 할 수 있다는 것이다.      예를 들어 spec이 다음과 같을때 정교한 precondition      /**   * @param set1 is a sorted set of characters with no repeats   * @param set2 is likewise   * @return characters that appear in one set but not the other,   *  in sorted order with no repeats   */  static String exclusiveOr(String set1, String set2);            이를 대체하는 ADT를 사용할 수 있다. (precondition을 대신함)      /** @return characters that appear in one set but not the other */  static SortedSet&lt;Character&gt; exclusiveOr(SortedSet&lt;Character&gt;  set1, SortedSet&lt;Character&gt; set2);        ADT의 이름 같은 경우 이 프로그램을 사용하는 모든 프로그래머가 사용하기에 이해가 더 쉽다.  또한 Static Checking이 가능하다.Summary  invariant는 개체의 수명동안 ADt 개체가 항상 참인 것이다.  좋은 ADT는 그 자체에 대한 불변성을 보존한다.  → 버그로부터 안전해짐  Rep exposure는 RI와 invariant preservation을 모두 보존한다.  AF는 구체적인 값을 추상적인 값에 매핑해주는 함수이다.  ADT를 활용해 이해하기 쉽고 변화할 준비가 된 코드를 작성 가능하다."
  },
  
  {
    "title": "Abstract data types(23.10.04)",
    "url": "/learninghub/study/mit6.005-%20software%20construction/Abstract-Data-Types(23.10.04)/",
    "categories": "Study, MIT6.005- Software Construction",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Objects  추상 자료형  표현 독립성  추상 데이터 유형의 위험한 문제를 해결하고, 클라이언트가 내부 표현에 대한 가정이 왜 위험하고, 어떻게 그것을 피할 수 있는가?  연산의 분류와 추상적인 데이터 유형에 대한 좋은 설계 원리를 세우는법What Abstraction Means  추상화 데이터 유형은 소프트웨어 공학의 일반적인 원리 중 하나  다...",
    "content": "Objects  추상 자료형  표현 독립성  추상 데이터 유형의 위험한 문제를 해결하고, 클라이언트가 내부 표현에 대한 가정이 왜 위험하고, 어떻게 그것을 피할 수 있는가?  연산의 분류와 추상적인 데이터 유형에 대한 좋은 설계 원리를 세우는법What Abstraction Means  추상화 데이터 유형은 소프트웨어 공학의 일반적인 원리 중 하나  다양한 의미로 이야기 되어진다.          추상화 : 낮은 정보를 숨기고 더 단순하게 표현      모듈화 : 시스템을 모듈로 나누고, 각 구성 요소에 설계, 구현 등의 기능을 추가      캡슐화 : 모듈 주위에 벽을 만들어 모듈 내부가 각자 스스로에게 책임을 부여, 다른 부분의 무결성 보장      정보 숨김 : 모듈의 세부 정보를 숨겨 추후 시스템 변경시 다른 모듈을 변경할 필요가 없음      관심사 분리 : 기능을 만들때는 하나의 모듈에만 책임을 남긴다.        소프트웨어 공학에서는 이러한 용어를 잘 아는 것이 중요하다.User-Defined Types  컴퓨팅 시대의 초기에는 내장된 타입과 프로시저들로 input과 output를 조절하였다.  이러한 하나의 프로시저를 정의하기 위해 거대한 프로그램의 제작에 들어갔다.  사용자 정의 유형을 허용하는 것은 상당히 진보적인 아이디어  Dahi(Simula 언어 개발자), Hoare(현재 사용죽인 추상화 타입의 발명), Parnas(캡슐화와 정보 숨기기 등의 정의) 등등이 제안  MIT에서 추상타입의 명세에 대해 개발  데이터 추상화의 핵심 아이디어는 어떤 동작에 따라 유형이 특정화 된다는 것  숫자는 더하고 곱하고, 문자열은 연결 가능하는것 불리언은 참 거짓을 구별하는 등…  다른 의미로 프로그래머는 초기 프로그래밍언어로 자신의 유형을 정의가 가능하다.  예를 들어 년/월/일을 나타내는 날짜형  하지만 계산을 못함 → 이게 추상화의 핵심  사용자가 저장되는 방식에 벗어나 자유롭게 저장하고 계산하는 것.  자바에서는 내장형 타입과 사용자 정의형이 구분된다.  Integer 나 boolean 은 java.lang 에 존재 하지만 java.util 을 기본으로 제공하는 건지와는 덜 명확하다.  이는 자바가 여전히 객체가 아닌 원시형의 데이터를 가지고 있음으로써 나타나는 문제          int 와 boolean 은 사용자가 확장이 불가능하다…      Classifiying Types and Operations  내장형이던 사용자 정의 형이던 확실하게 분류할 수 있는건 mutable 인가 immutable 로 분류 된다.  mutable한 객체는 변경 될 수 있다. 즉 실행될 때 다른 작업을 할 경우 다른 결과를 기대할 수 있다.  Date 는 mutable 하다. 그렇기에 setMonth 로 변경을 가지고 getMonth 로 이것을 관찰 할 수 있다.  String 은 immutable 하다. 하지만 StringBuiler 는 mutable 하다.  추상 유형의 연산은 다음과 같이 분류된다.          Creators : 새 객체를 만든다. 객체의 인자로 활용 될 순 있지만, 구성되어진 객체는 사용할 수 없다.      Producers : 오래된 객체로 새 객체를 만든다. String 의 concat() 매소드가 대표적                  concat() : 두 문자열을 연결하여 새로운 String 객체 생성                    Observers : 추상 객체의 정보를 다른 객체에 return 해준다 size 메소드가 대표적      Mutators : 객체를 바꾼다. add 가 대표적        이러한 연산을 요약한다면          creator: t* → T      producer: T+, t* → T      observer: T+, t* → t                                                  mutator: T+, t* → void              t              T                                            다양한 class 들의 연산 signatures를 보여준다  T 는 추상적 유형 그 자체로 각각 다른 타입이다. + 는 한번이상 발생을, * 는 0 번 이상 발생을 말한다.  creator operation은 생성사로 구현되는 경우가 많다. new ArrayList() 처럼.  그러나 creator는 단순히 static method가 될 수는 없는데 Arrays.asList() 가 대표적이다.  이런 creator는 종종 Factory method 라고도 불린다. String.valueOf 가 대표적인 factory method 중 하나.  Mutators는 종종 void return type에 불린다. 아무것도 반환하지 않은 것을 여러가지 부작용을 동반 할수 잇다. boolean 을 활용해 정상적으로 변경되었는지 알리는 부울을 반환라면 돌연변이를 줄일 수있다.Abstract Data Type Examples  추상 데이터 유형과 몇가지 작업의 유형  int 는 원시형 타입이고 immutable 하다.          creators: the numeric literals 0, 1, 2, …      producers: arithmetic operators +, -, ×, ÷      observers: comparison operators ==, !=, &lt;, &gt;      mutators: none (it’s immutable)        List 는 mutable 하다.          creators: ArrayList and LinkedList constructors, [Collections.singletonList](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#singletonList-T-)      producers: [Collections.unmodifiableList](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-T-)      observers: size, get      mutators: add, remove, addAll, [Collections.sort](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#sort-java.util.List-)        String 은 immutable          creators: String constructors      producers: concat, substring, toUpperCase      observers: length, charAt      mutators: none (it’s immutable)      Designing an Abstract Type  추상적 유형을 설계하는데에는 좋은 작업을 선택하고 어떻게 동작을 가져야하는지에 대한 결정이 필요하다.  복잡한 작업 하나보다는 쉬운 작업 몇개가 좋다는것을 명심하자  각각의 작동은 잘 정의된 목적을 가져야 하며 일관된 행동을 가져야한다 ( 애매해서는 안된다. )  만약에 멋대로 List 에 sum 을 추가한다면 단순히 Integers, String, nested 등등 모든 케이스에 대해서 강력하게 적용시켜야한다.  각 연산 집합은 다양한 상황에서 충분히 적합해야한다.  좋은 테스트는 모든 객체에 대해서 확인하는 것이다.  예를들어 get 연산자가 없다면 우리는 리스트의 요소를 알아낼수 없다.  기본적인 정보를 얻어내기에 어렵지 않아야함을 명시하자.  또다른 예로 size 연산자는 indices가 실패할때까지 증가 하는 식으로 알아낼수 있지만 이건 매우 비 효율적이다.  타입은 집합일 수도 그래프 일수도 있다.  하지만 일반적인 기능과 도메인별 기능을 혼동해서는 안된다.**Representation Independence**  좋은 추상 데이터 타입은 표현 독립적이여야한다.  추상 타입이 실제 사용자의 표현(실제 데이터 구조) 등과 독립적이므로 표현의 변화가 외부 코드에 영향을 미치지 않게 한다는것을 의미  예를 들어 List가 연결된 list인지 배열인지는 중요하지 않다.  ADT의 표현은 전제 조건과 사후 조건을 완전히 지정하지 않은 한 변경해서는 안된다.  고객은 이러한 조건을 확실하게 알고 의존관계를 파악한 후에 변경여부를 파악한다.**Example: Different Representations for Strings**  **Representation Independence**가 정확히 무엇을 의미하는지 예시  실제 String 을 표현한 MyString 코드/** MyString represents an immutable sequence of characters. */public class MyString {    //////////////////// Example of a creator operation ///////////////    /** @param b a boolean value     *  @return string representation of b, either \"true\" or \"false\" */    public static MyString valueOf(boolean b) { ... }    //////////////////// Examples of observer operations ///////////////    /** @return number of characters in this string */    public int length() { ... }    /** @param i character position (requires 0 &lt;= i &lt; string length)     *  @return character at position i */    public char charAt(int i) { ... }    //////////////////// Example of a producer operation ///////////////    /** Get the substring between start (inclusive) and end (exclusive).     *  @param start starting index     *  @param end ending index.  Requires 0 &lt;= start &lt;= end &lt;= string length.     *  @return string consisting of charAt(start)...charAt(end-1) */    public MyString substring(int start, int end) { ... }}  이러한 연산자와 명세는 오직 사용자가 알수 있는 유일한 정보  이러한 자료형에 대해 테스트를 시도한다.  하지만 assertEquals 는 시도할 수 없다?          왜? equailty를 정의하지 않았기에 → equailty를 어떻게 신중하게 구현할지도 추후 공부        현재로썬 구현되어 있는 5가지 메소드에 대해서만 테스트 한다.      valueOf 테스트      MyString s = MyString.valueOf(true);  assertEquals(4, s.length());  assertEquals('t', s.charAt(0));  assertEquals('r', s.charAt(1));  assertEquals('u', s.charAt(2));  assertEquals('e', s.charAt(3));              이것에 대한 테스트는 마지막에..        MyString 에 대한 표현에 있어 char 배열은 정확히 string의 길이이다. 끝에 추가적인 공간은 있으면 안된다.  내부 표현은 다음과 같이 선언되어 있다.          private char[] a;            이러한 표현을 선택한다면 연산자의 구현은 다음과 같을 것이다.      public static MyString valueOf(boolean b) {      MyString s = new MyString();      s.a = b ? new char[] { 't', 'r', 'u', 'e' }              : new char[] { 'f', 'a', 'l', 's', 'e' };      return s;  }      public int length() {      return a.length;  }      public char charAt(int i) {      return a[i];  }      public MyString substring(int start, int end) {      MyString that = new MyString();      that.a = new char[end - start];      System.arraycopy(this.a, start, that.a, 0, end - start);      return that;  }        이러한 구현의 문제점은 성능 개선의 기회가 없다는 것이다.  데이터 타입이 immutable이기에 굳이 subString 에서 새로운 문자열로 복사할 필요가 없다.  기존에 존재하는 문자열의 시작과 끝을 추적하는 방식으로 성능 개선의 여지가 있다.      최적화를 구현하기 위해 내부 표현을 변경      private char[] a;  private int start;  private int end;            새로운 연산자 구현          public static MyString valueOf(boolean b) {          MyString s = new MyString();          s.a = b ? new char[] { 't', 'r', 'u', 'e' }                  : new char[] { 'f', 'a', 'l', 's', 'e' };          s.start = 0;          s.end = s.a.length;          return s;      }          public int length() {          return end - start;      }          public char charAt(int i) {        return a[start + i];      }          public MyString substring(int start, int end) {          MyString that = new MyString();          that.a = this.a;          that.start = this.start + start;          that.end = this.start + end;          return that;      }        이러한 구현의 변경은 MyString 이 개인의 영역이 아닌 오직 공개된 명세에만 의존하기에 바로 변경이 가능하다. 이것이 표현 독립성의 힘**Realizing ADT Concepts in Java**  우리는 ADT 아이디어를 통해 Java 언어 기능을 사용하여 공부해보았다  자바 언어에 존재하는 ADT 개념들은 다음과 같다            ADT concept      Ways to do it in Java      Examples                  Creator operation      Constructor      http://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#ArrayList–                     Static (factory) method      http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#singletonList-T-, http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T…-                     Constant      http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html#ZERO              Observer operation      Instance method      http://docs.oracle.com/javase/8/docs/api/java/util/List.html#get-int-                     Static method      http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#max-java.util.Collection-              Producer operation      Instance method      http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#trim–                     Static method      http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-java.util.List-              Mutator operation      Instance method      http://docs.oracle.com/javase/8/docs/api/java/util/List.html#add-E-                     Static method      http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#copy-java.util.List-java.util.List-              Representation      private fields             Summary  추상 데이터 타입은 그들의 연산에 따라 특정되어진다.  좋은 ADT는 일괄적이며 적절하고, 간단하며 표현 독립적이다.  ADT의 명세는 연산자의 집합과 그들의 스펙이다.  연산자는 creators, producers, observers 그리고 mutators로 분리된다.  좋은 ADT는 명확한 명세를 제공하기에 잠재적 버그를 줄이고 간단한 연산 뒤에 구현을 숨겨 이해하기 쉽게 하며 표현독립성으로 변화에 준비 되었다.**Testing an Abstract Data Type**  ADT에 대한 테스트 케이스는 서로와 상호작용한다.  creators, producers, mutators 같은 경우는 실제 값을 관찰하여 테스트 하는게 가장 효율적이다.      input Test를 분할한 경우      // testing strategy for each operation of MyString:  //  // valueOf():  //    true, false  // length():  //    string len = 0, 1, n  //    string = produced by valueOf(), produced by substring()  // charAt():  //    string len = 1, n  //    i = 0, middle, len-1  //    string = produced by valueOf(), produced by substring()  // substring():  //    string len = 0, 1, n  //    start = 0, middle, len  //    end = 0, middle, len  //    end-start = 0, n  //    string = produced by valueOf(), produced by substring()            이를 바탕으로 test suite는 다음과 같다.      @Test public void testValueOfTrue() {      MyString s = MyString.valueOf(true);      assertEquals(4, s.length());      assertEquals('t', s.charAt(0));      assertEquals('r', s.charAt(1));      assertEquals('u', s.charAt(2));      assertEquals('e', s.charAt(3));  }      @Test public void testValueOfFalse() {      MyString s = MyString.valueOf(false);      assertEquals(5, s.length());      assertEquals('f', s.charAt(0));      assertEquals('a', s.charAt(1));      assertEquals('l', s.charAt(2));      assertEquals('s', s.charAt(3));      assertEquals('e', s.charAt(4));  }      @Test public void testEndSubstring() {      MyString s = MyString.valueOf(true).substring(2, 4);      assertEquals(2, s.length());      assertEquals('u', s.charAt(0));      assertEquals('e', s.charAt(1));  }      @Test public void testMiddleSubstring() {      MyString s = MyString.valueOf(false).substring(1, 2);      assertEquals(1, s.length());      assertEquals('a', s.charAt(0));  }      @Test public void testSubstringIsWholeString() {      MyString s = MyString.valueOf(false).substring(0, 5);      assertEquals(5, s.length());      assertEquals('f', s.charAt(0));      assertEquals('a', s.charAt(1));      assertEquals('l', s.charAt(2));      assertEquals('s', s.charAt(3));      assertEquals('e', s.charAt(4));  }      @Test public void testSubstringOfEmptySubstring() {      MyString s = MyString.valueOf(false).substring(1, 1).substring(0, 0);      assertEquals(0, s.length());  }        각 테스트는 일반적으로 객체를 만들고 수정한다.  그리고 각 작업과 유형을 감시하는 작업 또한 호출한다."
  },
  
  {
    "title": "Testing",
    "url": "/learninghub/Testing/",
    "categories": "",
    "tags": "",
    "date": "2024-12-15 00:00:00 +0900",
    





    
    "snippet": "Testing(23.09.14)이번 장의 목표  Test-first programmin의 절차를 알고, 테스팅 값을 이해하는것  메소드의 input과 output에 적절한 테스트를 디자인 하고 좋은 TC를 고르는것  테스트가 코드에 어느 범위 까지 적용 되는것을 이해하는것  블랙박스와 화이트박스 테스트를 이해하고 유닛과 통합 테스트 그리고 자동 회귀 ...",
    "content": "Testing(23.09.14)이번 장의 목표  Test-first programmin의 절차를 알고, 테스팅 값을 이해하는것  메소드의 input과 output에 적절한 테스트를 디자인 하고 좋은 TC를 고르는것  테스트가 코드에 어느 범위 까지 적용 되는것을 이해하는것  블랙박스와 화이트박스 테스트를 이해하고 유닛과 통합 테스트 그리고 자동 회귀 테스트를 이해한다.검증  일반적으로 테스팅의 대부분 절차는 검증이라 불린다.  검증의 목표는 야기 될 수 있는 프로그램의 잠재적 문제를 찾아 정확성을 높이는 것.  검증은 아래를 포함한다.          Foraml reasoning(형식추론) : 공식 증명으로 프로그램을 검증한다. 손으로 하는것보다 tool을 주로 사용, 주로 운영체제 스케줄러, 바이트코드 인터프리터등 작은 부분에 사용된다.      Code review : 누군가가 코드를 읽고 이것을 추론한다. 버그를 방지하는데 좋은 방법이다      Testing : TC를 input에 결과를 확인한다.          테스팅 하는것이 어려운 이유  Exhaustive Testing(철저한 테스팅) : 전체를 테스트하기에는 프로그램이 너무 거대함 (ex: 32비트의 부동 소수점 계산    a*b 는 2^64개의 TC가 존재  Haphazard Testing(우연적 테스팅) : 단지 실행하는지 확인만 하는것은 버기를 잡기엔 좋지않다. 왜냐하면 임의의 TC가 버그를 잡지 못할 수도 있다.  Random or statistical Testing(무작위 또는 정적 테스팅) : SW에서는 잘 어울리지 않음, 일반적인 다른 공학에서는 주로 사용되지만… SW는 대부분 불연속적, 특정한 공간에 이산적으로 발생 (ex: 스택 오버플로우, 정수 값 초과…) 그렇기에 TC를 선별할때 잘 선별 해야한다.Test-first Programming  테스트는 언제나 빠르게 자주 그렇지 않으면 검증되지 않은 코드가 쌓여 티버거 시간과 고통이 늘어난다.  test-first-programmin은 코드를 쓰기도 전에 테스트를 하는것이다.          함수의 기능을 작성한다.      구체적으로 어떻게 테스트 할지를 작성한다.      실제 코드를 작성한다        specification(명세) 에 함수의 input(paprameter와 같은…)과  output을 묘사, 그리고 input에 따른 return값이 어떻게 관련 있는지 또한 묘사  specification 또한 버그가 없도록 테스트가 필요Choosing Test Cases by Partitioning  좋은 테스트 케이스를 만드는것은 프로그램 디자인에 중요한 요소  이것을 위해 subdomains 활용          input의 집합      각 subdomain은 그 구역의 모든 범위에 적용됨      그렇기에 각각의 subdomain에서 하나 골라서 테스트        이러한 생각 뒤에는 한 구역의 input space에는 비슷한 결과를 낼 것이라고 생각  이러한 접근 법은 한정된 테스트 자원이 있을때 사용Example : **BigInteger.multiply()**  모든 정수를 나타난다. int 와 long 은 제한적인 정수  multiply() 는 곱셈 기능      이렇게 사용한다.      BigInteger a = ...;  BigInteger b = ...;  BigInteger ab = a.multiply(b);        이 코드는 다음과 같은 input 쌍이 존재 할 수 있다.          a와 b가 양수      a와 b가 음수      a는 양수, b는 음수      a는 음수, b는 양수      a나 b가 1,0,-1 일 경우        계산 방식 또한 다음과 같다.          크기에 대해 값이 작을 경우 효율을 위해 int 와 long 으로 계산      Long.MAX_VALUE 등 2^63 과 같은 극적으로 큰 값일때        이러한 점을 고려했을때 우리는 다음과 같은 test suite를 만들 수 있다.          (-3, 25) → a와 b가 작고 음수와 양수      (0, 30) → a는 0, b는 작은 양수      (2^100, 1) → a는 큰 양수 b는 1      등등…      **Include Boundaries in the Partition**  버그는 언제나 boundaries와 subdomains에서 일어난다          ‘0’은 양수와 음수의 경계      int 와 double 같은 경우 각 최대 최소      비어있는 String, list등의 Collection Type      요소의 첫번째 또는 마지막        왜 버그는 경계에서 일어날까?→ 프로그래머들은 off-by-one mistakes (한가지 실수)를 저지른다.          &lt;= 를 &lt; 로 쓰는것과 같은…        다른 문제로는 몇몇 경계들은 특별한 case로 다뤄야하는 경우도 있을 수 있다.  아니면 경계에서는 코드가 지속적으로 진행되지 않을 수도 있다.          int 같은 경우 최대 값을 넘어가면 마이너스의 값을 가진다.        max : int x int -&gt; int          a와 b의 relationship                  a &lt; b          a = b          a &gt; b                    a의 값은                  a = 0          a &lt; 0          a &gt; 0          a = int의 최대 값          a = int의 최소 값                    b의 값 또한 위와 같음        이러한 정보를 토대로 아래와 같은 테스트 값을 산출          (1, 2) → a &lt; b, a &gt; 0, b &gt;0      (0, 0) → a = b, a= 0, b= 0      (Integer.MAX_VALUE, Integer.MIN_VALUE) → a &gt; b, a = maxInt, b = minInt      Two Extemes for Covering the Partition  input space 의 분리가 나누어진 후에 얼마나 많은 test를 준비 할 것인가  Full Cartesian Product          각각의 분리에 대해 3 x 5 x 5 = 75 &gt; 는 7 x 7 = 49보다 크다      물론 a &lt; b , a= 0, b= 0 같은 경우는 이렇게 해당 될수 없다.        Cover each Part          각각의 텍스트는 최소 하나 이상의 범위에 적용된다. 하지만 이것을 모두 조합 할 필요는 없고 위의 max 같은 경우는 최소 5개로 적용이가능하다.      Blackbox and Whitebox Test  위에서 언급한 specification을 회상  Blackbox testing :  함수의 기능을 생각하지 않고 specification(명세)만을 보고 TC를 정함  Whitebox testing : 함수가 실제로 어떻게 돌아가는지를 생각하면서 TC를 만듬 위의 max 와 multiply 가 대표적          whitebox testing을 할때에는 예외에 대해 명시 (exception에 대한 throws)의 경우 굳이 NullPointEception에 대한 테스트를 할 필요가 없다. ..?      Exercises/** * Sort a list of integers in nondecreasing order.  Modifies the list so that  * values.get(i) &lt;= values.get(i+1) for all 0&lt;=i&lt;values.length()-1 */public static void sort(List&lt;Integer&gt; values) {    // choose a good algorithm for the size of the list    if (values.length() &lt; 10) {        radixSort(values);    } else if (values.length() &lt; 1000*1000*1000) {        quickSort(values);    } else {        mergeSort(values);    }}  이 코드에 대해서 화이트 박스 경계값 테스트는 values = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] 이다.  values = [] 는 white box Test용 값은 아니다.Coverage  하나의 TC가 얼마나 코드의 범위를 체크 할수 있는가 (화이트 박스 테스트)의 지표  Statement coverage : TC가 Statement 문을 전부 테스트 하는가?  Branch Coverage : 모든 if 와 while을 테스트 하는가?  Path Coverage : 모든 조합 가능한 조건문들을 테스트 하는가? = 모든 경로를 테스트 하는가?  일반적으로 patch &gt; branch &gt; statment 순으로 강력하다  하지만 현실적으로 Path나 Branch Coverage를 이뤄낼순 없다  현실적으론 하나의 테스트 케이스가 모든 Statement에 도달 할수 있게 조절 → 도구를 활용Unit Testing and Stubs  테스트를 할때는 가능하다면 모듈단위로 고립적 테스트 하는것이 좋다.  또한 고립된 모듈은 디버깅 하기도 수월 → Unit Test의 필요성  이와 반대로 모듈을 조합하거나 또는 전체 프로그램을 테스트 하는것을 intergation test라고 불린다.          이런 intergation test는 버그를 찾는것에 소모되는 시간이 크지만 여전히 전체 모듈 사이의 연결을 테스트하는데 여전히 중요하다.            하지만 철저한 Unit test는 intergation Test에 역할을 어느정도 대체해 버그를 찾는데 들이는 비용을 감소 시킬수가 있다.      /** @return the contents of the web page downloaded from url    */  public static String getWebPage(URL url) {...}      /** @return the words in string s, in the order they appear,               where a word is a contiguous sequence of               non-whitespace and non-punctuation characters    */  public static List&lt;String&gt; extractWords(String s) { ... }          /** @return an index mapping a word to the set of URLs               containing that word, for all webpages in the input set    */  public static Map&lt;String, Set&lt;URL&gt;&gt; makeIndex(Set&lt;URL&gt; urls) {       ...      for (URL url : urls) {          String page = getWebPage(url);          List&lt;String&gt; words = extractWords(page);          ...      }      ...  }        우리는 위 코드에서 3개의 단위 테스트를 할 수 있다.          getWebPage() : 다양한 url 을 가져온다.      extractWords() : 다양한 String을 테스트한다.      makeIndex() : 다양한 url의 집합을 테스트 한다.        extrackWords() 을 단위 테스트 한다면?          getWebPage() 에 의존해서는 안된다.      직접적으로 String을 받아오는 방식으로 해야한다. 왜? 다른 모듈에 버그가 있을수도 있기 때문에.        makeIndex() 를 단위 테스트 한다면?          쉽게 독립되긴 힘들어 보인다.      연관된 다른 메소드들의 단위 테스트를 실행해 신뢰감을 높인다면 해당 메소드도 테스트가 가능      이런식으로 테스트 완료된 구조를 넓혀간다.      만약 어떤식으로도 테스트 하고 싶다면 stub을 사용할 수 있을것이다.      Automated Testing and Regression Testing  Automated testing 은 자동적으로 실행과 테스트를 체크한다.  test driver 는input에 대한 결과를 체크 하기 위해 자동적으로 프로그램과 상호작용하지 않습니다. 대신에 자동으로 테스트 케이스가 맞는지는 체크합니다.  이러한 테스트 도구로는 JUnit이 주로도움을 줍니다.  현재로썬 테스트 도구는 연구 분야 역시 가장 좋은건 스스로 해보는것.  수정된 코드를 재 실행하는 것은 중요하다. 그리고 기능을 추가하거나 버그를 수정할때 마다 새로운 테스트를 자동으로 실행하는 것을 regression testing이라고 한다.  버그가 발생하고 그 코드를 수정한다면 다음 테스트 코드에는 그 버그를 유발 시켰던 TC를 추가하고 다시 테스트한다 이를 또한 regression testing이라고도 불린다.  이러한 아이디어는 또한 test-first-debugging 이라고도 불리는데 버그가 증가할때 즉시 TC에 추가한다. 버그를 수정한다면 모든 테스트 케이스들은 여전히 통과 될 것이다.  Automated Testing and Regression Testing 은 모두 서로 조합되서 사용된다.  Regression Testing 은 테스트가 자동으로 자주 실행 될때 실용적이며 이미 프로젝트가 완료 되어다면 회귀 테스트로 전체 자동 테스트를 하는것이 합리적이다.Summary  Test-first programming은 코드를 쓰기전에 테스트 코드를 적는것  분할과 경계는 테스트 케이스를 체계적으로 생성할 수 있다.  화이트 박스 테스트와 Statement Coverage는 test suit(test case를 묶은것)를 채우도록 해준다  각 모듈의 단위 테스트는 가능한한 고립시켜서 진행한다.  자동화된 테스팅은 버그를 방지한다."
  },
  
  {
    "title": "Static checking",
    "url": "/learninghub/Static-Checking/",
    "categories": "",
    "tags": "",
    "date": "2024-12-15 00:00:00 +0900",
    





    
    "snippet": "STATIC CHECKING(23.09.12)**Hailstone Sequence**      n이 짝수일 때 n / 2, n이 홀수 일때 3n + 1      2, 1           3, 10, 5, 16, 8, 4, 2, 1       4, 2, 1  2n, 2n-1 , ... , 4, 2, 1  5, 16, 8, 4, 2, 1  7, 22, ...",
    "content": "STATIC CHECKING(23.09.12)**Hailstone Sequence**      n이 짝수일 때 n / 2, n이 홀수 일때 3n + 1      2, 1           3, 10, 5, 16, 8, 4, 2, 1       4, 2, 1  2n, 2n-1 , ... , 4, 2, 1  5, 16, 8, 4, 2, 1  7, 22, 11, 34, 17, 52, 6, 13, 40, ...? (where does this stop?)            이런 코드를 하일스톤(우박) 코드… 왜? → 왔다갔다 하니깐….  Type  타입 → 값의 집합  Primitive Types (원시 타입) (int, long, boolean…)  Object Type (객체 타입) (String, BingInteger…)  Operations → 입력을 받고 출력을 생성하는 함수Static Typing &amp; Checking      Compile Time Error VS Runtime Error    ### 컴파일 타임 에러          기계어로 컴파일 하는 과정의 에러      구문 오류 또느 누락 파일 참조, 컴파일 되지 못하게 막음        ### 런타임 에러          프로그램이 실행하는 동안 발생 버그 (ex: 프로그램 충돌 등…)        JAVA는 정적 타입 언어 → 컴파일 타임에 변수를 검사함 (정적 검사) 이런 효과덕분에 버그에 더 안전함  Python은 동적 타입 언어 런타임 동안 에러를 검사Checking의 종류  Static checking : 프로그램 Run 이전에 버그를 자동으로 찾는것          구문 에러 : 잘못된 단어나, 구두점을 검사      작업 디렉토리 이름      잘못된 argument(인자)      잘못된 argument Type      잘못된 return Type      이러한 방식은 변수가 어떤 타입을 가질지는 보장하지만 런타임 시간까지 그것을 보증하지는 않는다.        Dynamic checking : Run 상태가 되고 버그를 자동으로 찾는것          잘못된 인자 값 (ex: x/y 에서 오직 y가 0일때 오류 이건 동적 에러)      반환 값을 특정할수 없는 경우..?      인덱스 범위 초과      null 객체를 참조할경우            No Chechking : 언어가 error를 찾이 않고 스스로 버그를 고치는 행위    Static checking &gt; Dynamice Checking &gt; No Checking 순으로 좋음.  Primitive Types  자바의 Integer(다른 원시 타입)은 실제 숫자가 아니다.  5 / 2의 경우 분수가 아닌 2를 리턴 → 동적 에러에서 탐지 못함  Overflow같은 경우 int나 long의 경우 값 초과시… 이상한 값 도출  float 과 doubles는 real number와는 조금 다르다. dynamice error(0으로 나누거나 음수에 제곱근)을 시도할경우 에러가 아닌 이상한 결과(POSITIVE_INFINITY)를 내보낸다.Arrays and Collectionsfixed Array  고정된 길이 만약 int[100] 이라면 그 이상을 넘어서면 → 버그List  Class  ArrayList, LiknedList…  객체를 저장한 Integer 같은 (int 와는 자동 형변환)Methods  public 프로그램 어디에서나 사용가능…  static 객체를 통해 불러지지 않음 ex) .add() / .lenght()      주석은 매우 중요하다 언제나 메소드의 대해서 추상적인 부분을 정의    ex) int n 에서 n이 양수임을 알림  **Mutating Values vs. Reassigning Variables**Mutable  일반적인 Array, List의 경우 값 안의 참조를 변경  StringBuiler도 마찬가지Immutable  일반적인 변수의 재할당  String 이 대표적Final  자바가 제공하는 Immutable 예약어  재 할당 할려고 시도시 Compile error가 발생해 Static checking이 가능해짐**Documenting Assumptions**  일반적으로 int 로 선언된 변수는 컴파일러가 검사한다.  final로 선언 한다면 절대 재 할당되지 않은 것을 컴파일러가 인지한다  하지만 음수 값이 들어가면 안된다는 것등은 컴파일러가 모른다  Assumption을 적는 것은 자기 또는 다른 사람이 이러한 형식을 잊이 않게 하기 위해  프로그램에 대해 두가지 목표를 명심해 쓸것          컴파일러가 구문, 타입 에러를 잡을수 있게 할것      사람이 프로그램을 이해하기 쉽게 하여 추후 수정하기 쉽게 할것      Hacking VS Engineering  BAD          테스트 하기전에 너무 많은 코드를 적기      모든 것을 기억할수 있다고 가정하고 주석을 적지 않은것      버그가 없다고 가정하거나 쉽게 수정할 수 있다고 생각하기        GOOD          조금 작성하고 테스트, 테스트 퍼스트 프로그래밍      코드가 의존하는 문서를 만들기      Static checking의 도움 받기      Summary      Static checking을 사용 해서 아래와 같은 목표를 도달.    버그로부터 안전한 코드          Static Checking이 type에 대해서 runtime 이전에 도움을 줄 수있다.        이해하기 쉬운 코드          코드에 타입이 명시적으로 적어져있기에 이해 하기 쉬움        변화에 준비됨          코드의 변경시 영향 받는 모든 곳에 에러를 보여주면서 상기시킴      "
  },
  
  {
    "title": "Specifications",
    "url": "/learninghub/Specifications/",
    "categories": "",
    "tags": "",
    "date": "2024-12-15 00:00:00 +0900",
    





    
    "snippet": "Specifications(23.09.21)**Specifications란 무엇인가?**  심각한 버그는 인터페이스의 동작에 대한 오해에서 나타난다.  정확한 명세를 활용해 비난을 사람이 아닌 코드로 옮겨야한다.      BigIntefer에 대한 명세와 코드      /*   * 명세   */      public BigInteger add(BigI...",
    "content": "Specifications(23.09.21)**Specifications란 무엇인가?**  심각한 버그는 인터페이스의 동작에 대한 오해에서 나타난다.  정확한 명세를 활용해 비난을 사람이 아닌 코드로 옮겨야한다.      BigIntefer에 대한 명세와 코드      /*   * 명세   */      public BigInteger add(BigInteger val)      Returns a BigInteger whose value is (this + val).      Parameters:   val - value to be added to this BigInteger.      Returns:   this + val          /*   * 실제 코드    */  if (val.signum == 0)      return this;  if (signum == 0)      return val;  if (val.signum == signum)      return new BigInteger(add(mag, val.mag), signum);      int cmp = compareMagnitude(val);  if (cmp == 0)      return ZERO;  int[] resultMag = (cmp &gt; 0 ? subtract(mag, val.mag)                     : subtract(val.mag, mag));  resultMag = trustedStripLeadingZeroInts(resultMag);      return new BigInteger(resultMag, cmp == signum ? 1 : -1);        Specifications로써의 BigInteger.add 는 일반적인 사용자가 이해하기 쉽게 되어 있다.  Source Code로 써의 BingInteger.add 는 코너케이스에 대한 질문에 적절한 읽을 수있는 문서를 제공한다.  Specifications를 사용함으로써 구현에 있어서 변화할 때 클라이언트에게 알리지 않고도 변경이 가능하다. → ?  코드를 더 빠르게 만들게 도와주기도 하는데 Specifications는 더 효율적인 구현을 제공하기도 한다.  precondition은 특정 범위에 대해 필요 없는 체크를 하지 않게 해준다.  Specifications = contract acts 라고도 불린다. 고객과 설계자와의 방화벽으로써 클라이언트가 작업과 unit의 자세한 부분까지 알게 할 필요가 없다. Specifications가 있다만 고객에게 소스코드를 읽게할 필요가 없다는 뜻  구현하는 사람은 장치의 세부 사항으로부터 보호한다.  또한 고객으로부터 어떻게 사용할지 물어보는 대신에 명세를 확인한다.  이러한 벽은 결과적으로 unit의 코드와 고객의 코드를 독립적으로 변경할 수 있게 해준다.Behavioral equivalencestatic int findFirst(int[] arr, int val) {    for (int i = 0; i &lt; arr.length; i++) {        if (arr[i] == val) return i;    }    return arr.length;}static int findLast(int[] arr, int val) {    for (int i = arr.length -1 ; i &gt;= 0; i--) {        if (arr[i] == val) return i;    }    return -1;}  위 두 코드는 다르다.  하지만 behavior equivalence에 대한 우리의 질문은 하나의 구현을 다른걸로 대체가 가능한지 에대한 문제이다.  단순히 코드가 다른걸 제외하고도 return값에 있어 또한 차이가 있다.  투 메소느는 같은 행동을 하지만 고객이 절대 다른 case에 있어서 의존하지 않게 할 수 있다.  결국 같은 val과 같은 요소를 출력하기에 서로가 서로로 전환 가능  동등성은 고객의 눈으로 봐야한다.  한 구현에 있어 대체제를 하기 위해 그리고 그것을 수용하기 위해 우리는 Soecification(명세)에 의존한다.Specification structure  메소드 명세는 다음과 같은 항으로 구성된다.          Precondition : keyword가 무엇을 요구하는지 나타내는것, 고객의 의무 어떤 값을 넣을지      Postcondition: keyword가 어떤 영향에 대해 나타내는것, 구현자의 의무 적절한 값을 반환        precondition이 고정되어 있다면 postcondition도 고정되어 있어야한다.  반대로 precondition이 고정되어 있지 않다면 구현은 postcondition에 구속되지 않는다. 예외를 던지거다 임의의 결과를 반환하는 등의 자유가 있다.  Precondition : 입력 조건, 함수가 Call 되기 전에 무엇이 참이 되어짐을 나타냄  Postcondition : 출력 조건, 함수가 실행되고 무엇이 참이 되어져야하는지를 나타냄Specifications in Java  일부 언어는 전제조건과 사후 조건을 언어의 기본적인 부분으로 포함  자바의 Static type은 메소드의 전제조건과 사후조건의 일부, 나머지는 주석으로 기술      이런 주석을 잘 활용하기 위해 javadoc의 규칙을 준수      /**   * Find a value in an array.   * @param arr array to search, requires that val occurs exactly once   *            in arr   * @param val value to search for   * @return index i such that arr[i] = val   */  static int find(int[] arr, int val)      Null reference  자바의 객체나 배열은 null 값을 가질수 있다. 즉 참조가 언제나 객체를 가지지 않는다. 자바에서는 이러한 null을 주의해야한다.  원시형 타입은 null이 가능하지 않다.  비 원시형에는 뭐든지 null이 가능  컴파일러는 null을 찾지 못한다. 그렇기에 런타임 시간에 에러가 발생  null과 빈 문자열은 같지 않다.  null 값은 불안전하기에 문법적 디자인으로 추천하지 않는다.  null 값은 암묵적으로 허용되지 않습니다 return values과 파라미터로써 null을 가지는것은  그렇기에 모든 전제조건은 null이 아닌것을 암묵적으로 가진다.  이는 출력조건 또한 non-null임을 가진다.  null을 파라미터로 하고싶은 경우 명시적으로 명시해야하는데… null은 피하는게 좋다.What a specification may talk about  메소드의 명세는 파라미터나 return값에 대한 이야기는 가능하지만 지역변수와 private fields 같은 명세에 보여질 필요가 없을것  독자가 spec에서 자바 코드를 읽을수 없는등 이용할수가 없을수도 있습니다  자바독이 읽을수 있는 HTML로 코드에서 추출하기 때문에 메소드의 소스코드는 굳이 이용하지 않아도 된다.Testing and specifications  명세에만 염두를 두고 진행하는 테스트를 블랙박스 테스트라고 한다.  화이트박스 테스트는 실제 기능을 보고 구현을 하지만, 화이트 박스도 명세를 따른다.  물론 구현보다 더 강력한 경우를 고려할수도 있다.  해당 명세를 보면 index는 배열에서 가장 낮은 val과 같은 값만 추출되어진다. → weak postconditionstatic int find(int[] arr, int val)  requires: val occurs in arr  effects:  returns index i such that arr[i] = val  이런 테스트코드는…?int[] array = new int[] { 7, 7, 7 };~~assertEquals(0, find(array, 7));~~  // bad test case: violates the specassertEquals(7, array[find(array, 7)]);  // correct  find 메소드를 val을 찾을수 없을때 특정값을 return 하는게 아닌 예외를 던지게하는다면  precondition을 위반하기 때문에 find는 호출되지 못하고 동작을 테스트하지 못한다.  왜 화이트박스 테스트가 의미가 있는지는 명세를 넘어서지 못한는 경우에 새로운 테스트를 찾을수가 없다. 그렇기에 구현 독릭접인 방식으로 여전히 테스트는 실행되어야한다.Testing units      Testing 단원에서 학습한 코드 예시      /** @return the contents of the web page downloaded from url */  public static String getWebPage(URL url) { ... }      /** @return the words in string s, in the order they appear,   *          where a word is a contiguous sequence of   *          non-whitespace and non-punctuation characters */  public static List&lt;String&gt; extractWords(String s) { ... }      /** @return an index mapping a word to the set of URLs   *          containing that word, for all webpages in the input set */  public static Map&lt;String, Set&lt;URL&gt;&gt; makeIndex(Set&lt;URL&gt; urls) {       ...      calls getWebPage and extractWords      ...  }        unit testing에 대해 이야기 할 때, 우리의 프로그램에 고립적으로 각각의 모듈에 대해 테스트를 작성하였다.  좋은 unit test는 작은 명세에 초첨을 맞춘다.Specifications for mutating methods  이전의 가변성과 불변성에 대해 이야기했다.  우리의 find 명세는 고려하지 않아다 어떻게 영향력을 미치는지 데이터를 변경할때 사후조건에서      가변 객체에 대한 명세는 다음과 같다.      static boolean addAll(List&lt;T&gt; list1, List&lt;T&gt; list2)    requires: list1 != list2    effects:  modifies list1 by adding the elements of list2 to the end of                it, and returns true if list1 changed as a result of call        자바 List interface를 단순화 한 예시 위  사후조건의 경우 두가지 제약이 있다.          list1 이 어떻게 수정되지는지      return값이 어떻게 결정되어지는지        전제조건을 본다면, 이것은 우리에게 말해줍니다.  리스트에 요소를 자체에 추가할려고 한다면 동작이 정의되지 않음을 알 수 있다. 너는 쉽게 상상할수 있습니다 왜 메소드의 구현자가 이 제약을 원하는지 .  이러한 방식은 구현이 쉬워지고 메소드의 유용한 것을 배제할 가능성이 낮아진다.  암묵적인 전제 조건인 not null을 적용"
  },
  
  {
    "title": "Recursive data types",
    "url": "/learninghub/Recursive-Data-Types/",
    "categories": "",
    "tags": "",
    "date": "2024-12-15 00:00:00 +0900",
    





    
    "snippet": "**Recursive Data Types(23. 10 .16)**Recursive functions재귀적 함수가 자기 자신의 관점에 따라 정의되는 것과 같이 재귀적 자료형 또한 자기 관점에서 정의된다.Immutable lists  immutable list 인 ImList&lt;E&gt; 이것이 4가지의 작동을 한다고 생각          empty:...",
    "content": "**Recursive Data Types(23. 10 .16)**Recursive functions재귀적 함수가 자기 자신의 관점에 따라 정의되는 것과 같이 재귀적 자료형 또한 자기 관점에서 정의된다.Immutable lists  immutable list 인 ImList&lt;E&gt; 이것이 4가지의 작동을 한다고 생각          empty: void → ImList      cons: E × ImList → ImList      first: ImList → E      rest: ImList → ImList        위 규칙들은 List 나 Scheme 의 기본적인 요소로 현재에서도 함수적 프로그래밍에 있어 널리 사용됨      이 데이터 유형을 구현하기 위해 Java 클래스를 비트 연사자를 사용한다면 아래와 같은 의미를 가진다.          empty() = [ ]      cons(0, empty() ) = [ 0 ]      cons(0, cons(1, cons(2, empty() ) ) ) = [ 0, 1, 2 ]      x ≡ cons(0, cons(1, cons(2, empty() ) ) ) = [ 0, 1, 2 ]      first(x) = 0      rest(x) = [ 1, 2 ]      first(rest(x) ) = 1      rest(rest(x) ) = [ 2 ]      first(rest(rest(x) ) = 2      rest(rest(rest(x) ) ) = [ ]      first(cons(elt, lst) ) = elt      rest(cons(elt, lst) ) = lst      Immutable lists in Java      자바의 인터페이스 예시      public interface ImList&lt;E&gt; {      // TODO: ImList&lt;E&gt; empty()      public ImList&lt;E&gt; cons(E e);      public E first();      public ImList&lt;E&gt; rest();  }        해당 인터페이스는 두가지 기능을 나타냅니다.          Empty 빈 연산의 결과를 나타냅니다.      Cons 축소 작업이 결과를 나타냅니다.          public class Empty&lt;E&gt; implements ImList&lt;E&gt; {      public Empty() {      }      public ImList&lt;E&gt; cons(E e) {          return new Cons&lt;&gt;(e, this);      }      public E first() {          throw new UnsupportedOperationException();      }      public ImList&lt;E&gt; rest() {          throw new UnsupportedOperationException();      }  }          public class Cons&lt;E&gt; implements ImList&lt;E&gt; {      private final E e;      private final ImList&lt;E&gt; rest;          public Cons(E e, ImList&lt;E&gt; rest) {          this.e = e;          this.rest = rest;      }      public ImList&lt;E&gt; cons(E e) {          return new Cons&lt;&gt;(e, this);      }      public E first() {          return e;      }      public ImList&lt;E&gt; rest() {          return rest;      }  }        empty 를 구현하는 방법 중에 Empty 생성자를 호출하는 방식이 있다. 하지만 이러한 방식은 독립성의 손산을 유발      이러한 메서드를 팩토리로 구현 → ???    List&lt;String&gt; z = new ArrayList&lt;&gt;();        업데이트된 ImList      public interface ImList&lt;E&gt; {      public static &lt;E&gt; ImList&lt;E&gt; empty() {          return new Empty&lt;&gt;();      }      public ImList&lt;E&gt; cons(E e);      public E first();      public ImList&lt;E&gt; rest();  }            우리는 모든 연산을 구현하였고 아래와 같은 스냅샷 다이어그램을 확인 할 수 있다.      | Java syntax | Functional syntax | Result || — | — | — || ImList nil = ImList.empty(); | nil = empty() | [ ] || nil.cons(0) | cons(0, nil) | [ 0 ] || nil.cons(2).cons(1).cons(0) | cons(0, cons(1, cons(2, nil))) | [ 0, 1, 2 ] || ImList x = nil.cons(2).cons(1).cons(0); | x = cons(0, cons(1, cons(2, nil))) | [ 0, 1, 2 ] || x.first() | first(x) | 0 || x.rest() | rest(x) | [ 1, 2 ] || x.rest().first() | first(rest(x)) | 1 || x.rest().rest() | rest(rest(x)) | [ 2 ] || x.rest().rest().first() | first(rest(rest(x))) | 2 || x.rest().rest().rest() | rest(rest(rest(x))) | [ ] || ImList y = x.rest().cons(4); | y = cons(4, rest(x)) | [ 4, 1, 2 ] |  이 구조에서 x 와 y 는 [1,2] 를 서로 공유 하고 있다는 것을 알고 있을것.**Recursive datatype definitions**  추상 데이터 타입의 ImList 는 두 구체적인 클래스 Empty , Cons 로 구성되어 있다.      하지만 ImList 또한 자기 자신을 재귀적으로 사용할 수 있다    ImList&lt;E&gt; = Empty + Cons(first:E, rest:ImList)    이러한 형식의 정의는 다음과 같다.          왼쪽이 추상 자료형, 오른쪽이 표현      포현은 + 로 구분된 데이터의 유형의 변형으로 구성      각각의 변형은 인자를 가진 constructor이다.        재귀형 데이터 타입의 다른 예인 이진트리          Tree&lt;E&gt; = Empty + Node(e:E, left:Tree&lt;E&gt;, right:Tree&lt;E&gt;)      **Functions over recursive datatypes**  변형이 있는 추상 데이터타입의 재귀적 정의는 무한 구조 처리, 각 타입에 대한 변형의 트리 구조 성립등에 이점을 갖는다.  예를 들어 사이즈를 측정하는 경우          size : ImList → int  // returns the size of the list        그리고 size의 크기를 정의한다.          size(Empty) = 0      size(Cons(first: E, rest: ImList)) = 1 + size(rest)        이러한 식을 다음과 같이 재귀적으로 볼 수 있다.size(Cons (0, Cons (1, Empty))) = 1 + size(Cons (1, Empty)) = 1 + (1 + size(Empty)) = 1 + (1 + 0) = 1 + 1 = 2이 정의로 자바 코드 작성public interface ImList&lt;E&gt; {    // ...    public int size();}public class Empty&lt;E&gt; implements ImList&lt;E&gt; {    // ...    public int size() { return 0; }}public class Cons&lt;E&gt; implements ImList&lt;E&gt; {    // ...    public int size() { return 1 + rest.size(); }}  이러한 재귀적 패턴을 구현하는법          추상 데이터 타입 인터페이스에서 연산을 선언      각각의 구체적인 변형에서 작동 실행            이러한 재귀적 패턴의 몇가지 예시    isEmpty : ImList → boolean          isEmpty(Empty) = true      isEmpty(Cons(first: E, rest: ImList)) = false        append: ImList × ImList → ImList          append(Empty, list2: ImList) = list2      append(Cons(first: E, rest: ImList), list2: ImList) = cons(first, append(rest, list2))      Tuning the rep      위의 size() 는 O(n) 시간이 소모  하지만 처음 계산 할때 크기 계산하는 방식으로 구성하면 O(1)      public class Cons&lt;E&gt; implements ImList&lt;E&gt; {      private final E e;      private final ImList&lt;E&gt; rest;      private int size = 0;      // rep invariant:      //   e != null, rest != null, size &gt;= 0      //   size &gt; 0 implies size == 1+rest.size()          // ...      public int size() {          if (size == 0) size = 1 + rest.size();          return size;      }  }              이러한 형식은 얼핏 보면 size 의 변화로 mutable하게 보인다. 하지만 이러한 방식은 beneficent mutation이다.      **Rep independence and rep exposure revisited**  우리는 이러한 클래스들을 숨겨오는것을 배웠고 pacakage-private를 활용해 더 잘 숨길수 있을것 이다.  오히려 size() 내 부에 배열을 숨기는 식으로 공간을 희생하고 더 빠른 계산의 가능Null vs empty  null 을 사용하고 싶은 욕구 주의  null 을 사용하면 매번 null 체크를 해야함          if (lst != null) n = lst.size();        코드가 더러워질 수가 있음          n = lst.size();      **Declared type vs. actual type**  type checking에는 컴파일 타임, 프로그램 실행 타임, 런타임 3가지로 나뉜다.          컴파일 시간에는 선언된 타입을 가진다 모든 메소드에 유형을 추론하여 검사한다.      런타임에는 실제 유형을 바탕으로 객체를 만든다. → 인터페이스를 선언할려고 하면 잡아낸다.      **Another example: Boolean formulas**  (P ∨ Q) ∧ (¬P ∨ R)이거를 아래와 같이 적기가 가능하다.Formula = Variable(name:String)          + Not(formula:Formula)          + And(left:Formula, right:Formula)          + Or(left:Formula, right:Formula)**Backtracking search with immutability**  서로 다른 인스턴스를 관리 하기위해 불변 리스트로 시작했지만 리스트의 끝만 공유 하는 방식으로 우린 수정했다.  backtracking 방식은 이런 목록에서 매우 우수하다.  단 mutable 리스트에는 이러한 백트래킹이 좋진 않다.  공유가 없는 immutable 또한 좋진 않다.  공유적인 immutable 리스트에 backtracking이 좋다는걸 기억하자."
  },
  
  {
    "title": "Recursion",
    "url": "/learninghub/Recursion/",
    "categories": "",
    "tags": "",
    "date": "2024-12-15 00:00:00 +0900",
    





    
    "snippet": "Recursion(23.09.27)Object  recursion 문제를 base case와 recursive steps로 분리 할 수 있습니다.  recursion에 help methods를 이해합니다.  recursion vs iteation 의 장단점을 이해합니다.Recursion  이미 recursion에 대한 사양을 가지고 있을때, 어떻게 구...",
    "content": "Recursion(23.09.27)Object  recursion 문제를 base case와 recursive steps로 분리 할 수 있습니다.  recursion에 help methods를 이해합니다.  recursion vs iteation 의 장단점을 이해합니다.Recursion  이미 recursion에 대한 사양을 가지고 있을때, 어떻게 구현하면 좋은가?  recursion은 모든 프로그램에 적절하다고는 볼 수 없지만 개발 도구 중 하나로는 여전히 중요한 방식입니다.  일반적으로 피보나치 함수와 나누기에 대해서 재귀를 사용한다.  재귀 함수는 base case와 recursive steps로 나누어진다.          base case : 함수 호출에 대해 즉시 결과를 계산한다.      recursive steop : 하나 이상의 재귀적 호출에 도움을 받아 계산        팩토리얼에 대해서 아래 두가지 예시          Iterative          public static long factorial(int n) {    long fact = 1;    for (int i = 1; i &lt;= n; i++) {      fact = fact * i;    }    return fact;  }              Recursive          public static long factorial(int n) {    if (n == 0) {      return 1;    } else {      return n * factorial(n-1);    }  }              recursive 구현에서 n = 0 일때 즉시 값을 반환한다. → Base case      n &gt; 0 보다 클 때 재귀를 호출 → Recursice steps      이를 시각화        | starts in  main | calls  factorial(3) | calls  factorial(2) | calls  factorial(1) | calls  factorial(0) | returns to  factorial(1) | returns to  factorial(2) | returns to  factorial(3) | returns to  main |  | — | — | — | — | — | — | — | — | — |    자기자신인 factorial(n- 1) 을 호출하면서 call Stack을 쌓이게 하고 그 후에 풀어가면서 계산하는 방식      다른 예 피보나치      /**   * @param n &gt;= 0   * @return the nth Fibonacci number   */  public static int fibonacci(int n) {      if (n == 0 || n == 1) {          return 1; // base cases      } else {          return fibonacci(n-1) + fibonacci(n-2); // recursive step      }  }        피보 나치는 n= 0 과 n = 1의 base case를 가지고 있다.**Choosing the Right Decomposition for a Problem**  재귀를 위해 문제를 분해하는 것은 중요하다.  좋은 decompositions(분해)는 짧고, 이해하기 쉽고, 버그에 안전하고, 변화에 유연해야한다.      다음과 같은 명세를 가정하자      /**   * @param word consisting only of letters A-Z or a-z   * @return all subsequences of word, separated by commas,   * where a subsequence is a string of letters found in word   * in the same order that they appear in word.   */  public static String subsequences(String word)        subsequences(\"abc\") 의 경우 \"abc,ab,bc,ac,a,b,c,” 분해 한다면?      다음과 같은 재귀 코드를 작성할 수 있다.       1 public static String subsequences(String word) {   2     if (word.isEmpty()) {   3         return \"\"; // base case   4     } else {   5         char firstLetter = word.charAt(0);   6         String restOfWord = word.substring(1);   7   8         String subsequencesOfRest = subsequences(restOfWord);   9  10         String result = \"\";  11         for (String subsequence : subsequencesOfRest.split(\",\", -1)) {  12             result += \",\" + subsequence;  13             result += \",\" + firstLetter + subsequence;  14         }  15         result = result.substring(1); // remove extra leading comma  16         return result;  17     }  18 }      **Structure of Recursive Implementations**  Base case : 더 이상 분해 할 수 없는 경우 빈 문자열, 빈 리스트, 빈 트리, 0 등등…  recursive step : 분해할 수 있는 것 작게 분해 후 재결합하여 문제를 해결하는 단계  문제를 최대한 작게 분할 하는 것은 중요하다 이렇게 하지 않으면 재귀가 끊나지 않을 가능성도 존재Helpe Methods  subsequences() 는 문제를 decomposition 하고 재귀적으로 해결하는 예시이다.  이러한 subproblem을 만들어서 문제를 해결하는 방식은 direct recursive implenation 이다.  어떠한 케이스의 경우 명세에서 recursive step에 대한 강력한 명세를 표현하는 것은 재귀적 분해를 더 우아하게 도와준다.  이러한 경우 부분적인 subsequence를 활용하여 부분적인 완성을 한다면?  예를 들어 “orange”가 있다면 첫 글짜 “o” 를 받고 “range” 는 재귀적으로 확장을 시도한다.      이를 코드로 작성한다면…      /**   * Return all subsequences of word (as defined above) separated by commas,   * with partialSubsequence prepended to each one.   */  private static String subsequencesAfter(String partialSubsequence, String word) {      if (word.isEmpty()) {          // base case          return partialSubsequence;      } else {          // recursive step          return subsequencesAfter(partialSubsequence, word.substring(1))               + \",\"               + subsequencesAfter(partialSubsequence + word.charAt(0), word.substring(1));      }  }        이러한 subsequencesAfter 를 helper method 라고 부른다.  이것은 본래 subsequences 와는 다른 명세를 만족시킵니다. 새로운 파라미터를 가지고 있기 때문에 (partialSubsequence)  이 매개변수는 단순한 반복에서 사용하는 지역 변수와 비슷한 역할을 한다.  이것은 단어의 끝까지 도달하는 것을 부분 연속을 유일한 결과로 반환한다.  이러한 재귀는 가능한 시퀸스를 백트랙킹한다.      구현을 완료하기 위해, 원본을 구현한다.      public static String subsequences(String word) {      return subsequencesAfter(\"\", word);  }        helper method 를 사용자에게 노출시키지 말것.  이런 helper method를 명세를 변경할 필요는 없다. → 이는 변경성을 저하  사용자는 언제나 기존의 방식을 유지한것처럼 보이게 하자.**Choosing the Right Recursive Subproblem**      다음과 같은 예제 integer 를 string (2진법)으로 변환하는 예제      **   * @param n integer to convert to string   * @param base base for the representation. Requires 2&lt;=base&lt;=10.   * @return n represented as a string of digits in the specified base, with   *           a minus sign if n&lt;0.   */  public static String stringValue(int n, int base)        stringValue(16, 10) 는 10000 를 리턴한다.      음수를 처리할려면 이 코드를 추가한다.    if (n &lt; 0) return \"-\" + stringValue(-n, base);    n = 829 ( 10진수 ) 라고 가정할때 어떤식으로 재귀로 분리 하겠는가?**Recursive Problems vs. Recursive Data**  우리가 봐왔던 케이스의 경우는 문재 구조가 자연스럽게 재귀적인 겅의를 부여하는 경우  재귀적 문제는 도구 상자에서 재귀적 해결을 꺼내는 것과 같다.  만약에 데이터 자체가 재귀적인 경우에는?          대표적으로 파일 시스템 A 폴더 → B 폴더 → C파일        java.io.File 은 대표적으로 파일 사용에 사용되는 라이브러리  f.getParentFile() 은 f 파일의 상위 폴더를 반환하는 메소드      이런 재귀적 데이터의 경우 자연스럽게 재귀 구조를 갖는다.      /**   * @param f a file in the filesystem   * @return the full pathname of f from the root of the filesystem   */  public static String fullPathname(File f) {      if (f.getParentFile() == null) {          // base case: f is at the root of the filesystem          return f.getName();      } else {          // recursive step          return fullPathname(f.getParentFile()) + \"/\" + f.getName();      }  }      Reentrant Code  재진입 이라는 용어는 일반적인 프로그래밍에서 특별한 경우에 속한다.  재진입 코드는 안전하게 재진입 하기에 호출되는 와중에도 재 진입이 가능하다.  재진입 코드는 파라미터와 지역변수의 상태를 전체적으로 안전하게 지켜준다.  전역변수의 사용을 없애고 가변 객체의 aliasese와 공유하지 않는다.  Direct recursion은 재진입이 일어날 수 있는 한가지 방법으로, factorial() 메소드는 factorial(n) 의 작업이 끝나지 않았지만 factorial(n-1) 을 호출 하는 방법으로 디자인 되어졌습니다.  Mutal recursion은 두개 또는 더 많은 경우가 일어날 수 있다.          A가 B를 호출하고 다시 A를 호출한다.      이러한 방식은 항상 프로그래머가 의도적으로 설계 하는 방식이지만 버그를 초래할 수도 있다.        Concurrency에서도 일어날 수 있다.  재진입 코드는 언제나 안전하게 사용해야함을 잊지 말자**When to Use Recursion Rather Than Iteration**  재귀를 사용하는 두 유형에 대해 공부했다          문제 자체가 자연스럽게 재귀일때      데이터가 재귀일때        재귀를 사용하는 또 다른 이유는 불변성입니다.  이상적인 재귀 구현에 있어 모든 변수는 상수 이고 불변성을 가져야합니다.  재귀 메소드는 어떠한 것도 변형하지 않는다는 점에서 순수한 메소드입니다.  메소드를 파라미터와 리턴 값에 대한 관계로 이해할 수 있다면 side effects는 없다고 볼 수 있다.  다양한 함수적 프로그래밍에서 이러한 이점을 가지며 명령형 프로그래밍 보다 이해하기가 쉽다.  하지만 재귀 구조에서는 많은 임시 변수가 선언되기에 이러한 동작을 스냅샷을 그리기에는 조금 복잡하다  또한 반복 솔류션 보다 공간 복잡도가 높다는 것인데 call Stack을 호출하한다는 단점이 있다.**Common Mistakes in Recursive Implementations**  재귀에서 일어날 수 있는 실수          Base case의 누락      더이상 밑의 step으로 감소되지 못함 → 무한 재귀      Summary  오늘 공부한 내용          재귀 문제와 재귀 데이터      재귀 문제의 대안적 해결      Helper method      반복 vs 재귀        재귀는 불변 객체를 사용하기에 버그로부터 안전해진다  재귀는 반복 솔루션보다 짧기에 이해가기가 쉽다.  재귀는 변화에 유연하다."
  },
  
  {
    "title": "Interface",
    "url": "/learninghub/Interface/",
    "categories": "",
    "tags": "",
    "date": "2024-12-15 00:00:00 +0900",
    





    
    "snippet": "Interface (23. 10. 11)Objectives  ADT를 정의하고 인터페이스를 구현하는 클래스를 작성하기Interfaces  자바의 interface 는 추상 데이터 유형 표현해 유용한 언어 메커니즘  메서드 시그니쳐는 있지만… bodies는 없다.  interface 는 모든 메서드에 대한 메서드 bodies를 정의한다. 따라서 JAVA...",
    "content": "Interface (23. 10. 11)Objectives  ADT를 정의하고 인터페이스를 구현하는 클래스를 작성하기Interfaces  자바의 interface 는 추상 데이터 유형 표현해 유용한 언어 메커니즘  메서드 시그니쳐는 있지만… bodies는 없다.  interface 는 모든 메서드에 대한 메서드 bodies를 정의한다. 따라서 JAVA에서 인터페이스는 추상 데이터 타입을 정의하는데 한가지 방법으로 사용된다.  이러한 방식을 사용하는 장점은 사용자에게 contract를 명시하고 더이상은 아니라는 것이다.  사용자가 ADT를 이해하는 것 오직 그뿐  interface 에는 인스턴스 변수를 넣을 수가 없기에 의도치 않은 종속성이 생성될 위험이 없음  구현은 서로 다른 클래스에서 분리된다.  Interface는 여러 클래스와 프로그램에서 동시에 존재가 가능하다.  하나의 클래스로만 추상 데이터 타입을 표시한다면 더 어려워진다. → 일반적인 클래스는 두 표현을 동시에 적을 수 없다.  자바의 Static checking은 ADT에 대해서 컴파일러가 여러 실수를 잡을 수 있게도 도와준다.**Example: MyString**      MyString 의 예제를 다시 보자      /** MyString represents an immutable sequence of characters. */  public interface MyString {          // We'll skip this creator operation for now      // /** @param b a boolean value      //  *  @return string representation of b, either \"true\" or \"false\" */      // public static MyString valueOf(boolean b) { ... }          /** @return number of characters in this string */      public int length();          /** @param i character position (requires 0 &lt;= i &lt; string length)       *  @return character at position i */      public char charAt(int i);          /** Get the substring between start (inclusive) and end (exclusive).       *  @param start starting index       *  @param end ending index.  Requires 0 &lt;= start &lt;= end &lt;= string length.       *  @return string consisting of charAt(start)...charAt(end-1) */      public MyString substring(int start, int end);  }            Constructort를 사용하서 아래의 첫번째 구현      public class SimpleMyString implements MyString {          private char[] a;          /* Create an uninitialized SimpleMyString. */      private SimpleMyString() {}          /** Create a string representation of b, either \"true\" or \"false\".       *  @param b a boolean value */      public SimpleMyString(boolean b) {          a = b ? new char[] { 't', 'r', 'u', 'e' }                : new char[] { 'f', 'a', 'l', 's', 'e' };      }          @Override public int length() { return a.length; }          @Override public char charAt(int i) { return a[i]; }          @Override public MyString substring(int start, int end) {          SimpleMyString that = new SimpleMyString();          that.a = new char[end - start];          System.arraycopy(this.a, start, that.a, 0, end - start);          return that;      }  }            최적화 구현      public class FastMyString implements MyString {          private char[] a;      private int start;      private int end;          /* Create an uninitialized FastMyString. */      private FastMyString() {}          /** Create a string representation of b, either \"true\" or \"false\".       *  @param b a boolean value */      public FastMyString(boolean b) {          a = b ? new char[] { 't', 'r', 'u', 'e' }                : new char[] { 'f', 'a', 'l', 's', 'e' };          start = 0;          end = a.length;      }          @Override public int length() { return end - start; }          @Override public char charAt(int i) { return a[start + i]; }          @Override public MyString substring(int start, int end) {          FastMyString that = new FastMyString();          that.a = this.a;          that.start = this.start + start;          that.end = this.start + end;          return that;      }  }        이전의 ADT와 비교한다면 static valueOf 가 현재 생성자 안에서 나타나며 this 를 사용하고 있다.  또한 @Override 의 표현의 사용 해당 annotation은 컴파일러에게 인터페이스의 메소드 중 하나와 동일한 시그니쳐를 가짐을 알린다.  물론 코드의 이해를 돕기 위해서도 사용된다.  우리가 새로 만든 substring(...) 에 집중하자면 이건 데이터의  빈 생성자의 경우 자바가 기본적으로 명시해준다.  하지만 boolean b를 받는 생성자를 추가함으로써 기본 생성자 또한 적어줘야한다.  좋은 ADT는 자신의 불변량을 보존한다.  아무것도 하지 않은 생성자는 좋지 않은 패턴이다. → 불변량을 설정하지 않으니깐…      사용자가 해당 ADT를 사용한다면..?      MyString s = new FastMyString(true);   System.out.println(\"The first character is: \" + s.charAt(0));            아래 코드와 많이 유사하다.      List&lt;String&gt; s = new ArrayList&lt;String&gt;();  ...        이 코드는 오히려 추상화 장벽을 무너트린다… 왜?  Client가 구체적인 class 이름을 알아야함  Java의 인터페이스는 생성자를 포함할 수 없기 때문에 실제로 생성자는 관련된 클래스 중에서 하나를 직접 호출해야하지만 그 생성자의 spec은 인터페이스에 적어져 있지 않음. → 동일한 생성자가 적용된다는 보장이 없음  Java 8 이상에서는 static methods가 포함되도록 허용되어 Creator 연산을 흉내낼 수 있다.      valueOf 방식으로 static factory method 추가한 코드      public interface MyString {          /** @param b a boolean value       *  @return string representation of b, either \"true\" or \"false\" */      public static MyString valueOf(boolean b) {          return new FastMyString(true);      }          // ...              추상화 장벽을 허물지 않고 ADT를 사용          MyString s = MyString.valueOf(true);  System.out.println(\"The first character is: \" + s.charAt(0));      Example : Set  Java Collection 제공하는 interface와 구현을 분리하는 예      Set 인터페이스      /** A mutable set.   *  @param &lt;E&gt; type of elements in the set */  public interface Set&lt;E&gt; {            Set 은 generic 타입이다. → 타입은 추후에 결정됨          // example creator operation      /** Make an empty set.       *  @param &lt;E&gt; type of elements in the set       *  @return a new set instance, initially empty */      public static &lt;E&gt; Set&lt;E&gt; make() { ... }        make  는 static factory 방식으로 구현됩니다.  Set&lt;String&gt; strings = Set.make();      그리고 컴파일러는 새로운 Set 과 String object를 만드는 것으로 이해합니다.      // example observer operations          /** Get size of the set.       *  @return the number of elements in this set */      public int size();          /** Test for membership.       *  @param e an element       *  @return true iff this set contains e */      public boolean contains(E e);        다음으로 두개의 observer 메서드 가 있다.  집합(set)에 대한 추상적인 개념으로 볼때 spec이 어떤지 .      특정 private field가 있는 집합의 특정 구현에 새부적인 구현을 언급하는것은 옳지 않다.       // example mutator operations          /** Modifies this set by adding e to the set.       *  @param e element to add */      public void add(E e);          /** Modifies this set by removing e, if found.       *  If e is not found in the set, has no effect.       *  @param e element to remove */      public void remove(E e);      **Why Interfaces?**  왜 인터페이스를 사용하는가?  컴파일러와 인간 모두를 위한 문서 : 인터페이스는 컴파일러가 버그를 static Checking 하는 것 뿐만 아니라 다른 사람이 코드를 읽기 쉽게 한다.  성능 절충 허용 : 지역 독립적인 코드 사용의 제공  선택적인 메소드 : mutable / immutable 를 선택적으로 제공  과소 결정된 메서드 : ADT는 요소 순서를 지정하지 않은채로 정렬, 비 정렬로 변환을 제공한다.  클래스의 다양한 시각 : 자바 클래스는 다양한 메서드로 구현 될 수 있습니다. 하나의 인터페이스로 구현된 클래스로 서로 다른 UI를 제공가능하다. (위젯과 위젯 목록 UI)  신뢰성이 떨어지는 구현 : 인터페이스는 버그를 포함할 수 있습니다. 그렇기에 계속해서 더 우수한 인터페이스를 구현해 버그가 발생하는 가능성을 낮출 수 있다.**Realizing ADT Concepts in Java**            ADT concept      Ways to do it in Java      Examples                  Abstract data type      Single class      http://docs.oracle.com/javase/8/docs/api/java/lang/String.html                     Interface + class(es)      http://docs.oracle.com/javase/8/docs/api/java/util/List.html and http://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html              Creator operation      Constructor      http://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#ArrayList–                     Static (factory) method      http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#singletonList-T-, http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T…-                     Constant      http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html#ZERO              Observer operation      Instance method      http://docs.oracle.com/javase/8/docs/api/java/util/List.html#get-int-                     Static method      http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#max-java.util.Collection-              Producer operation      Instance method      http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#trim–                     Static method      http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-java.util.List-              Mutator operation      Instance method      http://docs.oracle.com/javase/8/docs/api/java/util/List.html#add-E-                     Static method      http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#copy-java.util.List-java.util.List-              Representation      private fields             Summary  자바 인터페이스는 추상적인 데이터 타입을 연산을 지원하는 집합으로 공식화 하는데 도움을 준다."
  },
  
  {
    "title": "Exception",
    "url": "/learninghub/Exception/",
    "categories": "",
    "tags": "",
    "date": "2024-12-15 00:00:00 +0900",
    





    
    "snippet": "Exceptions (23.09.23)Exceptions for signaling bugs  자바 프로그래밍에는 다양한 예외가 있다.          ArrayIndex-OutOfBoundsExceions 같은…      NullPointerException 또한 일반적인 예외이다.      NumberFormatException 은 Interger....",
    "content": "Exceptions (23.09.23)Exceptions for signaling bugs  자바 프로그래밍에는 다양한 예외가 있다.          ArrayIndex-OutOfBoundsExceions 같은…      NullPointerException 또한 일반적인 예외이다.      NumberFormatException 은 Interger.parseInt 정수로 구문 분석할수 없는 문자열을 전달하는 경우의 예외도 있다.      Exceptions for special results  예외는 신호적인 버그뿐만 아니라 그들은 코드의 구조를 향상시킬수 있습니다. 특별한 결과함께 절차적인 것을 포함하여  자바의 Look up 은 양의 정수를 기대해거나 또는 객체에 대한 null 참조를 할때 -1의 인덱스를 얻을 수 있습니다.  어느정도는 이러한 방식을 사용해도 괜찮습니다. 하지만 두가지 문제점이 있다.          리턴값을 매번 확인해야한다.      이걸 잊어버리기 쉽다.            또한 특별한 값을 찾는것은 쉽지 않다. 아래 BirthdayBook 을 가정해보자.      class BirthdayBook {      LocalDate lookup(String name) { ... }  }        해당 메소드에 어떤 사람의 생일인지를 고려하지 않는 경우  우리는 이런 경우 특별한 결과를 리턴할 수 있다. (ex: 99.9.9) 같은 경우      예외를 사용하는 경우      LocalDate lookup(String name) throws NotFoundException {      ...      if ( ...not found... )          throw new NotFoundException();      ...      BirthdayBook birthdays = ...try {    LocalDate birthdate = birthdays.lookup(\"Alyssa\");    // we know Alyssa's birthday} catch (NotFoundException nfe) {    // her birthday was not in the birthday book}Checked and unChecked exceptions  위에서 우리는 특별한 결과와 버그를 위해 예외를 사용했다.  Checked exception은 다음과 같이 불린다.          RuntimeException 을 상속하지 않은 클래스      메소드에서 예외를 체크한다면 확인된 예외를 미리 선언을 해야한다. thowrs 를 활용      만약 다른 메소드가 호출한다면 마찬가지로 선언해야한다 그렇지 않으면 예외가 전파된다.        이런식으로 예외를 미리 선언하지 않으면 컴파일러가 거부한다.  ← 매우 유용  unChecked exception 같은 경우 버그를 알리는데 사용된다.          RuntimeException 을 상속하는 클래스        이 예외는 아마 가장 높은 수준을 제외하고는 밑에서는 다루지 못한다.  우리는 모든 메소드가 낮은 콜 레밸에서 선언되져야 할것을 원하지는 않는다. 다양한 버그의 예외가  결과적으로 unchecked exception은 컴파일러가 체크하지 못합니다. try - catch 나 a throws 같은 선언으로  자바는 여전히 허용합니다 당신이 a throws 를 사용하는 것을 unchecked exception의 부분으로써 그러나 추천하진 않는다,.Throwable hierarchy  어떻게 자바가 예외를 결정하는지를 이해하기 위해서는 계층 구조를 봐야한다.  Throwable 클래스는 thrown 하거나 caught할 수 있다.          어디서 예외를 던지는지에 대한 스택 포인터의 추적      예외의 optional string을 묘사한다.        어떤 객체가 throw 나 try-cathc 를 사용한다면 또는 선언한다면 이 클래스의 자식이 된다.  Error 클래스는 Throwable 의 자식으로써 자바 런타임 시스템에 의해 생성된 오류가 예약되어 있다.          stackoverflow 나 OutOfMemory 같은…      AssertionError 같은거 또한 Error의 확장이다, 이것이 런타임이 아닌 유저코드에서 나타나는 버그임에도 불구하고 에러는 회복 불가능한걸로 고려되며. 일반적으로 발견되지 않는다      간단하게 처리 할수 없는 에러!        확인된 예외와 확인되지 않은 예외를 구분하는 방법          RuntimeException , Error 이것들의 자식은 unchecked Exception이다. 컴파일러는 이것들에게 선언할것을 강요하지 않는다. 물론 호출자 또한      Throwable 과 Exception 의 모든 자식들은 checked Exception이다.  이런것들은 컴파일러가 throws 할것을 요구한다. (RuntimeException 의 자식이 아니라면)        예외를 정의할때, 서브클래스 중 하나를 선택해야한다. RunTimeException 또는 Exception 들 중에 Error 와 Throwable 는 자바 자체적으로 예약되어 있기에 하지 않아도 된다.Exception design considerations  특별한 결과에 대해선 checked exceptions을 버그에 대해서는 unchecked exception을 사용하는 규칙은 좋지만 자바의 예외는 끝이 아니다.  성능적인 패널티 외에도 예외에 대한 새로운 클래스를 만든느 것은 더 큰 비용을 요구한다. 만약 checked exception가 야기될수 있는 메소드일 경우 try-catch로 덮어야한다. 만약에 절대 던지지 않을 것이라고 알고 있는 경우 딜레마를 야기  예를 들어 큐 추상화를 디자인 할 경우          큐가 비어있을 때 pop의 경우 예외를 던져야 하는건 맞다.      만약 클라이언트가 예외가 아닌 대기열이 비지 않았을때만 pop하게 한다면 메소드를 사용하는 클라이언트 또한 try-catch를 던져야하는가?        이러한 규칙에 대해서 제시한다.          unchecked Exception은 버그를 알리는데에만 사용되여야 한다.      또한 편리하고 저렴하게 예외를 피할 방법이 있는 경우 에만 uncheckd exception을 작성한다.      그렇지 않으면 checked exception을 사용한다.        Example          큐에서 pop 할 경우 큐가 비어져있다면 EmptyQueueException 을 던질경우 caller 가 큐가 비었음을 먼저 테스트 해서 이를 피할수 있다.      Url.getWebPage() 같은 경우는 호출자가 예외를 피하기 쉽지 않기 때문에 checked IOException을 활용      int integerSquareRoot(int x) 깉은 경우 x가 완벽한 제곱근인지 찾는 것은 매우 어렵다 그렇기에 예외를 사용한다.      Abuse of exceptions      예외 남용의 예      try {      int i = 0;      while (true)          a[i++].f();  } catch (ArrayIndexOutOfBoundsException e) { }              이건 무한루프로써 예외를 통해 끝내는 경우          for (int i = 0; i &lt; a.length; i++) {      a[i].f();  }              이거와 완전하게 동일        자바의 Exception은 예외적인 상황에서 동작하게 만들었다 성능적인것은 기대하지 않는다.  또한 다른 버그가 숨어 있을 수 도 있다.  일반적인 루프를 사용시 예상되지 않은 엘 발생 할 경우 스택을 추적하여 종료한다.  하지만 예외기반 루프는 버그 기반 예외일 경우 일반적인 루프의 종료로 해석한다."
  },
  
  {
    "title": "Equality",
    "url": "/learninghub/Equality/",
    "categories": "",
    "tags": "",
    "date": "2024-12-15 00:00:00 +0900",
    





    
    "snippet": "Equality(23. 10. 13)Introduction추상화 함수에서 equality 연산을 정의 하는 방법**Three Ways to Regard Equality**  equality를 바라보는 다양한 방법  추상화 함수 사용(Using an abstraction function)          추상화 함수 $F$ 를 정의해 $F(a) = F(...",
    "content": "Equality(23. 10. 13)Introduction추상화 함수에서 equality 연산을 정의 하는 방법**Three Ways to Regard Equality**  equality를 바라보는 다양한 방법  추상화 함수 사용(Using an abstraction function)          추상화 함수 $F$ 를 정의해 $F(a) = F(b)$ 인 경우에만 equality를 확정        관계를 이용(Using a relation)          equilvalence(동치) E ⊆ T X T 아래와 같다.                  reflexive(반사): E(t,t) ∀ t ∈ T          symmetric(대칭): E(t,u) ⇒ E(u,t)          transitive(추론): E(t,u) ∧ E(u,v) ⇒ E(t,v)                    E의 equality를 정의를 사용한다면 우리는 오직 E(a,b) 일때만 equals하다고 말 할수 있다.        위는 추상화 함수로 유도된 동등성 관계이다.  Using observation(관찰 이용)          호출해서 직접 관찰하기                                                                              {1,2}                  = 2 and                  {2,1}                  = 2                                                              1 ∈ {1,2} is true, and 1 ∈ {2,1} is true          2 ∈ {1,2} is true, and 2 ∈ {2,1} is true          3 ∈ {1,2} is false, and 3 ∈ {2,1} is false          … and so on                    Example: Durationpublic class Duration {    private final int mins;    private final int secs;    // rep invariant:    //    mins &gt;= 0, secs &gt;= 0    // abstraction function:    //    represents a span of time of mins minutes and secs seconds    /** Make a duration lasting for m minutes and s seconds. */    public Duration(int m, int s) {        mins = m; secs = s;    }    /** @return length of this duration in seconds */    public long getLength() {        return mins*60 + secs;    }}  equal 한가?Duration d1 = new Duration (1, 2);Duration d2 = new Duration (1, 3);Duration d3 = new Duration (0, 62);Duration d4 = new Duration (1, 2);**== vs. equals()**  Java가 가지고 있는 동등성 연산          == 참조를 비교 한다. (참조 평등을 테스트) , 메모리의 같은 저장소를 가르킨다면 동일하다.      equals() 개체의 내용의 동일성      **Equality of Immutable Types**  equals 의 정의public class Object {    ...    public boolean equals(Object that) {        return this == that;    }}  기본적으로 == 와 동일하다.  그런데 immutable 타입도 이렇게 할수 있을까…?  Duration 의 equlaspublic class Duration {    ...    // Problematic definition of equals()    public boolean equals(Duration that) {        return this.getLength() == that.getLength();    }}      해당 코드의 반례      Duration d1 = new Duration (1, 2);  Duration d2 = new Duration (1, 2);  Object o2 = d2;  d1.equals(d2) → true  d1.equals(o2) → false              오버로드의 발생으로 위의 메소드가 실현되버린다.            equlas 를 표현한다면?      public class Duration extends Object {      // explicit method that we declared:      public boolean equals (Duration that) {          return this.getLength() == that.getLength();      }      // implicit method inherited from Object:      public boolean equals (Object that) {          return this == that;      }  }              Static checking에서 자바 컴파일러는 매개변수에 따라 메소드 오버로딩을 실행      d1.equals(o2) 와 d1.equals(d2) 는 같은 객체를 가르키지만 평등성이 어긋나는 예            개선된 equals()      @Override  public boolean equals (Object thatObject) {      if (!(thatObject instanceof Duration)) return false;      Duration thatDuration = (Duration) thatObject;      return this.getLength() == thatDuration.getLength();  }              해결          Duration d1 = new Duration(1, 2);  Duration d2 = new Duration(1, 2);  Object o2 = d2;  d1.equals(d2) → true  d1.equals(o2) → true      Object Contract  Object 클래스의 명세는 중요하다.  equals 를 정의할때 Object 의 equals 를 오버로딩 하는 방식으로 진행된다.          equals 의 동치 관계를 정의해야한다. → 반사적, 대칭적, 전이적 관계의 정의      equals 가 일치해야한다. 메소드의 반복 호출에도 항상 같은 결과를 반환      x.equals(null) 는 언제나 false를 반환해야한다.      hasCode 는 equals 에 대해 언제나 같은 값을 생산하다.      **Breaking the Equivalence Relation**  equlas() 를 정의 한다면 동치 관계(반사, 대칭, 전이)부터 시작되어야한다.      그렇지 않은 경우 동일성은 불규칙적으로 예측 불가능하게 동작한다. → a와 b는 동등하다. 하지만 b는 a와 동등하지 않는다는 결과      private static final int CLOCK_SKEW = 5; // seconds      @Override  public boolean equals (Object thatObject) {      if (!(thatObject instanceof Duration)) return false;      Duration thatDuration = (Duration) thatObject;      return Math.abs(this.getLength() - thatDuration.getLength()) &lt;= CLOCK_SKEW;  }      Breaking Hash Tables  hashcode 가 어떻게 작동하는지 어느정도 이해해야한다.  HashSet , HashMap 은 HashCode 에 의존하여 hashtable 을 사용하여 데이터를 저장한다.  메소드는 객체를 저장하고 map 에서 key를 사용해 구현한다.  해쉬 테이블은 mapping으로 나타내는데 key로 값을 매핑한다.  다른 트리 보다 우수함  key는 equals 나 hashcode 를 제외하고 특정 속성을 가질 필요가 없다.  저장할 객체가 생기면 key의 hashcode를 계산하고 배열범위의 인덱스로 변환한뒤에 삽입  hashtable의 표현 불변성은 결정된 값에 키가 있다는 제약조건이 있다.  hash 코드는 키가 인덱스 전체에 퍼지도록 설정, 충돌 발생시 각자 처리  Object 는 동일한 개체가 동일한 hashcode를 가져야한다.      hashcode() 를 활용한 equals      private static final int CLOCK_SKEW = 5; // seconds      @Override  public boolean equals (Object thatObject) {      if (!(thatObject instanceof Duration)) return false;      Duration thatDuration = (Duration) thatObject;      return Math.abs(this.getLength() - thatDuration.getLength()) &lt;= CLOCK_SKEW;  }            불변 객체 같은 경우 다른 구현이 필요하다.      Duration d1 = new Duration(1, 2);  Duration d2 = new Duration(1, 2);  d1.equals(d2) → true  d1.hashCode() → 2392  d2.hashCode() → 4823              당연히 다른 객체니 hashcode 는 다르다.        이런 경우의 eqaul성은 어떻게 수정해야할까      가장 합리적인 방법 hashcode()를 @Override 한다. → 나의 equals 한 추상 함수로      @Override  public int hashCode() {      return (int) getLength();  }              성능이 안좋은 해쉬 함수라도 부정확한 함수보다는 낫다.        equals 를 override 할 때에는 항상 hashCode 를 override 할것Equality of Mutable Types  mutable 한 친구들의 equality는?  가변 객체의 equality는 두가지로 나뉜다.          상태가 바뀌지 않고 관찰자로 구분할 수 없을 때 observational equality(관찰 평등) 이라고 불린다.      상태가 바뀜(돌연변이)이며 관찰자로 구분 할수 없을때 bejavioral equality(행동 평등) 이라고 불린다.        immutable의 경우 일반적으로 관찰과 행동이 동일하다.      관찰 동일성은 편하지만 버그가 잠재될 가능성이 있다.      List&lt;String&gt; list = new ArrayList&lt;&gt;();  list.add(\"a\");      Set&lt;List&lt;String&gt;&gt; set = new HashSet&lt;List&lt;String&gt;&gt;();  set.add(list);              이러한 상황에서 아래와 같은 결과        set.contains(list) → true    list.add(\"goodbye\");    set.contains(list) → false! → 더이상 equal 하지 않음      for (List&lt;String&gt; l : set) {      set.contains(l) → false!  }              이런식으로 반복한다면 상황은 더욱 심해진다.      list에 객체가 추가됨으로써 내부주고자 변경된다.(내부요소의 해시코드 기반이기에) hashcode가 변경된다.            java.util.Set 의 명세          Note: Great care must be exercised if mutable objects are used as set elements. The behavior of a set is not specified if the value of an object is changed in a manner that affects equals comparisons while the object is an element in the set.        이러한 주의를 명시하고 immutable 한 객체를 사용하는것도 방법  이러한 상황에서는 행동 평등 의 구현의 필요성**The Final Rule for equals and hashCode()**  Immtable 타입의 경우          equals() 는 추상적인 값을 비교해야합니다. ( 행동 평등 구현 )      hashCode() 는 추상 값으로 매핑해야한다.        Mutable 타입의 경우          equals() 의 경우 참조를 비교해야한다. ( 행동 평등 구현 )      hashCode() 도 참조 값으로 매핑해야한다.      Autoboxing and Equality  Object 형과 원시형의 동등성은…?Integer x = new Integer(3);Integer y = new Integer(3);x.equals(y) → truex == y -&gt; false(int)x == (int)y // returns true      이런 버그를 조심하자      Map&lt;String, Integer&gt; a = new HashMap(), b = new HashMap();  a.put(\"c\", 130); // put ints into the map  b.put(\"c\", 130);  a.get(\"c\") == b.get(\"c\") → ?? // what do we get out of the map?              둘다 결과물이 Integer 라서 false가 나온다!      Summary  Equality 는 동치 관계(반사, 대칭, 추이) 여야한다.  Equality 는 hashCode와 일치해야한다. 그래야 제대로 작동 한다.  추상화 함수는 불변 데이터 형의 Equality 에 기초로 만들어진다.  참조 Equality 는가변 데이터 유형에서 일관성있게 보장하는 방식이다."
  },
  
  {
    "title": "Designing specifications",
    "url": "/learninghub/Designing-Specifications/",
    "categories": "",
    "tags": "",
    "date": "2024-12-15 00:00:00 +0900",
    





    
    "snippet": "**Designing Specifications (23.09.24)**이 장의 목표  underdetermined specs(결정되지 않은 스펙)을 이해하고 식별하고 평가할 수 있다.  선언과 옵셔널을 이해하고 선언 사양을 작성할 수 있다.  전제조건과 사후 조건의 스펙을 이해하고 스펙 강도와 비교할 수 있다.  적절한 스펙을 논리적으로 쓸 수 있습니...",
    "content": "**Designing Specifications (23.09.24)**이 장의 목표  underdetermined specs(결정되지 않은 스펙)을 이해하고 식별하고 평가할 수 있다.  선언과 옵셔널을 이해하고 선언 사양을 작성할 수 있다.  전제조건과 사후 조건의 스펙을 이해하고 스펙 강도와 비교할 수 있다.  적절한 스펙을 논리적으로 쓸 수 있습니다.Introduction  유사한 기능에 대한 스펙을 비교하고 그것들에 상충 관계에 대해 이야기한다.          얼마나 결정적인가? : 스펙은 주어진 입력에 대한 가능한 출력만 정의하는가? 아니면 가능한 아웃풋의 집합 중에 하나를 선택하는가?      얼마나 선언적인가? : 스펙은 출력이 무엇인지를 말하는가? 아니면 출력이 어떻게 이뤄지는지를 말하는가?      얼마나 강한가? : 스펙은 작거나 큰 가능한 구현 집합이 있는가?      **Deterministic vs. underdetermined specs**static int findFirst(int[] arr, int val) {    for (int i = 0; i &lt; arr.length; i++) {        if (arr[i] == val) return i;    }    return arr.length;}static int findLast(int[] arr, int val) {    for (int i = arr.length - 1 ; i &gt;= 0; i--) {        if (arr[i] == val) return i;    }    return -1;}  first와 last는 임시적인 명칭      find 의 명세      static int findExactlyOne(int[] arr, int val)  requires: val occursexactly once in arr  effects:  returns index i such that arr[i] = val        이 명세는 결정론 적이다.  전제 조건이 만족되어질때 출력이 결정되어진다.  위 명세는 오직 하나의 return 값과 하나의 final static 값만 가능하다.  둘 이상의 유효한 출력에 대한 입력 값은 없다.      find 의 또 다른 명세      static int findOneOrMore,AnyIndex(int[] arr, int val)    requires: val occurs in arr    effects:  returns index i such that arr[i] = val        이 명세는 결정적이지 않는데 어떤 인덱스가 하나이상 반환 되어야 하는지는 적어져 있지 않다.  이것은 단순히 return 된 인덱스가 val임만을 의미한다.  이 명세는 하나의 입력에 대해 여러 출력을 허용한다.  비결정적 코드는 동일한 입력에 대해서도 다른 방향으로 동작할 수 있다.          임의의 숫자 및, 프로레스 순서 실행에 따라서…        그러나 명세가 비결정적이라도 구현까지 결정적이지 않을 필요는 없다.  결정적이지 않은 명세는 과소 결정적(underdetermined)이라고 표현한다.  underdetermined find 스펙은 결정적 비결정적 모두를 만족한다. 각각 underdetermined 방식으로 해결  위의 명세는 val 이 두번 이상 나타난다는 명세에 대해 어떤 인덱스가 반환되어야 하는지에 대해서는 의존하지 않는다.  위 명세는 또한 배열의 낮은 곳에서부터 탐색할지 높은곳에서 탐색할지에 대해 비결정적 명세 또한 만족한다.  결국 구현자가 이걸 선택한다.  미결정적 사양은 결정적 구현으로 마무리 짓는다.선언 vs 운영 명세  명세에는 두가지 종류가 있다.  Operational 명세는 메소드가 어떻게 작동하는지에 대한 일련의 과정을 서술          일반적으로 의사코드        Declarative 명세는 단계에 대한 내용이 아닌 최종 결과와 초기 상태에 대한 관계를 알린다.  대부분은 선언 명세가 좋다.          이해하기 쉬움      클라이언트가 의존할 수 이는 구현 세부 정보를 노출하지 않는다. → 변경 될 때 유지보수가 불가능하는 상황)      Ex) 배열에서 val을 발견 할때까지 아래로 내려가고 가장 낮은 인덱스가 반환된다는 것 이건 알릴 필요가 없음      이걸 활용해서 유지 관리자에게 설명하는건 옳지 않다. 그냥 메소드 본문을 설명하자            선언적 명세는 다양한 방법이 가능하다.      static boolean startsWith(String str, String prefix)  effects: returns true if and only if there exists String suffix              such that prefix + suffix == str              static boolean startsWith(String str, String prefix)  effects: returns true if and only if there exists integer i              such that str.substring(0, i) == prefix              static boolean startsWith(String str, String prefix)  effects: returns true if the first prefix.length() characters of str              are the characters of prefix, false otherwise      Stronger vs weaker specs  메소드를 변경하고자 할 때 해당 메소드가 의존하는 사양이 있다. 둘 다에게 안전성을 보장하고 싶은 경우 어떻게 비교할 것인가?  S2 가 S1보다 강하거나 같으면          S2의 전제조건이 S1의 전제조건보다 약하거나 같고      S2의 전제조건을 만족하는 상태에서 S2의 후조건은 S1의 후조건보다 강하거나 같을때        이러한 경우 S2를 만족하는 구현을 통해 S1 또한 만족 할수 있다.  더 나아가 S1는 S2로 대체가 가능하다.  이러한 두 가지 규칙은 몇개의 아이디어가 생긴다.      전제 조건을 약하게 해서 사용자를 만족시키고 메소드내의 약속을 통해 사후조건을 강하게 하는 방법이 있다.      static int findExactlyOne(int[] a, int val)  requires: val occursexactly once in a  effects:  returns index i such that a[i] = val          static int findOneOrMore,AnyIndex(int[] a, int val)  requires: val occursat least once in a  effects:  returns index i such that a[i] = val              전제 조건은 약해졌다.          static int findOneOrMore,FirstIndex(int[] a, int val)  requires: val occursat least once in a  effects:  returnslowest index i such that a[i] = val              하지만 후조건은 강해졌다!      Digramming Specifications  모든 자바 메소드를 하나의 그림으로 상상한다면…  모든 구현 가능한 공간의 영역을 정의하고 지정된 구현은 명세와 각 사전 사후 조건 관계에 따라 영역에 집어 넣는다.  구현의 경계선을 통해 메소드의 구현 범위 또한 알 수 있다.  Client는 이 다이어그램을 보고 명세 내부를 자유롭게 확인하고 변경이 가능하다.  또한 Client의 변경에도 유연성을 제공한다.  유사한 명세의 경우 어떻게 다른것과 관련을 지을 수 있는가?          우리는 S1로 시작하여 S2를 생성한다고 가정한다      전제 조건을 강화한다.                  s2 &gt; s1 이면 s2가 강한 사양으로 인지          사후 조건을 강화하는것은 구현자에게 어떤 의미인것인가? → 실행자의 자유는 적어지고 output의 요구 사항은 더 강해진다.          가장 낮은 index i 를 구현하도록 사후 조건을 강화한다면…          find OneOrMore,AnyIndex 를 내부 구현을 수정한다. → find OneOrMore,FirstIndex          find OneOrMore,AnyIndex 를 보이면서  find OneOrMore,FirstIndex   를 내부에 구현 할 수 있을까? 사후조건이 더강력한 find OneOrMore,FirstIndex 을 사용한다.                      다이어그램에서 강한 명세일수록 더 작은 영역을, 약한 명세이다면 더 큰 영역을 정의함을 볼 수 있다.  find Last 는 모든 다이어그램에서 만족하지만 그곳에서는 find OneOrMore,FirstIndex 는 만족하지 못할 것이다…Designing good Specifications  우수한 메소드란 무엇인가? 주로 명세를 작성한다는것  명세는 읽기 쉬어야하고 깔끔하게 잘 작성해야한다.  명세서의 내용을 규정하기는 어렵다 하지만 몇가지 지침이 있다.**The specification should be coherent**      명세에는 다양한 case를 사용하지 말아야한다 깊게 중첩된 분기문이 주로 예시      static int sumFind(int[] a, int[] b, int val)  effects: returns the sum of all indices in arrays a and b at which               val appears        이건 잘 설계 된 명세인가?          아마 그렇진 않을것이다.      관련 없는 두 작업 (두 array에서 찾고 합산)을 수행하기에 일관성이 떨어진다.      이런 경우 두개의 개별 절차를 적자            또 다른 예시      public static int LONG_WORD_LENGTH = 5;  public static String longestWord;      /**   * Update longestWord to be the longest element of words, and print   * the number of elements with length &gt; LONG_WORD_LENGTH to the console.   * @param words list to search for long words   */  public static void countLongWords(List&lt;String&gt; words)              전역 변수를 사용하는 것도 일관성이 없다.      이것 또한 두 가지 절차로 분리 한다면 조금 더 우수한 명세      **The results of a call should be informative**      또 다른 하나의 명세      static V put (Map&lt;K,V&gt; map, K key, V val)  requires: val may be null, and map may contain null values  effects:  inserts (key, val) into the mapping,                overriding any existing mapping for key, and                returns old value for key, unless none,                in which case it returns null        전제 조건이 null이 저장 될 수 있도록 적으세요  사후 조건에는 null 이 값을 찾지 못했다는 특별한 값으로 사용된다.  이것은 null이 리턴 될 때 실제로 바인딩이 된건지 알 수 없다.  삽입해서 null 인지 아니면 그냥 null인지 알 수 없는 이 디자인은 좋지 않다.**The specification should be strong enough**  사양은 일반적인 경우에서도 충분히 강력한 보증을 가져야한다.  특별한 케이스의 경우 메소드 사용에 있어 특별한 주의를 가져야한다.  예를 들어 허용되지 않은 값이나 인자에 대해 예외를 던지지 않을 경우  사용자가 실제로 어떤게 변화되었는지 결정하지 못할 때 애매한 값에 대해 exception을 던지는 것에 대해서는 별 의미가 없다.      여기 그 예시가 있다.      static void addAll(List&lt;T&gt; list1, List&lt;T&gt; list2)  effects: adds the elements of list2 to list1,               unless it encounters a null element,               at which point it throws a NullPointerException        만약 nullPointException 이 던져 졌을때, 고객들은 lis1인지 list2인지 애매해진다.**The specification should also be weak enough**      파일을 여는 방식에 따른 메소드      static File open(String filename)  effects: opens a file named filename        나쁜 명세의 대표적 예시  중요한 세부사항이 부족하다.  파일이 이미 열렸는지 아니면 생성되었는지 모른다.  파일을 열 방법이 없기 때문에 너무나 강력하다.  또한 다양한 문제가 있을 수 있다 (파일을 열 수 있는 권한이 없거나… 통제 파일 부재)  파일을 여는데 성공한다면 그에 대한 적절한 내용을 표시해야하는 등 더 약한 내용을 표시해야한다.**The specification should use abstract types where possible  앞선 Basic Java에서 추상적인 개념을 구별하는법을 공부 했다.  추상 타입에 대한 명세를 작성할 때 사용자와 구현자 모두 더 많은 자유를 가진다.      자바에서 종종 사용되는 List 나 Map 등은 다음과 같은 명세를 고려한다.      static ArrayList&lt;T&gt; reverse(ArrayList&lt;T&gt; list)  effects: returns a new list which is the reversal of list, i.e.               newList[i] == list[n-i-1]               for all 0 &lt;= i &lt; n, where n = list.size()        사용자는 어떤 List 를 사용할지 모르기에 List 로  추상화 하는것은 현명한 선택이다.**Precondition or postcondition?**  또 다른 설계의 문제는 Precondition 의 여부이다.  전제조건을 사용시 메소드 코드에서 이에 대한 확인 여부가 필요하다.  실제로 전제조건을 사용하는 이유는 메소드 내에서 이를 전제 조건 없이는 힘들기 때문에 이뤄진다.  하지만 전제 조건은 사용자에게 불편을 겪게 한다.  하지만 이렇게 하지 않는다면 오류를 복구 할수 있는 예측가능한 방법이 없다.  그래서 유저들은 전제 조건을 좋아하지 않는다.  자바 API는 적절하지 않은 인자가 확인 될 때 PostCondition 으로 예외를 던지도록 설정한다,.  이러한 방식은 호출자가 버그를 쉽게 찾을 수 있다.  Fall Fast 방식 달성 가능  또한 이러한 방법으로 이진 탐색 때 배열이 정렬되었는지(전제조건)을 미리 확인해 비용을 줄인다.  전제조건의 사용 유무는 공학적 판단 핵심 요소는 점검 비용과 방법의 범위를 색출 하는 것  로컬로만 호출 시 모든 경우를 다 체크하기 가능하다  하지만 모든 개발자가 사용하는 API의 경우는 자바 API처럼 해야한다.**About access control**  일반적으로 우리는 public 을 사용한다.  이러한 방식은 프로그램 어디서든지 접근하게 한다.  하지만 이러한 방식은 프로그램이 로컬로만 사용되지 않는다.  즉 코드가 변경될 준비가 되지 않았다.  이런 내부 도우미 메소드가 공개 된다면 인터페이스에 혼란이 가중된다.  private 를 활용하는 것은 모듈을 더 작고 일관성 있게 한다.  또한 이해하기 쉬워진다.  또한 버그로도 안전해진다.**About static vs. instance methods**  또한 논의 없이 static 을 사용하는것도 문제가 된다.  static 은 일반적으로 정적 객체에서 불러와진다.      일반적으로 지금까지 사용된 예      static int find(int[] arr, int val)  requires: val occurs in arr  effects:  returns index i such that arr[i] = val            int [] 을 사용하여 이걸 대신한다.      int find(int val)  requires: val occurs in this array  effects:  returns index i such thatthe value at index i in this array                is val      요약  명세는 구현자와 사용자 간의 중요한 방화벽의 역할을 한다.  소스코드를 전부 볼 필요 없이 이용 가능한 모듈을 개발이 가능하다.  구현자 또한 설계예 도움  선언적 명세가 가장 유용하다.  전제 조건은 이용자에게 부담을 주지만 결과적으로 가장 도움이 된다."
  },
  
  {
    "title": "Code review",
    "url": "/learninghub/Code-Review/",
    "categories": "",
    "tags": "",
    "date": "2024-12-15 00:00:00 +0900",
    





    
    "snippet": "Code Review (23.09.15)Code Review  본래 코드를 적은 사람이 아닌 다른 사람에게 코드를 보여주고 함께 하는것은 좋다.  코드 리뷰의 두가지 목적          Improving the code : 버그(예상되는)를 찾고 코드의 스타일을 서로 점검하면서 프로젝트의 기준의 일관성을 만든다.      Improving the p...",
    "content": "Code Review (23.09.15)Code Review  본래 코드를 적은 사람이 아닌 다른 사람에게 코드를 보여주고 함께 하는것은 좋다.  코드 리뷰의 두가지 목적          Improving the code : 버그(예상되는)를 찾고 코드의 스타일을 서로 점검하면서 프로젝트의 기준의 일관성을 만든다.      Improving the programmer : 코드 리뷰는 프로그래머가 서로 배우고 학습하는데 좋은 방법, 또한 오픈소스 프로젝트에서 일어나는 다양한 사건에 대해 코드 리뷰는 좋은 대화 수단이 될 수 있다.        코드리뷰는 또한 산업현장에서 또한 동료 개발자들의 Code Review 없이는 push를 불가능하게 함Style Standards  대부분의 회사나 거대한 프로젝트에서는 코딩 스타일을 가진다 (ex: 들여쓰기의 간격, 대괄호와 중괄호의 위치…)      JAVA 또한 일반적인 코드스타일이 있다      if (condition) {statements;  }  if (condition) {  statements;  } else {  statements;  }  if (condition) {  statements;  } else if (condition) {  statements;  } else {  statements;  }        더 자세한 기준은 https://www.oracle.com/java/technologies/javase/codeconventions-statements.html#15395 (업데이트 안됨)    하나의 프로젝트에 소속되어 있다면 그 소속의 코드 스타일을 따르는것은 중요하다.Smeely Examplepublic static int dayOfYear(int month, int dayOfMonth, int year) {    if (month == 2) {        dayOfMonth += 31;    } else if (month == 3) {        dayOfMonth += 59;    } else if (month == 4) {        dayOfMonth += 90;    } else if (month == 5) {        dayOfMonth += 31 + 28 + 31 + 30;    } else if (month == 6) {        dayOfMonth += 31 + 28 + 31 + 30 + 31;    } else if (month == 7) {        dayOfMonth += 31 + 28 + 31 + 30 + 31 + 30;    } else if (month == 8) {        dayOfMonth += 31 + 28 + 31 + 30 + 31 + 30 + 31;    } else if (month == 9) {        dayOfMonth += 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31;    } else if (month == 10) {        dayOfMonth += 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30;    } else if (month == 11) {        dayOfMonth += 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31;    } else if (month == 12) {        dayOfMonth += 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 31;    }    return dayOfMonth;}Don’t Repeat Yourself  위 코드 처럼 복사/붙여넣기 하는 것을 매우 위험한 행위          원본에 버그가 있는 상태에서 복사본 생성시 원본만 수정 할 경우 복사본의 버그는 남아 있음        위 코드에서 “4월” 은 총 8번 중복됨  만약.. 2월이 28일이 아니라 30일이라면..? 총 10줄의 코드를 실행해야함  DRY 원칙을 준수하기 위해 조금 작은 단위로 코드를 나누는 습관을 가지고 그것을 호출에서 사용Comments Where Needed  좋은 프로그래머들은 코드와 Comments(주석)과 함께 한다.  Comments는 코드를 이해하기 쉽게 하고 버그로 부터 더욱 더 안전하게 그리고 변화에 더 유연하게  좋은 Comment를 나타내기 위한 방법 중 하나는 메소드 또는 상위의 클래스의 동작을 문서화 하는 것이다.  자바에서는 Javadoc를 활용      @param , @return 을 사용  아래 예시      /**   * Compute the hailstone sequence.   * See http://en.wikipedia.org/wiki/Collatz_conjecture#Statement_of_the_problem   * @param n starting number of sequence; requires n &gt; 0.   * @return the hailstone sequence starting at n and ending with 1.   * For example, hailstone(3)=[3,10,5,16,8,4,2,1].   */  public static List&lt;Integer&gt; hailstoneSequence(int n) {  ...  }        또다른 Comment의 용도는 출저 명시 및 코드를 어느 부분에서 복사하고 적용 했는지를 적는 것이다.  특정 라이센스는 제한적인 코드가 있기에 이러한 행동은 코드 저작권 문제를 방지한다.  또한 이런 문서화는 코드가 구식이 되는 것을 방지한다.          예를들어 언제 스택 오버플로우 같은 곳에서 코드를 가져온지 적어놓는 것은 이 코드가 언제 작성된지 또한 확인 할수 있다.        하지만 코드를 직접 영어로 번역 하는것은 읽는 이가 JAVA를 이미 알고 있다고 있기에 좋지 않다.          ++i //increment i  ← 어차피 자바는 모두가 안다.        Comments로 코드의 의도를 설명하는 것보다는 코드로 의도를 표현하자          if (a.flags &amp;&amp;.... b.age&gt; 65) 보다는 if (a.isEligible() 등을 통해 코드에서 설명      단 라이브러리 사용시에 의도를 표현하기 모호한 경우 사용        해야 할 일이 있다면 TODO를 사용하는것도 좋은 방법Fail Fast  버그를 찾는것을 빠를 수록 좋다 → Fail Fast  빠른 문제의 관찰되어짐으로 빠르게 수정 가능 이런 방식은 Staic Checking이 Dynamic Checking보다 우월하다. 물론 잘못된 결과를 생성하는 것보단 Dynamic Chekcing이 더 빠르다.          Fail-fast에 적절한 방식 ( Static Checking &gt; Dynamic Checking &gt; Wrong answer )        위의 DayOfYear 코드는 fail fast라곤 볼 수 없다. 인자를 잘못 준다면 Wrong Answer가 나온다.  빠른 Fail Fast를 위해 static Checking과 Dynamic Checking을 사용          Static Checking 사용 → 파라미터 형식 강제          public enum Month { JANUARY, FEBRUARY, MARCH, ..., DECEMBER };  public static int dayOfYear(Month month, int dayOfMonth, int year) {    ...  }              Dynamic Checking 사용 → 런타임 시에 예외 처리          public static int dayOfYear(int month, int dayOfMonth, int year) {    if (month &lt; 1 || month &gt; 12) {      throw new IllegalArgumentException(); //예외를 처리해서 프로그래머에게 알리는 것은 에러가 뒤로 숨는걸 막아준다.    }    ...  }         Iterator VS Enumeration          Enumeration : 기존의 Iterator와 비슷하다. new 연산자로 생성이 안되며 Vector이용      Iterator : java Collections 저장 요소를 읽어오는 표준화 방법      두 기능은 비슷하지만 결정적 차이가 존재 Enumeration는 fail-safe 방식을 채택하지만 Iterator는 fail- fast 방식      Fail-Safe : 부분적인 실패가 발생할시 바로 예외를 발생시키고 중단하는것이 아닌 계속 작동하고 안정적으로 종료되게 하는것      Enumeration은 순차적 접근 중 Collection 변경이 발생시 이를 무시하고 끝까지 동작      Iterator 같은 경우 Collecion 변경시 예외 발생      Avoid Magic Numbers  대부분의 컴퓨터는 0과 1밖에 인지하지 못한다.  다른 숫자 또한 대부분 설명이 필요하다 (Comments라던가..)      차라리 명확한 이름 또는 상수로 대체하는게 더 좋아보인다.      if (password.length() &gt; 7) {      throw new InvalidArgumentException(\"password\");  }          public static final int MAX_PASSWORD_SIZE = 7; // Constatnt로 의미 부여      if (password.length() &gt; MAX_PASSWORD_SIZE) {      throw new InvalidArgumentException(\"password\");  }        dayOfYear 의 Magic Number를 피하는 방법          months 같은 경우 FEBRUARY , …,DECEMBER 등으로 → 더 읽기 쉬움      days 같은 경우는 숫자는 유지한채 array나 list를 활용해서 MONTH_LENGTH[month] 를 사용      59나 90 같은 프로그래머가 손으로 계산한 코드이다. → 이런 손으로 계산한 상수의 사용x MONTH_LENGTH[JANUARY] + MONTH_LENGTH[FEBRUARY] 를 사용        Magic Numbers는 SFB(not safe form bugs), ETU(not easy to understand), RFC(not ready for change) 등을 유발          일반적인 상수를 사용했더라도 의미 부여를 하지 않으면 위의 3개가 유발          final int FIVE = 5;  final int THIRTY_SIX = 36;  final int SEVENTY_TWO = 72;  for (int i = 0; i &lt; FIVE; ++i) {    turtle.forward(THIRTY_SIX);    turtle.turn(SEVENTY_TWO);  }              적절한 name을 통한 의미 부여          final double FULL_CIRCLE_DEGREES = 360.0;  final int NUM_SIDES = 5;  final int SIDE_LENGTH = 36;  for (int i = 0; i &lt; NUM_SIDES; ++i) {    turtle.forward(SIDE_LENGTH);    turtle.turn(FULL_CIRCLE_DEGREES / NUM_SIDES);  }      One purpose For Each Variable  dayOfYear 는 다른 값을 사용하는데 재사용된다. (파라미터로 사용, 식의 계산, 리턴값)  매개변수와 변수를 재사용하는것을 지양, 적극적으로 변수를 새롭게 사용  특히 매개변수는 함부러 수정하지 않고 사용 ( final 키워드를 사용하는것도 좋음 )Use Good Names  변수나 메소드에 좋은 이름을 좋은 것은 가독성에 효과를 준다.  JAVA의 명명 규칙은 아래와 같다.          메소드의 이름은 CamelCase      변수도 CamelCase      상수는 모두 대문자      클래스는 앞문자가 대문자      메소드는 동사 구문, 변수와 클래스는 명사구      CamelCase  낙타의 두개의 등과 비슷하다고 해서 명명된 방식  lowercamelCase          phoneNumber      createdAt        UpperCamelCase (PascalCse)          PhoneNumber      CreateAt      Use Whitespace to Help the Reader  일관된 공백의 사용  Tab은 각각의 IDE 같은 환경마다 기준이 다르다. → 다른 환경에서 사용시 들여쓰기가 망가짐.  Space를 활용한 공백 문자의 사용을 지향Smelly Examlpe(2)public static int LONG_WORD_LENGTH = 5;public static String longestWord;public static void countLongWords(List&lt;String&gt; words) {   int n = 0;   longestWord = \"\";   for (String word: words) {       if (word.length() &gt; LONG_WORD_LENGTH) ++n;       if (word.length() &gt; longestWord.length()) longestWord = word;   }   System.out.println(n);}Dont’use Global Variables  전역 변수: 프로그램 어디서나 접근이 가능한 변수 → 사용 자제          병행성 문제      긴 생명 주기 → 리소스 소비량이 늘어남      암묵적 결합 → 각 모듈간의 응집도를 떨어트림        public , static 이 자바의 전역 변수  전역변수를 사용하기 보단 return values를 사용 또는 메소드를 호출하는 객체를 사용  변수를 상수( final )로 사용하는 것은 전역변수의 위험을 일부 피할 수 있다.  위의 code에서는 n 과 LONG_WORD_LENGTH , word 가 상수화 가능          변수가 재할당 되지 않음 → 즉 상수화 가능        반복문 내에서 재 할당이 이뤄지는 longestWord 등은 상수화 불가능Method Should Return Results, not Print Them  위 코드는 결과의 일부를 콘솔로 직접 전달한다. 즉 변화에 대해 약한 RFC이다.  만약 다른 문맥이나 숫자에 대해 계산할려고 하면 코드를 재작성 해야한다.  프로그램은 가장 높은 수준만 사람과 상호작용하는게 원칙적          단 디버깅 output은 예외      Summary  코드를 붙여 넣지 말것 (Don’t Repeat Yourself)  필요한 부분에 적절한 Comments  빠른 버그 찾기 (Fall fast)  Magic Number 피하기  변수에는 하나의 목적만 수행하기  이름 잘 짓기  전역변수 사용 지양  메소드는 결과만 반환, 출력은 사용안함  적절한 공백의 사용"
  },
  
  {
    "title": "Avoiding debugging",
    "url": "/learninghub/Avoiding-Debugging/",
    "categories": "",
    "tags": "",
    "date": "2024-12-15 00:00:00 +0900",
    





    
    "snippet": "Avoiding Debugging(23.09.25)**First Defense: Make Bugs Impossible**  버그에 대한 최고의 방법은 설계상 불가능하게 하는것.      이전에 이야기한 static checking → 컴파일 시간에 버그를 제거함    불변성 : 한번 생성된 값은 절대 바뀌지 못한다. → 버그를 예방하는 또 다른 원리 ...",
    "content": "Avoiding Debugging(23.09.25)**First Defense: Make Bugs Impossible**  버그에 대한 최고의 방법은 설계상 불가능하게 하는것.      이전에 이야기한 static checking → 컴파일 시간에 버그를 제거함    불변성 : 한번 생성된 값은 절대 바뀌지 못한다. → 버그를 예방하는 또 다른 원리  String은 불변이다.버그를 방지하기 위한 디자인중 하나이다.  String을 호출 할때 해당 String이 변화 할것임을 걱정하지 않아도 된다.  자바는 또한 불별 참조를 제공한다. final 예약어를 통해서 절대 재할당 하지 못하게 막을 수 있다.  parameter에 final 을 선언하는 것은 상당히 유효하다.  변수의 유형처럼 선언은 중요한 문서입니다. 컴파일러가 static checking 할 수 있게 도와줄수 있기에.  final은 불변 객체이다. 하지만 다음과 같은 예시는?          final char[] vowels = new char[] { 'a', 'e', 'i', 'o', 'u' };      vowels = new char[] { 'x', 'y', 'z' };      vowels[0] = 'z';      final은 참조를 불별하게 만들 뿐이다.      즉 참조가 가리키는 개체를 보장하진 않는다.            또 다른 예시      char[] vowel4 = new char[] { vowel0, 'e', 'i', 'o', 'u' };  final char[] vowel5 = vowel4;      vowel4[0] = 'x';  vowel5[0] = 'z';      vowel4 = \"zeiou\"  vowel5 = \"zeiou\"              voewl4와 vowel5 는 같은 배열 객체를 가르키고 있기에 값이 같이 변경된다.      **Second Defense: Localize Bugs**  버그를 방지하지 못할 때, 프로그램의 작은 부분으로 지역화 시켜서 우리가 버그를 찾기 어렵지 않도록 설정해야한다.  메소드를 작게 하거나 모듈화 할 때 버그는 프로그램 텍스트를 학습 하는것으로 버그를 찾을 수 있다.  이건 fall fast 와도 비슷하다.      예시      /**   * @param x  requires x &gt;= 0   * @return approximation to square root of x   */  public double sqrt(double x) { ... }              만약 sqrt 를 호출 할때 x 인자를 -1을 주었다고 가정하자.      sqrt 는 모호한 값을 return 하거나, 무한 루프에 빠질 수 있다.      가장 유효한 방법은 버그를 빠르게 탐지해서 이를 지적하는것 이다.      우리는 Assertion 을 사용 할 수 있다.          /**   * @param x  requires x &gt;= 0   * @return approximation to square root of x   */  public double sqrt(double x) {      if (! (x &gt;= 0)) throw new AssertionError();      ...  }              Precondition이 충족 되지 않으면 코드는 Assertion 에러를 던진다.      이러한 효과는 호출자가 버그의 영향이 전파되는걸 방지한다.      이러한 precondition을 체크하는 것은 방어적 프로그래밍이라고 한다.      이런 방어적 프로그래밍은 버그의 영향을 안화할 수 있게 제공한다.      Assertions  일반적으로 프로시저의 다양한 방어 점검을 할때 사용하는 것은 assert 라고 한다.  assert (x &gt;= 0);  이러한 접근은 실패할 때 정확히 발생하는 방식이다.          주로 실패한 곳에서 로그 파일에 기록한다. → 유지보수자에게 이메일로알림        또한 Asserstions은 프로그램의 상태에 대한 가정을 문서화하는 이점을 갖는다.  assert (x &gt;= 0); 는 이 순간에 x는 항상 참이여야 한다는 걸 알인다.  주석과는 다른것이 이건 실제 코드에서 강제한다.  이건 Java 언어의 내장된 기능이다.  간단하게 boolean을 사용해서 AssertionError를 던진다.  주로 Assertion문은 식으로 묘사되며 대게 스트링으로 다뤄지지만, 원시 타입 및 객체에 대한 참조일 수도 있다.  Asserstion의 실패는  에러 메세지로 print 되며 이것은 프로그래머에게 실패를 야기 할수 있는 추가적인 정보를 제공하는데 사용될 수 있습니다.  이 expression은 콜론으로 분리됩니다. 예시는 아래와 같아요          assert (x &gt;= 0) : \"x is \" + x;        만약 x == -1 이라면 이렇게 나온다          x is -1        이와 함께 스택을 추적해서 프로그램 안의 코드나 sequence 호출 등 어디서 assert 에러를 찾았는지 위치를 말해줍니다.  이러한 정보는 버그를 찾기에는 충분한 정보  일반적으로 Assertion은 해제되어 있다. → 비용 문제  하지만… 일반적으로 Assertion을 통해 얻는 이득이 더 크다!  -ea 옵션을 VM 인수에 넣어 활성화 한다.      JUNIT 테스트시에 Assertion을 키고 실행하자 케이스의 예시      @Test(expected=AssertionError.class)  public void testAssertionsEnabled() {      assert false;  }        Assertions false 일 경우에 AssertionError를 thorws 한다.  자바의 assert 와 JUnuit의 assertTrue() 와 assertEquals()  는  서로 다르다.  그들은 모두 사용자의 코드에서 다른 문맥만을 비교한다.  assert 문은 구현된 코드 내에서 방어적 점검을 위해 사용된다.What to Assert      Assert 를 활용한 sqrt      public double sqrt(double x) {      assert x &gt;= 0;      double r;      ... // compute result r      assert Math.abs(r*r - x) &lt; .0001;      return r;  }              메소드 인자에 대한 요구 사항      메소드 리턴값에 대한 요구 사항 →자기 점검          switch (vowel) {    case 'a':    case 'e':    case 'i':    case 'o':    case 'u': return \"A\";    default: Assert.fail();  }              모든 사례를 테스트하기            런타임 assertions을 언제 작성해야할까?          코드를 다 쓰고 난 뒤가 아닌… 코드를 적으면서 적자 (잊어먹으니깐)      What Not to Assert  Runtime assertions은 무료가 아니다.  그것들은 코드를 어수선하게 만들 수 있기에, 남발해서는 안된다.      사소한 assertions은 생략한다.      // don't do this:  x = y + 1;  assert x == y+1;        이 assert는 버그를 찾을 수 없는 대표적인 예  모든것을 의심하지 말고 믿을건 믿는 방식이 필요  프로그램 외부의 조건( 사람의 입력, 네트워크 상태) 에는 assertion을 사용하지 않는다.  assertion은 프로그램 내부의 상태에서 보장한다. 명세의 내부에 있는지에 대해  assertion 실패할 경우 프로그램은 제대로 작동하지 않은 경우를 말한다.  그러므로 assertion의 실패 = 버그 존재 라고 볼수 있다.  외부의 장애는 Exceoption으로 처리한다.  많은 assertion의 메커니즘은 이걸 테스팅이나 디버깅동안 실행하기고, 유저에게 릴리즈 할때는 끄는게 원칙이다.  자바의 assert는 이러한 길을 자기오 있다.  이러한 접근법의 이득은 당신의 프로그램이 매우 비싼 assertion을 작성하게 도운다.  예를 들어 이진 탐색을 통해 탐색 하는 프로시저가 있을때, asserting은 전체 배열을 스캔할 수 있다. 그러나 이런 방식은 긴 시간이 걸린다.      테스팅 동안은 그런 비용을 지불할수 있다. 왜냐하면 디버깅을 쉽게 해주니깐! 그러나 릴리즈 후에는 이러한 테스트는 불가능하다.    그러나 release 할 동안 assertion을 비활성화 하는 것은 심각하게 손해이다. 그러나 assertion이 가져다 주는 이득은 강력하기에 전부 지우지는 않는다.  assertion이 비활성화될 프로그램내에서 의존이 존재 하면 안된다.  특히 side-effect가 없어야한다.          리스트 안에서 요소를 삭제하는 expression          // don't do this:  assert list.remove(x);              assertion이 비활성화 된다면, 전체 식이 실행되지 않는다. 그리고 x는 절대 식에서 제거 되지 않는다.      이렇게 바꿀것.          boolean found = list.remove(x);  assert found;  // good!      Incremental Development  지역화된 버그릐 최적의 길은 점진적으로 조금씩 부분으로 개발하는것이다.  작은 프로그램만 빌드하고, 철저한 테스트  이러한 방법은 버그를 찾을때 이전의 더미 보다 방금 짠 부분에서 버그가 있을 확률이 높다.  자세한 내용은 사전의 test에…          Unit Testing      Regression Testing      Modularity &amp; Encapsulation  좋은 소프트웨어 디자인을 위해 버그를 지역화 시킬 수 있다.  Modularity          모둘화는 시스템의 컴포넌트, 모둘 단위로 설계, 구현, 테스트 등으로 각각 별도로 기능하도록 나누는 것을 의미한다.      그리고 각 시스템을 반복적으로 재사용한다.      모듈 시스템의 반대는 모노톨릭(단일) 시스템이다.      서로가 뒤영켜 의존하는 상태      하나의 긴 main()이 있기에 이해하기 어렵고… 버그를 찾기가 힘들다.        Encapsulation          캡슐화는 모듈의 외각에 벽을 짓는것과 같다.      모듈의 내부 행동, 버그, 작은 문제가 다른 모듈에게 데미지가 가지 않도록 모듈의 외곽에 벽을 세우는것과 같다.      이런 캡슐화는 접근 컨트롤의 종류중 하나로 사용되는데 pulic 과 private 는 모듈(메소드, 변수)의 가시성과 접근성을 조종 가능하다.      public 변수와 메소드는 접근 가능한데 코드의 어떤 곳에서든지.      private 는 오직 같은 클래스 내에서만 접근 가능하다.      가능한한 private 를 유지하자… 특히 변수에 대해서 캡슐화를 제공하는 것은 부주의한 코드로부터 버그가 야기되는 것을 제한해줍니다.      캡슐화는 변수 범위에 대해서도 제공한다.      Scope은 전체 프로그램의 텍스트의 부분으로 정의됩니다. 식 또는 문에서 변수를 참조할 경우 메소드의 파라미터는 메소드의 body안으로 제한됩니다.      지역 변수의 범위는 다음 중괄호 닫힘까지입니다.      변수의 범위를 최대한 작게 유지하는 것은 프로그램에서 버그를 찾는것을 더 쉽게 해줍니다.              다음과 같은 예시가 있습니다.          for (i = 0; i &lt; 100; ++i) {      ...      doSomeThings();      ...  }                          i 는 무한번 반복된다.                  public static int i;  ...  for (i =0; i &lt; 100; ++i) {      ...      doSomeThings();      ...  }                          i 의 범위는 프로그램의 전체가 되었습니다. 어디서든지 참조 가능하고 루프는 100번 반복                  public static int i;  ...  for (i =0; i &lt; 100; ++i) {      ...      doSomeThings();      ...  }                          지역 변수를 활용해서 범위를 제한하였다.          i 는 문 내에서만 변경이 가능하다.                    최소화된 변수 범위의 활용 은 버그 지역화에 가장 강력합니다.              항상 루프의 변수를 초기화 하세요.          int i;  for (i = 0; i &lt; 100; ++i) {                          지역화도 추가하세요.                for (int i = 0; i &lt; 100; ++i) {            i 를 루프 안에서만 한정시켜야 합니다.                  자바의 변수는 중괄호 안에서 선언해서 지역 변수로 만든다.          하지만 함수를 시작할때 모든 변수를 선언하지 말아야한다 → 함수가 너무 커진다.          전역 변수는 언제나 피할것… 필요할때 마다 코드를 파라미터로써 전달하는 방식이 좋다.          전역변수는 언제나 재할당의 실수가 있음을 명시                    Summary  avoid debugging          static typing을 활용해 버그 자체를 방지하다 자동화된 dynamic checking, 불변 타입 또한 활용        keep bugs confined          fail fast를 assertion을 활용해서 도달한다.      버그가 퍼지는 것을 막는다      점진적 개발과 모듈화를 이용한다.      "
  },
  
  {
    "title": "Jekyll 이미지 관리하기",
    "url": "/learninghub/tech/jekyll-blog/jekyll%EC%9D%B4%EB%AF%B8%EC%A7%80%EA%B4%80%EB%A6%AC/",
    "categories": "Tech, jekyll-blog",
    "tags": "writing",
    "date": "2024-12-14 21:10:00 +0900",
    





    
    "snippet": "Jekyll에서는 일반적으로 글은 _posts 에 이미지는 assets 에 저장한다.하지만 이러한 방식의 경우 추후 image가 많아 질경우 두가지 디렉토리에 관리를 해줘야하는 불편함이 예상되었다..일반적인 jekyll의 이미지 리소스 관리learninghub/                 # 프로젝트의 루트 디렉토리├── _config.yml    ...",
    "content": "Jekyll에서는 일반적으로 글은 _posts 에 이미지는 assets 에 저장한다.하지만 이러한 방식의 경우 추후 image가 많아 질경우 두가지 디렉토리에 관리를 해줘야하는 불편함이 예상되었다..일반적인 jekyll의 이미지 리소스 관리learninghub/                 # 프로젝트의 루트 디렉토리├── _config.yml              # Jekyll 설정 파일├── _posts/                  # 블로그 게시글을 저장하는 디렉토리│   ├── 2024-12-14-ubuntu-upgrade.md    # 블로그 포스트│   └── ...                  # 다른 포스트들├── _site/                   # 빌드 후 생성되는 사이트 파일├── assets/                  # 정적 파일들 (이미지, CSS, JavaScript)│   ├── images/              # 이미지 파일들│   │   ├── image1.png       # 이미지 파일1│   │   ├── image2.jpg       # 이미지 파일2│   │   └── ...              # 다른 이미지들└── ...만약 카테고리와 포스트가 많아지게 된다면… 이미지가 너무 복잡해 질거라 예상했다.만약 _post 에 .md 와 image를 같이 저장한다면?learninghub/                     # 프로젝트의 루트 디렉토리├── _config.yml                   # Jekyll 설정 파일├── _posts/                       # 블로그 게시글을 저장하는 디렉토리│   ├── 2024-12-14-ubuntu-upgrade.md    # 블로그 포스트 파일│   ├── 2024-12-14-ubuntu-upgrade/      # 해당 포스트의 이미지 폴더│   │   ├── ubuntu-runner-upgrade.png   # 이미지1│   │   └── ubuntu-runner-upgrade2.jpg  # 이미지2│   │   └── ...              # 다른 이미지들└── ...게시글에 대한 마크다운과 이미지가 같이 관리 된다면 더욱 편하다고 생각했다.Jekyll에서 이미지를 관리하는 방법CDN(Content Delivery Network)# The CDN endpoint for media resources.# Notice that once it is assigned, the CDN url# will be added to all media resources (site avatar, posts' images, audio and video files) paths starting with '/'## e.g. 'https://cdn.com'cdn: \"https://unggu0704.github.io/learninghub\"  CDN은 웹 콘텐츠를 여러 데이터 센터(엣지 서버)에서 복제  사용자가 이미지를 요청할 때 가장 가까운 서버에서 전송.. .하는 개념하지만 jekyll에서 블로그 호스팅으로 쓰기에 현재로써는 image를 호스팅하는 서버 즉 내 블로그 url을 적어둔다.이렇게 되면 jekyll은 이미지를 가져올 때 내 블로그의 url을 찾아간다.baseurl# The base URL of your sitebaseurl: \"/learninghub\"  일반적인 baseurl을 사용하여 로컬 환경에서도 url이 통일 될 수 있게 설정한다.시도 방법플러그인 - jekyll-postfiles를 사용 (X)https://github.com/nhoizey/jekyll-postfiles  permalink의 설정에 맞춰 폴더를 생성해 이미지 경로를 쉽게 해주는 플러그인… 이지만  Github Page에서는 동작하지 않는다고 한다…CDN을 통한 사용법 (X)  이미지 경로를 ![tt](/_posts/image/apple-touch-icon.png)_test_ 로 설정  cdn 설정을 통해 deploy 작업을 거치면          \"https://unggu0704.github.io/learninghub\" 가 추가로 붙는다.        https://unggu0704.github.io/learninghub/_posts/image/apple-touch-icon.png)_test_test) 가 완성하지만.. 해당 방법은 확장성이 낮으며 로컬 환경에서 이미지 테스트를 해볼 수가 없다.해결permalink와 site.url을 사용결국 중요한건 이미지가 있는 경로까지 url 설정을 해야한다. (배포/로컬 환경 동일하게!)└─Tech    └─jekyll-blog        │  2024-12-15-Jekyll-로컬-환경-구축.md        │        └─2024-12-15-Ubuntu에러                2024-12-15-Ubuntu에러.md                image 1.png                image.png  본래는 _post 에 모든 .md 파일을 넣어야하지만 카테고리 관리를 위해 내부에 별도의 폴더를 디렉토리 이름으로 설정해 관리하고 있다.  불러와야할 url          {환경에따른 주소}/learninghub/categories/tech/jekyll-blog/Ubuntu에러/image경로      /learninghub  baseurl 설정으로 가져올 수 있다.기존의 permalink 설정permalink: /posts/:title/  post에 접근시 접근 url은          https://unggu0704.github.io/learninghub/posts/post 제목        해당 디렉토리 경로를 가져오기 위해 permalink를 실제 디렉토리 이름과 동일하게 작업변경된 permalink 설정permalink: /:categories/:title/  실제 _post 안에서 카테고리 이름과 동일하게 폴더를 만들어 관리하여 url을 통일  이럴 경우 실제 url과 디렉토리 구조와 동일하게 맞추어진다.baseurl과 permalink의 조합![image.png](/learninghub/tech/jekyll-blog/jekyll%EC%9D%B4%EB%AF%B8%EC%A7%80%EA%B4%80%EB%A6%AC//image.png)  baseurl + page.url (현재 접속url) 을 하여 이미지 경로를 설정  Liquid 템플릿 구문을 사용하기 위해서 render_with_liquid: true` 작업이 필수적이미지가 정상적으로 로드 되는 것을 확인할 수 있었다."
  },
  
  {
    "title": "Ubuntu runner가 업그레이드 됨",
    "url": "/learninghub/tech/jekyll-blog/Ubuntu%EC%97%90%EB%9F%AC/",
    "categories": "Tech, jekyll-blog",
    "tags": "writing",
    "date": "2024-12-14 18:10:00 +0900",
    





    
    "snippet": "Github의 Runner서버 중 (*Ubuntu-24-04-64x)* 가 기존의 Action에 맞지 않다고 에러가 발생기존의 Workflow 설정(Asis)jobs:  # Build job  build:    runs-on: ubuntu-latest  ubuntu-latest를 설정하고 있음          2024년 1월 부터 *Ubuntu-24-...",
    "content": "Github의 Runner서버 중 (*Ubuntu-24-04-64x)* 가 기존의 Action에 맞지 않다고 에러가 발생기존의 Workflow 설정(Asis)jobs:  # Build job  build:    runs-on: ubuntu-latest  ubuntu-latest를 설정하고 있음          2024년 1월 부터 *Ubuntu-24-04-64x)* 가 Ubuntu Runner 서버로 설정된다고 안내      https://github.com/actions/runner-images/issues/10636        현재 jekyll는 *Ubuntu-22-04-64x)* 에 맞춰져 있기에 해당 에러가 발생  더이상 *Ubuntu-22-04-64x)* 는 최신 버전이 아니기에… lastes가 아닌 명시적 작성Ubuntu 버전을 명확히 yml에 작성jobs:  # Build job  build:    runs-on: ubuntu-22.04정상적으로 Action Job들이 완료되었다."
  },
  
  {
    "title": "Jekyll 로컬환경 구축하기",
    "url": "/learninghub/tech/jekyll-blog/Jekyll-%EB%A1%9C%EC%BB%AC-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95/",
    "categories": "Tech, jekyll-blog",
    "tags": "writing",
    "date": "2024-12-14 18:10:00 +0900",
    





    
    "snippet": "1. Ruby 설치Chirpy의 테마를 설치하기 위해서는 Ruby 3.1.x를 설정해야한다.2-1. Window 설치https://rubyinstaller.org/downloads/에 방문하여 3.1.6(with DEVKIT)과 함께 다운받는다.2-2. MACbrew를 통해 설치한다.brew install rbenv ruby-buildrbenv glo...",
    "content": "1. Ruby 설치Chirpy의 테마를 설치하기 위해서는 Ruby 3.1.x를 설정해야한다.2-1. Window 설치https://rubyinstaller.org/downloads/에 방문하여 3.1.6(with DEVKIT)과 함께 다운받는다.2-2. MACbrew를 통해 설치한다.brew install rbenv ruby-buildrbenv global 3.1.4rbenv rehash3. Bundler 설치gem install bundler루비의 gem 명령어를 통해 bundler 설치4. 프로젝트 의존성 설치 및 로컬 서버 실행bundler install bundler exec jekyll s정상적으로 4000번 포트에 로컬서버가 기동되는 것을 볼 수 있었다."
  },
  
  {
    "title": "내맘대로 제목",
    "url": "/learninghub/education/nhn%20academy/%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B8%80%EC%9E%85%EB%8B%88%EB%8B%A4/",
    "categories": "Education, NHN Academy",
    "tags": "writing",
    "date": "2024-12-04 15:10:00 +0900",
    





    
    "snippet": "테스트글입test_상대url상대경로새로운 변경이슈이미지",
    "content": "테스트글입test_상대url상대경로새로운 변경이슈이미지"
  }
  
]

