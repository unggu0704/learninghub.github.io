---
author: "unggu"
date: 2023-11-04 05:37:22 +0800
categories: [Computer Science, Operating System]
tags: [CS, OS]
render_with_liquid: true
comments: true
---
# Page

> *다중 프로그래밍 환경에서 주 기억 장치를 동적 분할해 메모리 관리 작업이 필요함*
> 

### Address란?

- **논리적 주소**
    - CPU가 생성하는 주소 프로레스 내부에서 사용함 0부터 시작
- **물리적 주소**
    - 실제 RAM 에 올라가는 위치
- **Address Binding**
    - 어떤 프로그램이 어느 메모리의 위치에 어떤 물리적 주소에 load 될지를 결정하는 과정

실제 프로세스의 물리적 주소와 논리적 주소는 같지 않다..

그렇기에 CPU의 MMU가 이러한 주소를 서로 매핑하여 관리한다.

### Swapping

- 메모리는 크지 않다.. 그렇기에 디스크에서 꼭 필요한것만 Swap in 해야한다.
- 스케줄러에 의해 선정해 swap in/out을 결정한다.

## Allocation

### ****Contiguous Allocation****

- 연속적 할당이라고 불림
- 말 그대로 프로세스들이 연속적인 메모리 공간을 차지
- **고정 분할 기법**
    - 메모리를 일정 크기로 나누어 할당한다. → 무조건 올라갈 수 있는 프로세스의 수가 고정된다.
    - 내부 단편화
        - 정해진 사이즈에 남는 공간
- **동적 분할 기법**
    - 프로세스의 크기를 고려해서 할당
    - 외부 단편화
        - 적절한 사이즈가 없어 빈 공간으로 낭비되는 구역
    - *first-fit*
        - 프로세스의 크기가 맞으면 무조건 할당
    - *best-fit*
        - 프로세스 크기가 맞은 것 중 가장 작은 hole로 할당, 모든 메모리를 탐색해야함
        - 매우 작은 Hole들이 외부 단편화 발생
    - *Wors-fit*
        - 가장 큰 Hole에 집어 넣는다.
        - 매우 큰 Hole들이 외부 단편화 발생
- 이런 단편화를 해결 하기 위해 압축이라는 기술이 있지만… 비용이 매우 많이 드는 작업

### Non****Contiguous Allocation (Paging)****

- 단편화로 인한 비 효율성을 개선하자!
- 메모리를 **Frame**으로 나누고 프로세스를 **page**라는 조각으로 나눈다.
- 프레임의 순서와 상관없이 각 **Frame**에 **page** 를 저장한다.
    - 이때 추후에 언제든이 찾아갈 수 있게 **page table**을 통해 주소를 저장해놓는다.
- 외부 단편화를 해결!
- Swap out이 간단해진다.
- 하지만 여전히 page table로 인해 메모리 량 증가 및 접근 속도가 두배
- 내부 단편화의 문제는 여전히 존재
- 이를 해결하는 TLB
- **TLB**
    - 고속 캐시라고 불린다!
    - 최근 참조 페이지를 TLB에 저장한다. (추후 가장 먼저 찾음)

### Non****Contiguous Allocation(Segement)****

- 각 프로세스를 여러 세그먼트로 나눈다.
    - 세그먼트로 나누는 범위는 함수 하나 일수도, 프로그램 전체 일수도?
- segement number, offset 등으로 구성
- paging 비용이 사라지기에 오버헤드가 감소했지만…
- 외부 단편화는 여전히 존재