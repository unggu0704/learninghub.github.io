---
author: 김규형
date: 2024-12-15 14:10:00 +0800
categories: [NHN Academy, DataBase]
tags: [sw-engineering, SW공학]
render_with_liquid: true
---

# 병행성 제어(23. 12. 05)

## Transaction

> 트랜잭션(Transaction)은 데이터베이스의 상태를 변환시키는 `하나의 논리적 기능을 수행하기 위한 작업의 단위` 또는 `한꺼번에 모두 수행되어야 할 일련의 연산`들을 의미
> 

### DML

- SUID의 조합
    
    ```
    예시) 사용자 A가 사용자 B에게 만원을 송금한다.
    
    * 이때 DB 작업
    - 1. 사용자 A의 계좌에서 만원을 차감한다 : UPDATE 문을 사용해 사용자 A의 잔고를 변경
    - 2. 사용자 B의 계좌에 만원을 추가한다 : UPDATE 문을 사용해 사용자 B의 잔고를 변경
    
    현재 작업 단위 : 출금 UPDATE문 + 입금 UPDATE문
    → 이를 통틀어 하나의 트랜잭션이라고 한다.
    - 위 두 쿼리문 모두 성공적으로 완료되어야만 "하나의 작업(트랜잭션)"이 완료되는 것이다. `Commit`
    - 작업 단위에 속하는 쿼리 중 하나라도 실패하면 모든 쿼리문을 취소하고 이전 상태로 돌려놓아야한다. `Rollback`
    
    ```
    

### 트랜잭션의 특징

- 원자성
    
    모두 반영되거나 반영되지 않아야 한다.
    
- 일관성
    
    언제나 작업의 처리 결과는 같아야한다.
    
- 독립성
    
    둘 이상의 트랜잭션이 실행되더라도 서로에 연산에 끼어 들수 없다.
    
- 지속성
    
    한번 처리가 되었다면 영구적으로 반영
    

### 트랜잭션의 스케줄

- 어떤 트랜잭션에 있는 단위작업의 리스트
- DBMS가 보는 트랜잭션의 단위 작업들을 기술
- 각 트랜잭션에 Abort와 Commit 연산을 넣은 스케줄을 완전한 스케줄(Complete Schedule)로 부름
- 다른 단위 작업이 인터리빙 되지 않는 경우 직렬 스케줄(Serial Schedule)로 부름

### 직렬 스케줄

- 일관적인 데이터베이스 인스턴스에 대한 효과가 완결된 트랜잭션 집합 S에 대대한 완전한 직렬 스케줄의 효과와 동등함이 보장되는 스케줄
- 주어진 스케줄을 수행해서 나온 데이터베이스 인스턴스는 해당 트랜잭션들을 직렬 순서대로 수행해서 나온 데이터베이스 인스턴스와 동등

## 충돌

### 기록 - 판독 충돌

![Untitled]({{ site.baseurl }}{{ page.url }}/img10/Untitled.png)

- 미 완결 데이터를 읽는 경우
- 트랜잭션 T1이 수정한 DB 객체 A를 T1이 commit되기 전에 트랜잭션 T2가 판독 하는 경우
- **오손 판독**이라고도 불린다.

### 판독 - 기록 충돌

![Untitled]({{ site.baseurl }}{{ page.url }}/img10/Untitled%201.png)

- 반복 불가능한 읽기를 수행
- T1이 객체 A의 값을 판독 중에 T2가 A의 값을 변경하는 이유

### 기록 - 기록 충돌

- 미완결 데이터를 덮어 쓰는 경우
- T1이 어떤 객체 A를 수정하고 그걸 진행중인 R2가 덮어 쓰는 경우
- 맹목 기록이라고 부른다.

## Lock Mode

- 직렬성 보장을 위한 방법으로 데이터 객체들이 상호 베타적으로 엑세스 되도록 한다.
- 한 트랜잭션이 한 데이터 객체에 액세스 했을 때 다른 트랜잭션이 해당 객체를 수정하지 못하도록 함
- 다중 트랜잭션 환경에서 데이터베이스의 일관성과 무결성을 유지하기 위한 순차적 진행을 보장

### Shared Lock Mode

- 한 트랜잭션이 객체 A에 Shared Lock을 가지고 있으면, 다른 트랜직션에대해서도 읽기 허용
- 하지만 다른 트랜잭션이 Exclusive Lock을 허용하진 않는다,.
- 즉 독점 Lock을 불가능하게 하고 공유 공간이라고 선언

### Exclusive Lock

- 다른 트랜잭션에서 데이터를 읽을 수도, 쓸 수도 없는 잠금 모드
- 트랜잭션 T1이 객체 A에 Exclusive Lock을 가지고 있을 경우, Ti는 A에서 Shared Lock을 가질 수 없음
- 트랜잭션 T1이 객체 A에 Exclusive Lock을 가지고 있을 경우, Ti는 A에서 Exclusive Lock을 가질 수 없음
- 즉 Java의 Synchorized와 비슷하다.

### **Strict 2 Phase Lock**

- 가장 널리 사용되는 잠금 규약으로, 두 가지 규칙을 사용
    1. 트랜잭션 T가 어떤 객체를 판독(수정)하려면, 그 객체에 대해 공유(배타적) 잠금을 요청
    2. 트랜잭션이 종료될 때 가지고 있던 모든 잠금을 풀어줌
- 잠금 규약은 안전한 인터리빙만을 어용함

## Concurrency Control(DB)

- DBMS는 잠금 관리자(Lock Manager)를 제공
    - 잠금 관리자는 잠금 테이블(Lock Table)과 트랜잭션 테이블(Transaction Table)을 유지
    - 잠금 테이블 엔트리(Lock Table Entry)로 객체에 대한 잠금 정보 관리

### Deadlock

![Untitled]({{ site.baseurl }}{{ page.url }}/img10/Untitled%202.png)

- 두 트랜잭션이 잠금 해제를 기다리는 관계에 사이클이 생기는 경우
- 논리적으로 교착상태를 막을 수 있는 방법은 없음
    - 예방으로 프로세스의 시작을 막음
    - 탐지로 교착상태를 검출하여 프로세스를 Kill

### 교착 상태 예방

- 트랜잭션마다 우선순위를 부여해주고 우선 순위가 낮은 트랜잭션은 우선순위가 높은 트랜잭션을 기다릴 수 없도록 하여 예방
- 우선 순위 지정에는 타임 스탬프를 사용
    - 가장 오래된 트랜잭션이 가장 높은 우선순위를 가짐

### 교착 상태 탐지

- Deadlock은 매우 드물게 발생되며, 몇 안되는 트랜잭션만 관련됨
- 발생 후 탐지해서 해결하는 것이 좋을 수 있음
    - DBMS는 주기적으로 Deadlock인지를 점검