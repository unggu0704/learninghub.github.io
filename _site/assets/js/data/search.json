[
  
  {
    "title": "Vison control",
    "url": "/learninghub/study/mit6.005-software%20construction/Vison-Control/",
    "categories": "Study, MIT6.005-Software Construction",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Objectives  version control이 무엇이고 왜 사용하는지 파악하기  어떻게 git이 version history를 그래프로 저장하는지 이해  version history를 사용하고 읽고 만드는것을 연습Introduction  Version control 시스템은 소프트웨어 공학에선 필수적인 도구입니다. 대부분의 오픈, 취미 등등에서 ...",
    "content": "Objectives  version control이 무엇이고 왜 사용하는지 파악하기  어떻게 git이 version history를 그래프로 저장하는지 이해  version history를 사용하고 읽고 만드는것을 연습Introduction  Version control 시스템은 소프트웨어 공학에선 필수적인 도구입니다. 대부분의 오픈, 취미 등등에서 사용.  version control 없이 팀원의 모든 코드를 조절하는 것은 매우 어렵다.version control 없는 버전 제어  드롭박스  undo/redo  파일에 번호를 붙여 저장Inventing version control(버전 컨트롤의 발명)엘리스 혼자서 개발할때  version control 없이 혼자 개발할경우 백업파일을 만든다고 가정  Hello.java1, Hello.java2….  그리고 이걸 Cloud에 올린다.  만약 노트북에서 작업한 HelloL.java 와 데스크탑에서 작업한 HelloD.java  만약 실수로 파일을 덮어 쓴다면…? (ex: HelloL.java → HelloD.java)  데스크탑에서 작업한 소중한 파일을 잃어버렸다…앨리스와 밥이 개발할때  서로 다른 컴퓨터에서 작업하기에 클라우드 서버에 엄격한 규율을 적용  또한 효율적인 관리를 위해 로그 작성Muliple branches  새로운 기능을 추가하기 위해 브랜치에서 작업  기능이 완전하게 작업되기 전까지 pull 되는건 누구도 원하지 않음  혼자 개발하더라도 이러한것은 동일함  이러한 기능은 높은 유연성을 제공Distributed vs centralized  중앙집중식          마스터 서버 하나에서 관리      모든 사용자는 마스터서버와 작업을 공유        분산식          개인적인 사용자가 개인 저장소를 가지고 있음      개인 저장소에서 변경된다면 팀 저장소는 그에 대한 변경 내용을 결정해야함      Version control 용어  Repository : 로컬 또는 원격 저장소  Working copy : 작업 또는 프로젝트의 편집 가능한 복사본  File : 단일 파일  Version : 프로젝트의 한 시점을 기록  diff : 두 버전간의 차이  Head : 현재 버전version control system의 특징  Realibable : 안전하게 백업  Multiple files : 프로젝트의 여러 버전을 추적  Meaningful Version : 어떤 변화가 있고 어디서 만들어졌는지  Revert : 이전 버전으로 복원  Compare version  Review history : 전체 프로젝트 또는 개인 파일에 대한 컴토  Not just for code : 산문, 이미지….  Merge : 이전 버전과 다른 버전을 결합  Track respnsibillity : 누가 변화를 가지고, 누가 코드 라인을 만졌는지  Work in parallel : 한명의 프로그래머가 다른 사람에 상관없이 혼자 버전관리 가능하다.  Work-In-Progress : 다수의 프로그래머가 서로 완료되지 않은 작업을 공유 가능Git  Command Line에서 작동  자세한 내용은 PS0에서…git object graph  git에서 수행하는 모든 작업은 우리의 프로젝트 안 파일에 그래프 형식으로 저장된다.  git clone은 이러한 그래프를 로컬로 가져오는것  일반적으로 directed acyclic graph(DAG) 형태  커밋은 일반적으로 16진수로 표시되는 고유 ID로 식별  각 커밋에는 부모 커밋에 대한 포인터가 있다.  부모가 둘인 커밋도 있을수 있음git commit  작업 디렉토리 내용을 기반으로 커밋을 생성 그래서 편집을 하면 스냅샷에 변경 사항 포함  git은 마지막 준비 영역이 staging area에 저장  staging area는 프로토 커밋과 같다. git add 를 사용하여 새로운 스냅샷을 만드는것은 다음과 같다.      작업 디렉토리와 스테이징 영역 Head commit 모두 같다.    파일을 변경    git add 를 사용해서 Stage 변경    git commit 을 사용해서 새 커밋 만들기  Sequences, trees, and graphs  단일 컴퓨터에서 혼자 작업할 경우 DAG는 일반적인 시퀸스로 보임 (commit1 → commit2 → commit3…)  하지만 다수의 프로그래머가 동시에 변화를 만든다면? ( 여러 커밋이 하나의 부모 커밋을 가리킬때)  이러한 과정으로 git push, git pull이 있음merging  A라는 파일을 각자 다른 두 사람이 B 와 C파일을 생성  B가 업데이트된 A를 push  C가 업데이트된 A를 push할 경우 push가 거절됨  C는 B로 인해 업데이트 된 A를 pull 하고 자신의 업데이트된 A를 병합하여 새로운 A+를 생성  C는 A+를 push하고 B또한 A+를 pull 한다.  이러한 방식은 서로 다른 파일을 수정했기에 가능하다…"
  },
  
  {
    "title": "Testing",
    "url": "/learninghub/study/mit6.005-software%20construction/Testing/",
    "categories": "Study, MIT6.005-Software Construction",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "이번 장의 목표  Test-first programmin의 절차를 알고, 테스팅 값을 이해하는것  메소드의 input과 output에 적절한 테스트를 디자인 하고 좋은 TC를 고르는것  테스트가 코드에 어느 범위 까지 적용 되는것을 이해하는것  블랙박스와 화이트박스 테스트를 이해하고 유닛과 통합 테스트 그리고 자동 회귀 테스트를 이해한다.검증  일반적...",
    "content": "이번 장의 목표  Test-first programmin의 절차를 알고, 테스팅 값을 이해하는것  메소드의 input과 output에 적절한 테스트를 디자인 하고 좋은 TC를 고르는것  테스트가 코드에 어느 범위 까지 적용 되는것을 이해하는것  블랙박스와 화이트박스 테스트를 이해하고 유닛과 통합 테스트 그리고 자동 회귀 테스트를 이해한다.검증  일반적으로 테스팅의 대부분 절차는 검증이라 불린다.  검증의 목표는 야기 될 수 있는 프로그램의 잠재적 문제를 찾아 정확성을 높이는 것.  검증은 아래를 포함한다.          Foraml reasoning(형식추론) : 공식 증명으로 프로그램을 검증한다. 손으로 하는것보다 tool을 주로 사용, 주로 운영체제 스케줄러, 바이트코드 인터프리터등 작은 부분에 사용된다.      Code review : 누군가가 코드를 읽고 이것을 추론한다. 버그를 방지하는데 좋은 방법이다      Testing : TC를 input에 결과를 확인한다.          테스팅 하는것이 어려운 이유  Exhaustive Testing(철저한 테스팅) : 전체를 테스트하기에는 프로그램이 너무 거대함 (ex: 32비트의 부동 소수점 계산    a*b 는 2^64개의 TC가 존재  Haphazard Testing(우연적 테스팅) : 단지 실행하는지 확인만 하는것은 버기를 잡기엔 좋지않다. 왜냐하면 임의의 TC가 버그를 잡지 못할 수도 있다.  Random or statistical Testing(무작위 또는 정적 테스팅) : SW에서는 잘 어울리지 않음, 일반적인 다른 공학에서는 주로 사용되지만… SW는 대부분 불연속적, 특정한 공간에 이산적으로 발생 (ex: 스택 오버플로우, 정수 값 초과…) 그렇기에 TC를 선별할때 잘 선별 해야한다.Test-first Programming  테스트는 언제나 빠르게 자주 그렇지 않으면 검증되지 않은 코드가 쌓여 티버거 시간과 고통이 늘어난다.  test-first-programmin은 코드를 쓰기도 전에 테스트를 하는것이다.          함수의 기능을 작성한다.      구체적으로 어떻게 테스트 할지를 작성한다.      실제 코드를 작성한다        specification(명세) 에 함수의 input(paprameter와 같은…)과  output을 묘사, 그리고 input에 따른 return값이 어떻게 관련 있는지 또한 묘사  specification 또한 버그가 없도록 테스트가 필요Choosing Test Cases by Partitioning  좋은 테스트 케이스를 만드는것은 프로그램 디자인에 중요한 요소  이것을 위해 subdomains 활용          input의 집합      각 subdomain은 그 구역의 모든 범위에 적용됨      그렇기에 각각의 subdomain에서 하나 골라서 테스트        이러한 생각 뒤에는 한 구역의 input space에는 비슷한 결과를 낼 것이라고 생각  이러한 접근 법은 한정된 테스트 자원이 있을때 사용Example : **BigInteger.multiply()**  모든 정수를 나타난다. int 와 long 은 제한적인 정수  multiply() 는 곱셈 기능      이렇게 사용한다.      BigInteger a = ...;  BigInteger b = ...;  BigInteger ab = a.multiply(b);        이 코드는 다음과 같은 input 쌍이 존재 할 수 있다.          a와 b가 양수      a와 b가 음수      a는 양수, b는 음수      a는 음수, b는 양수      a나 b가 1,0,-1 일 경우        계산 방식 또한 다음과 같다.          크기에 대해 값이 작을 경우 효율을 위해 int 와 long 으로 계산      Long.MAX_VALUE 등 2^63 과 같은 극적으로 큰 값일때        이러한 점을 고려했을때 우리는 다음과 같은 test suite를 만들 수 있다.          (-3, 25) → a와 b가 작고 음수와 양수      (0, 30) → a는 0, b는 작은 양수      (2^100, 1) → a는 큰 양수 b는 1      등등…      **Include Boundaries in the Partition**  버그는 언제나 boundaries와 subdomains에서 일어난다          ‘0’은 양수와 음수의 경계      int 와 double 같은 경우 각 최대 최소      비어있는 String, list등의 Collection Type      요소의 첫번째 또는 마지막        왜 버그는 경계에서 일어날까?→ 프로그래머들은 off-by-one mistakes (한가지 실수)를 저지른다.          &lt;= 를 &lt; 로 쓰는것과 같은…        다른 문제로는 몇몇 경계들은 특별한 case로 다뤄야하는 경우도 있을 수 있다.  아니면 경계에서는 코드가 지속적으로 진행되지 않을 수도 있다.          int 같은 경우 최대 값을 넘어가면 마이너스의 값을 가진다.        max : int x int -&gt; int          a와 b의 relationship                  a &lt; b          a = b          a &gt; b                    a의 값은                  a = 0          a &lt; 0          a &gt; 0          a = int의 최대 값          a = int의 최소 값                    b의 값 또한 위와 같음        이러한 정보를 토대로 아래와 같은 테스트 값을 산출          (1, 2) → a &lt; b, a &gt; 0, b &gt;0      (0, 0) → a = b, a= 0, b= 0      (Integer.MAX_VALUE, Integer.MIN_VALUE) → a &gt; b, a = maxInt, b = minInt      Two Extemes for Covering the Partition  input space 의 분리가 나누어진 후에 얼마나 많은 test를 준비 할 것인가  Full Cartesian Product          각각의 분리에 대해 3 x 5 x 5 = 75 &gt; 는 7 x 7 = 49보다 크다      물론 a &lt; b , a= 0, b= 0 같은 경우는 이렇게 해당 될수 없다.        Cover each Part          각각의 텍스트는 최소 하나 이상의 범위에 적용된다. 하지만 이것을 모두 조합 할 필요는 없고 위의 max 같은 경우는 최소 5개로 적용이가능하다.      Blackbox and Whitebox Test  위에서 언급한 specification을 회상  Blackbox testing :  함수의 기능을 생각하지 않고 specification(명세)만을 보고 TC를 정함  Whitebox testing : 함수가 실제로 어떻게 돌아가는지를 생각하면서 TC를 만듬 위의 max 와 multiply 가 대표적          whitebox testing을 할때에는 예외에 대해 명시 (exception에 대한 throws)의 경우 굳이 NullPointEception에 대한 테스트를 할 필요가 없다. ..?      Exercises/** * Sort a list of integers in nondecreasing order.  Modifies the list so that  * values.get(i) &lt;= values.get(i+1) for all 0&lt;=i&lt;values.length()-1 */public static void sort(List&lt;Integer&gt; values) {    // choose a good algorithm for the size of the list    if (values.length() &lt; 10) {        radixSort(values);    } else if (values.length() &lt; 1000*1000*1000) {        quickSort(values);    } else {        mergeSort(values);    }}  이 코드에 대해서 화이트 박스 경계값 테스트는 values = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] 이다.  values = [] 는 white box Test용 값은 아니다.Coverage  하나의 TC가 얼마나 코드의 범위를 체크 할수 있는가 (화이트 박스 테스트)의 지표  Statement coverage : TC가 Statement 문을 전부 테스트 하는가?  Branch Coverage : 모든 if 와 while을 테스트 하는가?  Path Coverage : 모든 조합 가능한 조건문들을 테스트 하는가? = 모든 경로를 테스트 하는가?  일반적으로 patch &gt; branch &gt; statment 순으로 강력하다  하지만 현실적으로 Path나 Branch Coverage를 이뤄낼순 없다  현실적으론 하나의 테스트 케이스가 모든 Statement에 도달 할수 있게 조절 → 도구를 활용Unit Testing and Stubs  테스트를 할때는 가능하다면 모듈단위로 고립적 테스트 하는것이 좋다.  또한 고립된 모듈은 디버깅 하기도 수월 → Unit Test의 필요성  이와 반대로 모듈을 조합하거나 또는 전체 프로그램을 테스트 하는것을 intergation test라고 불린다.          이런 intergation test는 버그를 찾는것에 소모되는 시간이 크지만 여전히 전체 모듈 사이의 연결을 테스트하는데 여전히 중요하다.            하지만 철저한 Unit test는 intergation Test에 역할을 어느정도 대체해 버그를 찾는데 들이는 비용을 감소 시킬수가 있다.      /** @return the contents of the web page downloaded from url    */  public static String getWebPage(URL url) {...}      /** @return the words in string s, in the order they appear,               where a word is a contiguous sequence of               non-whitespace and non-punctuation characters    */  public static List&lt;String&gt; extractWords(String s) { ... }          /** @return an index mapping a word to the set of URLs               containing that word, for all webpages in the input set    */  public static Map&lt;String, Set&lt;URL&gt;&gt; makeIndex(Set&lt;URL&gt; urls) {       ...      for (URL url : urls) {          String page = getWebPage(url);          List&lt;String&gt; words = extractWords(page);          ...      }      ...  }        우리는 위 코드에서 3개의 단위 테스트를 할 수 있다.          getWebPage() : 다양한 url 을 가져온다.      extractWords() : 다양한 String을 테스트한다.      makeIndex() : 다양한 url의 집합을 테스트 한다.        extrackWords() 을 단위 테스트 한다면?          getWebPage() 에 의존해서는 안된다.      직접적으로 String을 받아오는 방식으로 해야한다. 왜? 다른 모듈에 버그가 있을수도 있기 때문에.        makeIndex() 를 단위 테스트 한다면?          쉽게 독립되긴 힘들어 보인다.      연관된 다른 메소드들의 단위 테스트를 실행해 신뢰감을 높인다면 해당 메소드도 테스트가 가능      이런식으로 테스트 완료된 구조를 넓혀간다.      만약 어떤식으로도 테스트 하고 싶다면 stub을 사용할 수 있을것이다.      Automated Testing and Regression Testing  Automated testing 은 자동적으로 실행과 테스트를 체크한다.  test driver 는input에 대한 결과를 체크 하기 위해 자동적으로 프로그램과 상호작용하지 않습니다. 대신에 자동으로 테스트 케이스가 맞는지는 체크합니다.  이러한 테스트 도구로는 JUnit이 주로도움을 줍니다.  현재로썬 테스트 도구는 연구 분야 역시 가장 좋은건 스스로 해보는것.  수정된 코드를 재 실행하는 것은 중요하다. 그리고 기능을 추가하거나 버그를 수정할때 마다 새로운 테스트를 자동으로 실행하는 것을 regression testing이라고 한다.  버그가 발생하고 그 코드를 수정한다면 다음 테스트 코드에는 그 버그를 유발 시켰던 TC를 추가하고 다시 테스트한다 이를 또한 regression testing이라고도 불린다.  이러한 아이디어는 또한 test-first-debugging 이라고도 불리는데 버그가 증가할때 즉시 TC에 추가한다. 버그를 수정한다면 모든 테스트 케이스들은 여전히 통과 될 것이다.  Automated Testing and Regression Testing 은 모두 서로 조합되서 사용된다.  Regression Testing 은 테스트가 자동으로 자주 실행 될때 실용적이며 이미 프로젝트가 완료 되어다면 회귀 테스트로 전체 자동 테스트를 하는것이 합리적이다.Summary  Test-first programming은 코드를 쓰기전에 테스트 코드를 적는것  분할과 경계는 테스트 케이스를 체계적으로 생성할 수 있다.  화이트 박스 테스트와 Statement Coverage는 test suit(test case를 묶은것)를 채우도록 해준다  각 모듈의 단위 테스트는 가능한한 고립시켜서 진행한다.  자동화된 테스팅은 버그를 방지한다."
  },
  
  {
    "title": "Static checking",
    "url": "/learninghub/study/mit6.005-software%20construction/Static-Checking/",
    "categories": "Study, MIT6.005-Software Construction",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "**Hailstone Sequence**      n이 짝수일 때 n / 2, n이 홀수 일때 3n + 1      2, 1           3, 10, 5, 16, 8, 4, 2, 1       4, 2, 1  2n, 2n-1 , ... , 4, 2, 1  5, 16, 8, 4, 2, 1  7, 22, 11, 34, 17, 52, 6, 13, 40...",
    "content": "**Hailstone Sequence**      n이 짝수일 때 n / 2, n이 홀수 일때 3n + 1      2, 1           3, 10, 5, 16, 8, 4, 2, 1       4, 2, 1  2n, 2n-1 , ... , 4, 2, 1  5, 16, 8, 4, 2, 1  7, 22, 11, 34, 17, 52, 6, 13, 40, ...? (where does this stop?)            이런 코드를 하일스톤(우박) 코드… 왜? → 왔다갔다 하니깐….  Type  타입 → 값의 집합  Primitive Types (원시 타입) (int, long, boolean…)  Object Type (객체 타입) (String, BingInteger…)  Operations → 입력을 받고 출력을 생성하는 함수Static Typing &amp; Checking      Compile Time Error VS Runtime Error    ### 컴파일 타임 에러          기계어로 컴파일 하는 과정의 에러      구문 오류 또느 누락 파일 참조, 컴파일 되지 못하게 막음        ### 런타임 에러          프로그램이 실행하는 동안 발생 버그 (ex: 프로그램 충돌 등…)        JAVA는 정적 타입 언어 → 컴파일 타임에 변수를 검사함 (정적 검사) 이런 효과덕분에 버그에 더 안전함  Python은 동적 타입 언어 런타임 동안 에러를 검사Checking의 종류  Static checking : 프로그램 Run 이전에 버그를 자동으로 찾는것          구문 에러 : 잘못된 단어나, 구두점을 검사      작업 디렉토리 이름      잘못된 argument(인자)      잘못된 argument Type      잘못된 return Type      이러한 방식은 변수가 어떤 타입을 가질지는 보장하지만 런타임 시간까지 그것을 보증하지는 않는다.        Dynamic checking : Run 상태가 되고 버그를 자동으로 찾는것          잘못된 인자 값 (ex: x/y 에서 오직 y가 0일때 오류 이건 동적 에러)      반환 값을 특정할수 없는 경우..?      인덱스 범위 초과      null 객체를 참조할경우            No Chechking : 언어가 error를 찾이 않고 스스로 버그를 고치는 행위    Static checking &gt; Dynamice Checking &gt; No Checking 순으로 좋음.  Primitive Types  자바의 Integer(다른 원시 타입)은 실제 숫자가 아니다.  5 / 2의 경우 분수가 아닌 2를 리턴 → 동적 에러에서 탐지 못함  Overflow같은 경우 int나 long의 경우 값 초과시… 이상한 값 도출  float 과 doubles는 real number와는 조금 다르다. dynamice error(0으로 나누거나 음수에 제곱근)을 시도할경우 에러가 아닌 이상한 결과(POSITIVE_INFINITY)를 내보낸다.Arrays and Collectionsfixed Array  고정된 길이 만약 int[100] 이라면 그 이상을 넘어서면 → 버그List  Class  ArrayList, LiknedList…  객체를 저장한 Integer 같은 (int 와는 자동 형변환)Methods  public 프로그램 어디에서나 사용가능…  static 객체를 통해 불러지지 않음 ex) .add() / .lenght()      주석은 매우 중요하다 언제나 메소드의 대해서 추상적인 부분을 정의    ex) int n 에서 n이 양수임을 알림  **Mutating Values vs. Reassigning Variables**Mutable  일반적인 Array, List의 경우 값 안의 참조를 변경  StringBuiler도 마찬가지Immutable  일반적인 변수의 재할당  String 이 대표적Final  자바가 제공하는 Immutable 예약어  재 할당 할려고 시도시 Compile error가 발생해 Static checking이 가능해짐**Documenting Assumptions**  일반적으로 int 로 선언된 변수는 컴파일러가 검사한다.  final로 선언 한다면 절대 재 할당되지 않은 것을 컴파일러가 인지한다  하지만 음수 값이 들어가면 안된다는 것등은 컴파일러가 모른다  Assumption을 적는 것은 자기 또는 다른 사람이 이러한 형식을 잊이 않게 하기 위해  프로그램에 대해 두가지 목표를 명심해 쓸것          컴파일러가 구문, 타입 에러를 잡을수 있게 할것      사람이 프로그램을 이해하기 쉽게 하여 추후 수정하기 쉽게 할것      Hacking VS Engineering  BAD          테스트 하기전에 너무 많은 코드를 적기      모든 것을 기억할수 있다고 가정하고 주석을 적지 않은것      버그가 없다고 가정하거나 쉽게 수정할 수 있다고 생각하기        GOOD          조금 작성하고 테스트, 테스트 퍼스트 프로그래밍      코드가 의존하는 문서를 만들기      Static checking의 도움 받기      Summary      Static checking을 사용 해서 아래와 같은 목표를 도달.    버그로부터 안전한 코드          Static Checking이 type에 대해서 runtime 이전에 도움을 줄 수있다.        이해하기 쉬운 코드          코드에 타입이 명시적으로 적어져있기에 이해 하기 쉬움        변화에 준비됨          코드의 변경시 영향 받는 모든 곳에 에러를 보여주면서 상기시킴      "
  },
  
  {
    "title": "Specifications",
    "url": "/learninghub/study/mit6.005-software%20construction/Specifications/",
    "categories": "Study, MIT6.005-Software Construction",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Specifications란 무엇인가?  심각한 버그는 인터페이스의 동작에 대한 오해에서 나타난다.  정확한 명세를 활용해 비난을 사람이 아닌 코드로 옮겨야한다.      BigIntefer에 대한 명세와 코드      /*   * 명세   */      public BigInteger add(BigInteger val)      Returns a B...",
    "content": "Specifications란 무엇인가?  심각한 버그는 인터페이스의 동작에 대한 오해에서 나타난다.  정확한 명세를 활용해 비난을 사람이 아닌 코드로 옮겨야한다.      BigIntefer에 대한 명세와 코드      /*   * 명세   */      public BigInteger add(BigInteger val)      Returns a BigInteger whose value is (this + val).      Parameters:   val - value to be added to this BigInteger.      Returns:   this + val          /*   * 실제 코드    */  if (val.signum == 0)      return this;  if (signum == 0)      return val;  if (val.signum == signum)      return new BigInteger(add(mag, val.mag), signum);      int cmp = compareMagnitude(val);  if (cmp == 0)      return ZERO;  int[] resultMag = (cmp &gt; 0 ? subtract(mag, val.mag)                     : subtract(val.mag, mag));  resultMag = trustedStripLeadingZeroInts(resultMag);      return new BigInteger(resultMag, cmp == signum ? 1 : -1);        Specifications로써의 BigInteger.add 는 일반적인 사용자가 이해하기 쉽게 되어 있다.  Source Code로 써의 BingInteger.add 는 코너케이스에 대한 질문에 적절한 읽을 수있는 문서를 제공한다.  Specifications를 사용함으로써 구현에 있어서 변화할 때 클라이언트에게 알리지 않고도 변경이 가능하다. → ?  코드를 더 빠르게 만들게 도와주기도 하는데 Specifications는 더 효율적인 구현을 제공하기도 한다.  precondition은 특정 범위에 대해 필요 없는 체크를 하지 않게 해준다.  Specifications = contract acts 라고도 불린다. 고객과 설계자와의 방화벽으로써 클라이언트가 작업과 unit의 자세한 부분까지 알게 할 필요가 없다. Specifications가 있다만 고객에게 소스코드를 읽게할 필요가 없다는 뜻  구현하는 사람은 장치의 세부 사항으로부터 보호한다.  또한 고객으로부터 어떻게 사용할지 물어보는 대신에 명세를 확인한다.  이러한 벽은 결과적으로 unit의 코드와 고객의 코드를 독립적으로 변경할 수 있게 해준다.Behavioral equivalencestatic int findFirst(int[] arr, int val) {    for (int i = 0; i &lt; arr.length; i++) {        if (arr[i] == val) return i;    }    return arr.length;}static int findLast(int[] arr, int val) {    for (int i = arr.length -1 ; i &gt;= 0; i--) {        if (arr[i] == val) return i;    }    return -1;}  위 두 코드는 다르다.  하지만 behavior equivalence에 대한 우리의 질문은 하나의 구현을 다른걸로 대체가 가능한지 에대한 문제이다.  단순히 코드가 다른걸 제외하고도 return값에 있어 또한 차이가 있다.  투 메소느는 같은 행동을 하지만 고객이 절대 다른 case에 있어서 의존하지 않게 할 수 있다.  결국 같은 val과 같은 요소를 출력하기에 서로가 서로로 전환 가능  동등성은 고객의 눈으로 봐야한다.  한 구현에 있어 대체제를 하기 위해 그리고 그것을 수용하기 위해 우리는 Soecification(명세)에 의존한다.Specification structure  메소드 명세는 다음과 같은 항으로 구성된다.          Precondition : keyword가 무엇을 요구하는지 나타내는것, 고객의 의무 어떤 값을 넣을지      Postcondition: keyword가 어떤 영향에 대해 나타내는것, 구현자의 의무 적절한 값을 반환        precondition이 고정되어 있다면 postcondition도 고정되어 있어야한다.  반대로 precondition이 고정되어 있지 않다면 구현은 postcondition에 구속되지 않는다. 예외를 던지거다 임의의 결과를 반환하는 등의 자유가 있다.  Precondition : 입력 조건, 함수가 Call 되기 전에 무엇이 참이 되어짐을 나타냄  Postcondition : 출력 조건, 함수가 실행되고 무엇이 참이 되어져야하는지를 나타냄Specifications in Java  일부 언어는 전제조건과 사후 조건을 언어의 기본적인 부분으로 포함  자바의 Static type은 메소드의 전제조건과 사후조건의 일부, 나머지는 주석으로 기술      이런 주석을 잘 활용하기 위해 javadoc의 규칙을 준수      /**   * Find a value in an array.   * @param arr array to search, requires that val occurs exactly once   *            in arr   * @param val value to search for   * @return index i such that arr[i] = val   */  static int find(int[] arr, int val)      Null reference  자바의 객체나 배열은 null 값을 가질수 있다. 즉 참조가 언제나 객체를 가지지 않는다. 자바에서는 이러한 null을 주의해야한다.  원시형 타입은 null이 가능하지 않다.  비 원시형에는 뭐든지 null이 가능  컴파일러는 null을 찾지 못한다. 그렇기에 런타임 시간에 에러가 발생  null과 빈 문자열은 같지 않다.  null 값은 불안전하기에 문법적 디자인으로 추천하지 않는다.  null 값은 암묵적으로 허용되지 않습니다 return values과 파라미터로써 null을 가지는것은  그렇기에 모든 전제조건은 null이 아닌것을 암묵적으로 가진다.  이는 출력조건 또한 non-null임을 가진다.  null을 파라미터로 하고싶은 경우 명시적으로 명시해야하는데… null은 피하는게 좋다.What a specification may talk about  메소드의 명세는 파라미터나 return값에 대한 이야기는 가능하지만 지역변수와 private fields 같은 명세에 보여질 필요가 없을것  독자가 spec에서 자바 코드를 읽을수 없는등 이용할수가 없을수도 있습니다  자바독이 읽을수 있는 HTML로 코드에서 추출하기 때문에 메소드의 소스코드는 굳이 이용하지 않아도 된다.Testing and specifications  명세에만 염두를 두고 진행하는 테스트를 블랙박스 테스트라고 한다.  화이트박스 테스트는 실제 기능을 보고 구현을 하지만, 화이트 박스도 명세를 따른다.  물론 구현보다 더 강력한 경우를 고려할수도 있다.  해당 명세를 보면 index는 배열에서 가장 낮은 val과 같은 값만 추출되어진다. → weak postconditionstatic int find(int[] arr, int val)  requires: val occurs in arr  effects:  returns index i such that arr[i] = val  이런 테스트코드는…?int[] array = new int[] { 7, 7, 7 };~~assertEquals(0, find(array, 7));~~  // bad test case: violates the specassertEquals(7, array[find(array, 7)]);  // correct  find 메소드를 val을 찾을수 없을때 특정값을 return 하는게 아닌 예외를 던지게하는다면  precondition을 위반하기 때문에 find는 호출되지 못하고 동작을 테스트하지 못한다.  왜 화이트박스 테스트가 의미가 있는지는 명세를 넘어서지 못한는 경우에 새로운 테스트를 찾을수가 없다. 그렇기에 구현 독릭접인 방식으로 여전히 테스트는 실행되어야한다.Testing units      Testing 단원에서 학습한 코드 예시      /** @return the contents of the web page downloaded from url */  public static String getWebPage(URL url) { ... }      /** @return the words in string s, in the order they appear,   *          where a word is a contiguous sequence of   *          non-whitespace and non-punctuation characters */  public static List&lt;String&gt; extractWords(String s) { ... }      /** @return an index mapping a word to the set of URLs   *          containing that word, for all webpages in the input set */  public static Map&lt;String, Set&lt;URL&gt;&gt; makeIndex(Set&lt;URL&gt; urls) {       ...      calls getWebPage and extractWords      ...  }        unit testing에 대해 이야기 할 때, 우리의 프로그램에 고립적으로 각각의 모듈에 대해 테스트를 작성하였다.  좋은 unit test는 작은 명세에 초첨을 맞춘다.Specifications for mutating methods  이전의 가변성과 불변성에 대해 이야기했다.  우리의 find 명세는 고려하지 않아다 어떻게 영향력을 미치는지 데이터를 변경할때 사후조건에서      가변 객체에 대한 명세는 다음과 같다.      static boolean addAll(List&lt;T&gt; list1, List&lt;T&gt; list2)    requires: list1 != list2    effects:  modifies list1 by adding the elements of list2 to the end of                it, and returns true if list1 changed as a result of call        자바 List interface를 단순화 한 예시 위  사후조건의 경우 두가지 제약이 있다.          list1 이 어떻게 수정되지는지      return값이 어떻게 결정되어지는지        전제조건을 본다면, 이것은 우리에게 말해줍니다.  리스트에 요소를 자체에 추가할려고 한다면 동작이 정의되지 않음을 알 수 있다. 너는 쉽게 상상할수 있습니다 왜 메소드의 구현자가 이 제약을 원하는지 .  이러한 방식은 구현이 쉬워지고 메소드의 유용한 것을 배제할 가능성이 낮아진다.  암묵적인 전제 조건인 not null을 적용"
  },
  
  {
    "title": "Recursive data types",
    "url": "/learninghub/study/mit6.005-software%20construction/Recursive-Data-Types/",
    "categories": "Study, MIT6.005-Software Construction",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Recursive functions재귀적 함수가 자기 자신의 관점에 따라 정의되는 것과 같이 재귀적 자료형 또한 자기 관점에서 정의된다.Immutable lists  immutable list 인 ImList&lt;E&gt; 이것이 4가지의 작동을 한다고 생각          empty: void → ImList      cons: E × ImList...",
    "content": "Recursive functions재귀적 함수가 자기 자신의 관점에 따라 정의되는 것과 같이 재귀적 자료형 또한 자기 관점에서 정의된다.Immutable lists  immutable list 인 ImList&lt;E&gt; 이것이 4가지의 작동을 한다고 생각          empty: void → ImList      cons: E × ImList → ImList      first: ImList → E      rest: ImList → ImList        위 규칙들은 List 나 Scheme 의 기본적인 요소로 현재에서도 함수적 프로그래밍에 있어 널리 사용됨      이 데이터 유형을 구현하기 위해 Java 클래스를 비트 연사자를 사용한다면 아래와 같은 의미를 가진다.          empty() = [ ]      cons(0, empty() ) = [ 0 ]      cons(0, cons(1, cons(2, empty() ) ) ) = [ 0, 1, 2 ]      x ≡ cons(0, cons(1, cons(2, empty() ) ) ) = [ 0, 1, 2 ]      first(x) = 0      rest(x) = [ 1, 2 ]      first(rest(x) ) = 1      rest(rest(x) ) = [ 2 ]      first(rest(rest(x) ) = 2      rest(rest(rest(x) ) ) = [ ]      first(cons(elt, lst) ) = elt      rest(cons(elt, lst) ) = lst      Immutable lists in Java      자바의 인터페이스 예시      public interface ImList&lt;E&gt; {      // TODO: ImList&lt;E&gt; empty()      public ImList&lt;E&gt; cons(E e);      public E first();      public ImList&lt;E&gt; rest();  }        해당 인터페이스는 두가지 기능을 나타낸다.          Empty 빈 연산의 결과      Cons 축소 작업이 결과          public class Empty&lt;E&gt; implements ImList&lt;E&gt; {      public Empty() {      }      public ImList&lt;E&gt; cons(E e) {          return new Cons&lt;&gt;(e, this);      }      public E first() {          throw new UnsupportedOperationException();      }      public ImList&lt;E&gt; rest() {          throw new UnsupportedOperationException();      }  }          public class Cons&lt;E&gt; implements ImList&lt;E&gt; {      private final E e;      private final ImList&lt;E&gt; rest;          public Cons(E e, ImList&lt;E&gt; rest) {          this.e = e;          this.rest = rest;      }      public ImList&lt;E&gt; cons(E e) {          return new Cons&lt;&gt;(e, this);      }      public E first() {          return e;      }      public ImList&lt;E&gt; rest() {          return rest;      }  }        empty 를 구현하는 방법 중에 Empty 생성자를 호출하는 방식이 있다. 하지만 이러한 방식은 독립성의 손산을 유발      이러한 메서드를 팩토리로 구현 → ???    List&lt;String&gt; z = new ArrayList&lt;&gt;();        업데이트된 ImList      public interface ImList&lt;E&gt; {      public static &lt;E&gt; ImList&lt;E&gt; empty() {          return new Empty&lt;&gt;();      }      public ImList&lt;E&gt; cons(E e);      public E first();      public ImList&lt;E&gt; rest();  }        우리는 모든 연산을 구현하였고 아래와 같은 스냅샷 다이어그램을 확인 가능.| Java syntax | Functional syntax | Result || — | — | — || ImList nil = ImList.empty(); | nil = empty() | [ ] || nil.cons(0) | cons(0, nil) | [ 0 ] || nil.cons(2).cons(1).cons(0) | cons(0, cons(1, cons(2, nil))) | [ 0, 1, 2 ] || ImList x = nil.cons(2).cons(1).cons(0); | x = cons(0, cons(1, cons(2, nil))) | [ 0, 1, 2 ] || x.first() | first(x) | 0 || x.rest() | rest(x) | [ 1, 2 ] || x.rest().first() | first(rest(x)) | 1 || x.rest().rest() | rest(rest(x)) | [ 2 ] || x.rest().rest().first() | first(rest(rest(x))) | 2 || x.rest().rest().rest() | rest(rest(rest(x))) | [ ] || ImList y = x.rest().cons(4); | y = cons(4, rest(x)) | [ 4, 1, 2 ] |  이 구조에서 x 와 y 는 [1,2] 를 서로 공유 하고 있다는 것을 알고 있을것.Recursive datatype definitions  추상 데이터 타입의 ImList 는 두 구체적인 클래스 Empty , Cons 로 구성되어 있다.      하지만 ImList 또한 자기 자신을 재귀적으로 사용할 수 있다    ImList&lt;E&gt; = Empty + Cons(first:E, rest:ImList)    이러한 형식의 정의는 다음과 같다.          왼쪽이 추상 자료형, 오른쪽이 표현      포현은 + 로 구분된 데이터의 유형의 변형으로 구성      각각의 변형은 인자를 가진 constructor이다.        재귀형 데이터 타입의 다른 예인 이진트리          Tree&lt;E&gt; = Empty + Node(e:E, left:Tree&lt;E&gt;, right:Tree&lt;E&gt;)      Functions over recursive datatypes  변형이 있는 추상 데이터타입의 재귀적 정의는 무한 구조 처리, 각 타입에 대한 변형의 트리 구조 성립등에 이점을 갖는다.  예를 들어 사이즈를 측정하는 경우          size : ImList → int  // returns the size of the list        그리고 size의 크기를 정의한다.          size(Empty) = 0      size(Cons(first: E, rest: ImList)) = 1 + size(rest)        이러한 식을 다음과 같이 재귀적으로 볼 수 있다.size(Cons (0, Cons (1, Empty))) = 1 + size(Cons (1, Empty)) = 1 + (1 + size(Empty)) = 1 + (1 + 0) = 1 + 1 = 2이 정의로 자바 코드 작성public interface ImList&lt;E&gt; {    // ...    public int size();}public class Empty&lt;E&gt; implements ImList&lt;E&gt; {    // ...    public int size() { return 0; }}public class Cons&lt;E&gt; implements ImList&lt;E&gt; {    // ...    public int size() { return 1 + rest.size(); }}  이러한 재귀적 패턴을 구현하는법          추상 데이터 타입 인터페이스에서 연산을 선언      각각의 구체적인 변형에서 작동 실행            이러한 재귀적 패턴의 몇가지 예시    isEmpty : ImList → boolean          isEmpty(Empty) = true      isEmpty(Cons(first: E, rest: ImList)) = false        append: ImList × ImList → ImList          append(Empty, list2: ImList) = list2      append(Cons(first: E, rest: ImList), list2: ImList) = cons(first, append(rest, list2))      Tuning the rep      위의 size() 는 O(n) 시간이 소모  하지만 처음 계산 할때 크기 계산하는 방식으로 구성하면 O(1)      public class Cons&lt;E&gt; implements ImList&lt;E&gt; {      private final E e;      private final ImList&lt;E&gt; rest;      private int size = 0;      // rep invariant:      //   e != null, rest != null, size &gt;= 0      //   size &gt; 0 implies size == 1+rest.size()          // ...      public int size() {          if (size == 0) size = 1 + rest.size();          return size;      }  }              이러한 형식은 얼핏 보면 size 의 변화로 mutable하게 보인다. 하지만 이러한 방식은 beneficent mutation이다.      Rep independence and rep exposure revisited  우리는 이러한 클래스들을 숨겨오는것을 배웠고 pacakage-private를 활용해 더 잘 숨길수 있을것 이다.  오히려 size() 내 부에 배열을 숨기는 식으로 공간을 희생하고 더 빠른 계산의 가능Null vs empty  null 을 사용하고 싶은 욕구 주의  null 을 사용하면 매번 null 체크를 해야함          if (lst != null) n = lst.size();        코드가 더러워질 수가 있음          n = lst.size();      Declared type vs. actual type  type checking에는 컴파일 타임, 프로그램 실행 타임, 런타임 3가지로 나뉜다.          컴파일 시간에는 선언된 타입을 가진다 모든 메소드에 유형을 추론하여 검사한다.      런타임에는 실제 유형을 바탕으로 객체를 만든다. → 인터페이스를 선언할려고 하면 잡아낸다.      Another example: Boolean formulas  (P ∨ Q) ∧ (¬P ∨ R)이거를 아래와 같이 적기가 가능하다.Formula = Variable(name:String)          + Not(formula:Formula)          + And(left:Formula, right:Formula)          + Or(left:Formula, right:Formula)Backtracking search with immutability  서로 다른 인스턴스를 관리 하기위해 불변 리스트로 시작했지만 리스트의 끝만 공유 하는 방식으로 우린 수정했다.  backtracking 방식은 이런 목록에서 매우 우수하다.  단 mutable 리스트에는 이러한 백트래킹이 좋진 않다.  공유가 없는 immutable 또한 좋진 않다.  공유적인 immutable 리스트에 backtracking이 좋다는걸 기억하자."
  },
  
  {
    "title": "Recursion",
    "url": "/learninghub/study/mit6.005-software%20construction/Recursion/",
    "categories": "Study, MIT6.005-Software Construction",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Object  recursion 문제를 base case와 recursive steps로 분리 할 수 있습니다.  recursion에 help methods를 이해합니다.  recursion vs iteation 의 장단점을 이해합니다.Recursion  이미 recursion에 대한 사양을 가지고 있을때, 어떻게 구현하면 좋은가?  recursion...",
    "content": "Object  recursion 문제를 base case와 recursive steps로 분리 할 수 있습니다.  recursion에 help methods를 이해합니다.  recursion vs iteation 의 장단점을 이해합니다.Recursion  이미 recursion에 대한 사양을 가지고 있을때, 어떻게 구현하면 좋은가?  recursion은 모든 프로그램에 적절하다고는 볼 수 없지만 개발 도구 중 하나로는 여전히 중요한 방식입니다.  일반적으로 피보나치 함수와 나누기에 대해서 재귀를 사용한다.  재귀 함수는 base case와 recursive steps로 나누어진다.          base case : 함수 호출에 대해 즉시 결과를 계산한다.      recursive steop : 하나 이상의 재귀적 호출에 도움을 받아 계산        팩토리얼에 대해서 아래 두가지 예시          Iterative          public static long factorial(int n) {    long fact = 1;    for (int i = 1; i &lt;= n; i++) {      fact = fact * i;    }    return fact;  }              Recursive          public static long factorial(int n) {    if (n == 0) {      return 1;    } else {      return n * factorial(n-1);    }  }              recursive 구현에서 n = 0 일때 즉시 값을 반환한다. → Base case      n &gt; 0 보다 클 때 재귀를 호출 → Recursice steps      이를 시각화        | starts in  main | calls  factorial(3) | calls  factorial(2) | calls  factorial(1) | calls  factorial(0) | returns to  factorial(1) | returns to  factorial(2) | returns to  factorial(3) | returns to  main |  | — | — | — | — | — | — | — | — | — |    자기자신인 factorial(n- 1) 을 호출하면서 call Stack을 쌓이게 하고 그 후에 풀어가면서 계산하는 방식      다른 예 피보나치      /**   * @param n &gt;= 0   * @return the nth Fibonacci number   */  public static int fibonacci(int n) {      if (n == 0 || n == 1) {          return 1; // base cases      } else {          return fibonacci(n-1) + fibonacci(n-2); // recursive step      }  }        피보 나치는 n= 0 과 n = 1의 base case를 가지고 있다.**Choosing the Right Decomposition for a Problem**  재귀를 위해 문제를 분해하는 것은 중요하다.  좋은 decompositions(분해)는 짧고, 이해하기 쉽고, 버그에 안전하고, 변화에 유연해야한다.      다음과 같은 명세를 가정하자      /**   * @param word consisting only of letters A-Z or a-z   * @return all subsequences of word, separated by commas,   * where a subsequence is a string of letters found in word   * in the same order that they appear in word.   */  public static String subsequences(String word)        subsequences(\"abc\") 의 경우 \"abc,ab,bc,ac,a,b,c,” 분해 한다면?      다음과 같은 재귀 코드를 작성할 수 있다.       1 public static String subsequences(String word) {   2     if (word.isEmpty()) {   3         return \"\"; // base case   4     } else {   5         char firstLetter = word.charAt(0);   6         String restOfWord = word.substring(1);   7   8         String subsequencesOfRest = subsequences(restOfWord);   9  10         String result = \"\";  11         for (String subsequence : subsequencesOfRest.split(\",\", -1)) {  12             result += \",\" + subsequence;  13             result += \",\" + firstLetter + subsequence;  14         }  15         result = result.substring(1); // remove extra leading comma  16         return result;  17     }  18 }      Structure of Recursive Implementations  Base case : 더 이상 분해 할 수 없는 경우 빈 문자열, 빈 리스트, 빈 트리, 0 등등…  recursive step : 분해할 수 있는 것 작게 분해 후 재결합하여 문제를 해결하는 단계  문제를 최대한 작게 분할 하는 것은 중요하다 이렇게 하지 않으면 재귀가 끊나지 않을 가능성도 존재Helpe Methods  subsequences() 는 문제를 decomposition 하고 재귀적으로 해결하는 예시이다.  이러한 subproblem을 만들어서 문제를 해결하는 방식은 direct recursive implenation 이다.  어떠한 케이스의 경우 명세에서 recursive step에 대한 강력한 명세를 표현하는 것은 재귀적 분해를 더 우아하게 도와준다.  이러한 경우 부분적인 subsequence를 활용하여 부분적인 완성을 한다면?  예를 들어 “orange”가 있다면 첫 글짜 “o” 를 받고 “range” 는 재귀적으로 확장을 시도한다.      이를 코드로 작성한다면…      /**   * Return all subsequences of word (as defined above) separated by commas,   * with partialSubsequence prepended to each one.   */  private static String subsequencesAfter(String partialSubsequence, String word) {      if (word.isEmpty()) {          // base case          return partialSubsequence;      } else {          // recursive step          return subsequencesAfter(partialSubsequence, word.substring(1))               + \",\"               + subsequencesAfter(partialSubsequence + word.charAt(0), word.substring(1));      }  }        이러한 subsequencesAfter 를 helper method 라고 부른다.  이것은 본래 subsequences 와는 다른 명세를 만족시킵니다. 새로운 파라미터를 가지고 있기 때문에 (partialSubsequence)  이 매개변수는 단순한 반복에서 사용하는 지역 변수와 비슷한 역할을 한다.  이것은 단어의 끝까지 도달하는 것을 부분 연속을 유일한 결과로 반환한다.  이러한 재귀는 가능한 시퀸스를 백트랙킹한다.      구현을 완료하기 위해, 원본을 구현한다.      public static String subsequences(String word) {      return subsequencesAfter(\"\", word);  }        helper method 를 사용자에게 노출시키지 말것.  이런 helper method를 명세를 변경할 필요는 없다. → 이는 변경성을 저하  사용자는 언제나 기존의 방식을 유지한것처럼 보이게 하자.**Choosing the Right Recursive Subproblem**      다음과 같은 예제 integer 를 string (2진법)으로 변환하는 예제      **   * @param n integer to convert to string   * @param base base for the representation. Requires 2&lt;=base&lt;=10.   * @return n represented as a string of digits in the specified base, with   *           a minus sign if n&lt;0.   */  public static String stringValue(int n, int base)        stringValue(16, 10) 는 10000 를 리턴한다.      음수를 처리할려면 이 코드를 추가한다.    if (n &lt; 0) return \"-\" + stringValue(-n, base);    n = 829 ( 10진수 ) 라고 가정할때 어떤식으로 재귀로 분리 하겠는가?**Recursive Problems vs. Recursive Data**  우리가 봐왔던 케이스의 경우는 문재 구조가 자연스럽게 재귀적인 겅의를 부여하는 경우  재귀적 문제는 도구 상자에서 재귀적 해결을 꺼내는 것과 같다.  만약에 데이터 자체가 재귀적인 경우에는?          대표적으로 파일 시스템 A 폴더 → B 폴더 → C파일        java.io.File 은 대표적으로 파일 사용에 사용되는 라이브러리  f.getParentFile() 은 f 파일의 상위 폴더를 반환하는 메소드      이런 재귀적 데이터의 경우 자연스럽게 재귀 구조를 갖는다.      /**   * @param f a file in the filesystem   * @return the full pathname of f from the root of the filesystem   */  public static String fullPathname(File f) {      if (f.getParentFile() == null) {          // base case: f is at the root of the filesystem          return f.getName();      } else {          // recursive step          return fullPathname(f.getParentFile()) + \"/\" + f.getName();      }  }      Reentrant Code  재진입 이라는 용어는 일반적인 프로그래밍에서 특별한 경우에 속한다.  재진입 코드는 안전하게 재진입 하기에 호출되는 와중에도 재 진입이 가능하다.  재진입 코드는 파라미터와 지역변수의 상태를 전체적으로 안전하게 지켜준다.  전역변수의 사용을 없애고 가변 객체의 aliasese와 공유하지 않는다.  Direct recursion은 재진입이 일어날 수 있는 한가지 방법으로, factorial() 메소드는 factorial(n) 의 작업이 끝나지 않았지만 factorial(n-1) 을 호출 하는 방법으로 디자인 되어졌습니다.  Mutal recursion은 두개 또는 더 많은 경우가 일어날 수 있다.          A가 B를 호출하고 다시 A를 호출한다.      이러한 방식은 항상 프로그래머가 의도적으로 설계 하는 방식이지만 버그를 초래할 수도 있다.        Concurrency에서도 일어날 수 있다.  재진입 코드는 언제나 안전하게 사용해야함을 잊지 말자**When to Use Recursion Rather Than Iteration**  재귀를 사용하는 두 유형에 대해 공부했다          문제 자체가 자연스럽게 재귀일때      데이터가 재귀일때        재귀를 사용하는 또 다른 이유는 불변성입니다.  이상적인 재귀 구현에 있어 모든 변수는 상수 이고 불변성을 가져야합니다.  재귀 메소드는 어떠한 것도 변형하지 않는다는 점에서 순수한 메소드입니다.  메소드를 파라미터와 리턴 값에 대한 관계로 이해할 수 있다면 side effects는 없다고 볼 수 있다.  다양한 함수적 프로그래밍에서 이러한 이점을 가지며 명령형 프로그래밍 보다 이해하기가 쉽다.  하지만 재귀 구조에서는 많은 임시 변수가 선언되기에 이러한 동작을 스냅샷을 그리기에는 조금 복잡하다  또한 반복 솔류션 보다 공간 복잡도가 높다는 것인데 call Stack을 호출하한다는 단점이 있다.**Common Mistakes in Recursive Implementations**  재귀에서 일어날 수 있는 실수          Base case의 누락      더이상 밑의 step으로 감소되지 못함 → 무한 재귀      Summary  오늘 공부한 내용          재귀 문제와 재귀 데이터      재귀 문제의 대안적 해결      Helper method      반복 vs 재귀        재귀는 불변 객체를 사용하기에 버그로부터 안전해진다  재귀는 반복 솔루션보다 짧기에 이해가기가 쉽다.  재귀는 변화에 유연하다."
  },
  
  {
    "title": "Mutability & immutability",
    "url": "/learninghub/study/mit6.005-software%20construction/Mutability-&-Immutability/",
    "categories": "Study, MIT6.005-Software Construction",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Object  가변 객체와 가변성에 대해 이핸다.  allasing(별명 짓기)를 Identify 성과 가변성의 위험을 이해  불변성을 사용해 정확성, 명확성,등을 개선한다.Mutability  Java의 일부 객체는 불변성을 가지고 있다.  한번 생성되면 → 항상 동일한 값을 가지고 있다. [Immutability]  한번 생성되면 → 추후 값을 변...",
    "content": "Object  가변 객체와 가변성에 대해 이핸다.  allasing(별명 짓기)를 Identify 성과 가변성의 위험을 이해  불변성을 사용해 정확성, 명확성,등을 개선한다.Mutability  Java의 일부 객체는 불변성을 가지고 있다.  한번 생성되면 → 항상 동일한 값을 가지고 있다. [Immutability]  한번 생성되면 → 추후 값을 변경하는 메소드가 있다. [Mutability]      String 은 불변 타입의 가장 큰 예시이다. 같은 객체는 항상 동일한 문자열만을 나타낸다.      String s = \"a\";  s = s.concat(\"b\"); // s+=\"b\" and s=s+\"b\" also mean the same thing              s 라는 String 객체는 언제나 “a” 만을 담고 있다.      하지만 concat 을 통해 이어 붙일 시에 새로운 ab라는 객체를 만들어 저장한다.      s가 가르키는 주소가 변경되는 형태                StringBuilder 는 가변 타입의 예시이다. 문자열을 일부 삭제, 삽입등을 방법을 가지고 있다.      StringBuilder sb = new StringBuilder(\"a\");  sb.append(\"b\");              하지만 StringBuiler 는 다르다.      하나의 sb 객체에 값을 직접 수정하는 식으로 변경한다.      String t = s;t = t + \"c\";StringBuilder tb = sb;tb.append(\"c\");  일반적인 String 에서 t 와 s 는 같은 객체를 가르킨다. 물론 tb 와 sb 또한 같은 객체를 가르킨다.  하지만 값의 변경이 이루어질 때 t 는 새로운 객체인 abc 를 생성해서 가르키지만, tb 는 sb 와 함께 가르키는 객체를 수정해 sb 또한 같이 값이 변경된다.      String 의 사용이 일부 코드에서 지양되는 이유      String s = \"\";  for (int i = 0; i &lt; n; ++i) {      s = s + n;  }      ///////////////////////////////////  String s = \"\";  for (int i = 0; i &lt; n; ++i) {  \t  StringBuilder sb = new StringBuilder();      for (int j = 0; j &lt; s.length; j++) { // 기존 문자열 n -1 번 반복  \t\t\t\tsb.append(s.charAt(j);// 기존의 s의 문자열을 하나하나 새로운 값에 넣어야함   \t\t}  \t\tsb.append(n);  \t\ts = sb;  }              String 에 대한 많은 변경이 이루어질 때 너무나 많은 임시적 복사본이 생성된다.      위 코드에서는 n 개의 String 객체가 생성될 위험을 가진다.      시간 복잡도 면에서도  O($n^2$)를 가진다            StringBuilder 객체는 이러한 문제를 해결 할 수 있다.      StringBuilder sb = new StringBuilder();  for (int i = 0; i &lt; n; ++i) {    sb.append(String.valueOf(n));  }  String s = sb.toString();              StringBuilder 는 이러한 복사본을 최소화한다.      마지막 까지 복사본을 만들지 않고 계속해서 객체 내부의 값만 수정한다.      가변 객체는 객체를 공유함으로써 더 성능 좋은 통신이 가능하다.      Risks of mutation  가변 타입을 불변 타입보다 강력하게 보인다.  그러면 왜 불변 타입을 사용하는걸까…?  불변 타입은 버그로부터 안전하고, 이해하기 쉬우며, 변화에 준비됬다.  가변성은 코드를 이해하기 어렵게 만든다 두가지 예시**Risky example #1: passing mutable values**/** @return the sum of the numbers in the list */public static int sum(List&lt;Integer&gt; list) {    int sum = 0;    for (int x : list)        sum += x;    return sum;}  단순히 리스트의 값을 모두 더하는 코드  만약 절대 값도 처리하고 싶다면 다음과 같이 코드를 변경한다./** @return the sum of the absolute values of the numbers in the list */public static int sumAbsolute(List&lt;Integer&gt; list) {    // let's reuse sum(), because DRY, so first we take absolute values    for (int i = 0; i &lt; list.size(); ++i)        list.set(i, Math.abs(list.get(i)));    return sum(list);}  이 코드는 list를 직접 변경하여 사용한다.  얼핏 보면 효율적인 코드로 보인다. (DRY 우수)  하지만 이 코드는 잠재적인 버그를 가지고 있다. → 가변객체를 통과시키는것 , 추후에 디버깅 난이도 상승/** @return the sum of the absolute values of the numbers in the new list */public static int sumAbsolute(List&lt;Integer&gt; list) {    List&lt;Integer&gt; absoluteValues = new ArrayList&lt;&gt;();    for (int num : list) {        absoluteValues.add(Math.abs(num));    }    return sum(absoluteValues);}  가변 객체를 넘기는것보단 새로운 리스트를 생성해서 넘기는 것이 조금더 안전하다.**Risky example #2: returning mutable values**  우리가 가변 객체를 함수에 전달하면 생기는 문제를 보았다. 가변 객체를 return 하는 것은?  Date 를 고려해보자. 이건 가변 타입이다. 우리가 만약 첫번 째 날이 봄날인지 가정하는 코드를 쓴다면?/** @return the first day of spring this year */public static Date startOfSpring() {    return askGroundhog();}  Groundhog 알고리즘을 사용하여 봄의 시작을 계산하는 코드// somewhere else in the code...public static void partyPlanning() {    Date partyDate = startOfSpring();    // ...}  전체적인 코드는 작동하지만 두가지 수정 사항이 생겼다.                  매번 코드에 대한 질문을 대답해야 하기에 추후에 대답을 위해서 코드를 수정한다.          /** @return the first day of spring this year */  public static Date startOfSpring() {      if (groundhogAnswer == null) groundhogAnswer = askGroundhog();      return groundhogAnswer;  }  private static Date groundhogAnswer = null;                            봄의 날씨가 너무 춥기에 봄의 시작일에서 한달 뒤로 코드를 수정해야한다.          // somewhere else in the code...  public static void partyPlanning() {      // let's have a party one month after spring starts!      Date partyDate = startOfSpring();      partyDate.setMonth(partyDate.getMonth() + 1);      // ... uh-oh. what just happened?  }                    partyDate의 Month 를 1 올렸지만, groundHogAnswer도 1 오르는 문제가 발생한다.      또한 11(12월)의 경우 잘못된 값을 내보낼 수 있다        결과적으로 이 코드는…          잠재적 버그를 가지고 있다.      변화를 위한 준비는 좋지만 이것이 버그를 도입하지 않고 바꾸는것이 중요하다…        각 두 예제에서 List&lt;Integer&gt; 와 Date 를 불변 유형이였다면 이러한 문제를 피할 수 있을것이다.  물론 Java.time , LocalDateTime 같은 불변 타입을 사용한다면 버그를 피할 수 있다.  이런 예제는 왜 가변 타입이 나쁜 성능을 보이는지 알려줍니다.  이런 버그를 피하는 간단한 방법은 명세나 메소드 시그니처의 변경을 피하는 것이다          startOfSpring() 에서 항상 복사본을 return 한다.      return new Date(groundhogAnswer.getTime());        이러한 패턴을 defensive copying 이라고 한다.  이는 추상적인 데이터 타입이며 기존의 값에 영향을 주지 않고 자유롭게 사용이 가능하다. → 캡슐화 달성  그러나 이러한 방어적 복사는 이용자가 추가적인 공간과 작업이 요구 된다. 즉 99%의 사용자가 날짜를 변경하지 않더라도 이런 오버헤드는 발생한다.  불변성은 이런 오버헤드가 없다. 즉 이런 상황에서는 불변성이 더욱 이득이 되는 상황**Aliasing is what makes mutable types risky**  일반적으로 가변 객체를 지역적으로 사용하는 것은 괜찮다.  하지만 다양한 객체에 aliases 라고 불리는 여러개의 참조를 가지는것에 문제가 있다.                  List 객체를 사용하는 sum , sumAbsolute 이건 다양한 사람이 협업하는 과정에서 문제가 발생        (한 프로그래머는 sumAbsolute 만을 수정하면서 sum 은 유지되기를 희망할 때)                    Date 같은 경우 groundhogAnswer 와 partyDate 를 가리키는데 이 또한 각자 같은 객체를 참조하지만 다른 곳에 위치 되어 있어 코드를 읽기 어렵게 한다.            **Specifications for mutating methods**  가변성 있는 메소드의 수행에 대해 명세에 포함하는 것은 중요합니다.  우리는 앞서 가변성이 버그의 원인이 됨을 확인하였다.static void sort(List&lt;String&gt; lst)requires: nothingeffects:  puts lst in sorted order, i.e. lst[i] &lt;= lst[j]              for all 0 &lt;= i &lt; j &lt; lst.size()  가변성을 제거한 명세static List&lt;String&gt; toLowerCase(List&lt;String&gt; lst)requires: nothingeffects:  returns a new list t where t[i] = lst[i].toLowerCase()  변이는 결국 끔찍한 버그로 이어지는 것을 언제나 명심할것**Iterating over arrays and lists**  가변 객체중에 Iterator 를 확인해보자.  Collections의 요소들을 순차적으로 확인하는 객체로써 자바에서는 List의 loop에서 주로 사용된다.List&lt;String&gt; lst = ...;for (String str : lst) {    System.out.println(str);}  이걸 컴파일러는 이렇게 해석한다…List&lt;String&gt; lst = ...;Iterator iter = lst.iterator();while (iter.hasNext()) {String str = iter.next();    System.out.println(str);}  iterator가 가지고 있는 두가지 메소드          next() returns the next element in the collection      hasNext() tests whether the iterator has reached the end of the collection.        주목할 것은 next() 는 가변 메소드로써 단순히 요소를 리턴할 뿐만 아니라 다음 값을 찾는다MyIterator      MyIterator의 구현      /**   * A MyIterator is a mutable object that iterates over   * the elements of an ArrayList&lt;String&gt;, from first to last.   * This is just an example to show how an iterator works.   * In practice, you should use the ArrayList's own iterator   * object, returned by its iterator() method.   */  public class MyIterator {          private final ArrayList&lt;String&gt; list;      private int index;      // list[index] is the next element that will be returned      //   by next()      // index == list.size() means no more elements to return          /**       * Make an iterator.       * @param list list to iterate over       */      public MyIterator(ArrayList&lt;String&gt; list) {          this.list = list;          this.index = 0;      }          /**       * Test whether the iterator has more elements to return.       * @return true if next() will return another element,       *         false if all elements have been returned       */      public boolean hasNext() {          return index &lt; list.size();      }          /**       * Get the next element of the list.       * Requires: hasNext() returns true.       * Modifies: this iterator to advance it to the element       *           following the returned element.       * @return next element of the list       */      public String next() {          final String element = list.get(index);          ++index;          return element;      }  }        Instance varibles : 자바에서 필드라고 불리는 인스턴스 변수로써 매개변수와 로컬 변수와는 차이가 있다. 객체의 인스턴스에 저장되고 일반적인 로컬 변수보다는 더 오래 가는것을 명심  Constructor : 객체를 생성  this : 인스턴스 변수를 참조하는데 사용  etc…  list 는 final 로 선언되어져 있다.          이는 불변 객체로 선언되어 관리됨을 알 수 있다…      이런 일반적인 반복자의 개념은 다양한 언어에서 사용된다. (디자인 패턴)      **Mutation undermines an iterator**      아래 코드는 iterator를 사용하는 예 이다.      /**   * Drop all subjects that are from Course 6.   * Modifies subjects list by removing subjects that start with \"6.\"   *   * @param subjects list of MIT subject numbers   */  public static void dropCourse6(ArrayList&lt;String&gt; subjects)        dropCourse6 은 클라이언트에게 인수가 변경될 것을 경고한다.      테스트를 위해서 입력을 분할한다.      // Testing strategy:  //   subjects.size: 0, 1, n  //   contents: no 6.xx, one 6.xx, all 6.xx  //   position: 6.xx at start, 6.xx in middle, 6.xx at end      // Test cases:  //   [] =&gt; []  //   [\"8.03\"] =&gt; [\"8.03\"]  //   [\"14.03\", \"9.00\", \"21L.005\"] =&gt; [\"14.03\", \"9.00\", \"21L.005\"]  //   [\"2.001\", \"6.01\", \"18.03\"] =&gt; [\"2.001\", \"18.03\"]  //   [\"6.045\", \"6.005\", \"6.813\"] =&gt; []          public static void dropCourse6(ArrayList&lt;String&gt; subjects) {      MyIterator iter = new MyIterator(subjects);      while (iter.hasNext()) {          String subject = iter.next();          if (subject.startsWith(\"6.\")) {              subjects.remove(subject);          }      }  }            테스트 결과      // dropCourse6([\"6.045\", \"6.005\", \"6.813\"])  //   expected [], actual [\"6.005\"]              마지막은 실패했다.        이건 모든 Iterator 를 사용하는 모든 곳에서 나타나는 문제for (String subject : subjects) {    if (subject.startsWith(\"6.\")) {        subjects.remove(subject);    }}  이건 결과적으로 [Concurrent­Modification­Exception](http://docs.oracle.com/javase/8/docs/api/?java/util/ConcurrentModificationException.html)를 유발한다.      이 문제를 해결할려면…      Iterator iter = subjects.iterator();  while (iter.hasNext()) {      String subject = iter.next();      if (subject.startsWith(\"6.\")) {  \t\t\titer.remove(subject);      }  }              iter.remove() 로 변경한다.      기존의 subjects.remove() 는 리스트에서 해당 요소를 다시 찾아서 제거 한다. (예외발생)      iter.remove() 는 현재 순회 중에 요소를 삭제 할 수 있는 유일한 방법…        이렇게 해서 전체 문제를 해결했다고는 볼 수 없다.          만약 같은 Iterator를 다른 프로그램이 실행중이라면..?’            이 문제에 대한 스냅샷 다이어그램      **Mutation and contracts****Mutable objects can make simple contracts very complex**  가변 데이터 구조체에 대한 기능적 이슈입니다.  같은 가변 객체에 대한 다양한 참조(aliasese 라고도 불림)  다양한 위치에 있는 참조가 한 객체를 의존하고 있는 상태  이러한 경우 다양한 곳에 위치한 참조자 들끼리 서로 가변 객체를 좋은 방식으로 다루기를 기도하는 방법뿐…  이러한 방식의 대표적은 Java의 Collections          Collections 은 이러한 방식에 대해서 어떻게 기록하고 있는가?      수정 (List 를 추가하거나 삭제)할때 어떤 식으로 책임은 Collections , List , Iterator  중에 누가 책임지나?        Solution                  synchronizing 사용 → Concurrency 보장        List list = Collections.synchronizedList(new ArrayList(...));                    Stram() ,  parallelStream() 활용          List&lt;String&gt; list = Arrays.asList(\"one\", \"two\", \"three\", \"four\", \"five\");  list.parallelStream().forEach(element -&gt; {  // 동시성으로 요소 처리  });                      이와 같이 가변 속성은 추론에 대한 비용이 들어가기 때문에, 프로그램과 데이터 구조에 대한 이해가 더 어렵다.  가변성은 편의성과 성능에 큰 이점을 주기에 버그 안정성과 비교해서 잘 비교해 사용하자.**Mutable objects reduce changeability**  가변 객체는 구현자와 사용자 사이에서 높은 복잡한 제약을 요구하고 변경에 대한 높은 비용을 요구합니다.  즉 Object 를 사용한다는 것은 코드의 변경을 힘들게 하는 것이라고도 말할 수 있다.      Example (MIT에서 사용자의 이름을 검색하고 9자리 식별번호를 반환)      /**   * @param username username of person to look up   * @return the 9-digit MIT identifier for username.   * @throws NoSuchUserException if nobody with username is in MIT's database   */  public static char[] getMitId(String username) throws NoSuchUserException {      // ... look up username in MIT's database and return the 9-digit ID  }              해당 명세에 따라 클라이언트가 이렇게 요청한다.          char[] id = getMitId(\"bitdiddle\");  System.out.println(id);              이 상태에서 유저의 개인정보 보호를 위해 구현자와 사용자는 id 앞 5글자에 *****로 가리기로 한다.          char[] id = getMitId(\"bitdiddle\");  for (int i = 0; i &lt; 5; ++i) {      id[i] = '*';  }  System.out.println(id);              구현자는 캐쉬를 추가한다.          private static Map&lt;String, char[]&gt; cache = new HashMap&lt;String, char[]&gt;();      public static char[] getMitId(String username) throws NoSuchUserException {      // see if it's in the cache already      if (cache.containsKey(username)) {          return cache.get(username);      }          // ... look up username in MIT's database ...          // store it in the cache for future lookups      cache.put(username, id);      return id;  }              이러한 방식에 대해서 발생하는 문제가 있다.      id 는 가변 객체(aliased)에 * 를 추가한다면 cache의 배열까지 수정한다.      가변 객체를 공유 하는 것은 또다시 누구의 책임이 있는지 애매해진다.                  구현자는 return 값을 고정해야만 하는가?          사용자는 return 값을 수정하면 안되는가?                          새로 적은 명세      public static char[] getMitId(String username) throws NoSuchUserException     requires: nothing    effects: returns an array containing the 9-digit MIT identifier of username,               or throws NoSuchUserException if nobody with username is in MIT’s               database. Caller may never modify the returned array.              여전히 문제가 존재한다.      이 코드의 문제는 이러한 제약이 프로그램 전체에 미친다는 것이다.                  array를 절대 수정하지 말것                    기존의 precondition과 postcondition들은 메소드의 주변만 생각했지 다른 곳에서까지 생각할 필요가 없었다는 것을 떠올리면 매우 큰 제약.            비슷한 문제를 가진 예제      public static char[] getMitId(String username) throws NoSuchUserException     requires: nothing    effects: returns a new array containing the 9-digit MIT identifier of username,               or throws NoSuchUserException if nobody with username is in MIT’s               database.              새로운 배열을 return 한다고 해서 완전한 문제를 해결할 수 있는것은 아니다.      여전히 구현자는 새로운 array를 alias 하지 않는다고 보장하지 못한다.            더 나은 예제      public static String getMitId(String username) throws NoSuchUserException     requires: nothing    effects: returns the 9-digit MIT identifier of username, or throws               NoSuchUserException if nobody with username is in MIT’s database.              String 을 return 함으로써 불변성을 보장한다.      또한 불변성이 보장 받았기에 cache를 자유롭게 사용할 수 있다.  → 성능 향상      **Useful immutable types**  일반적으로 immutable은 다양한 문제를 피할 수 있기에, Java API에서의 일반적인 불변 유형 열거          primitive type, primitive는 immutable 입니다.      BigInteger , BigDecimal 또한 immutable 입니다.      mutable한 Date 의 사용을 지양하세요. 시간을 기록할 때 에는 java.time 을 사용하세요.      자바 Collections의 구현에 있어서 모두 mutable 입니다. immutable 하게 할려면 아래를 활용하세요                  Collections.unmodifiableList          Collections.unmodifiableSet          Collections.unmodifiableMap                    mutable한 collection을 다른 프로그램에 전달하기 전에 이 collection을 수정할수 없도록 wrapper 할 수 있습니다.      final 참조는 Object에서는 수정이 가능합니다.      Collections 는 Collections.emptyList 를 통해서 빈 불변 리스트를 생성할 수 있습니다.                  이 빈 리스트는 null 을 사용하는 것을 줄일 수 있는 장점이 있습니다.                    Summary  mutability는 성능과 편의성에 우위를 가지지만, 버그의 위험성을 가진다. 또한 정확성을 추론하기에 높은 비용을 요구한다.  immutable 객체의 차이에 대해서 String 은 immutable 객체, final 은 불변 참조를 이해한다.  immutablility는 결과적으로 버그로부터 안전하고 이해하기 쉬우며, 변화에 준비된 것을 확인 할 수 있다.          물론 비용에 대한 단점도 존재한다…      "
  },
  
  {
    "title": "Interface",
    "url": "/learninghub/study/mit6.005-software%20construction/Interface/",
    "categories": "Study, MIT6.005-Software Construction",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Objectives  ADT를 정의하고 인터페이스를 구현하는 클래스를 작성하기Interfaces  자바의 interface 는 추상 데이터 유형 표현해 유용한 언어 메커니즘  메서드 시그니쳐는 있지만… bodies는 없다.  interface 는 모든 메서드에 대한 메서드 bodies를 정의한다. 따라서 JAVA에서 인터페이스는 추상 데이터 타입을 정...",
    "content": "Objectives  ADT를 정의하고 인터페이스를 구현하는 클래스를 작성하기Interfaces  자바의 interface 는 추상 데이터 유형 표현해 유용한 언어 메커니즘  메서드 시그니쳐는 있지만… bodies는 없다.  interface 는 모든 메서드에 대한 메서드 bodies를 정의한다. 따라서 JAVA에서 인터페이스는 추상 데이터 타입을 정의하는데 한가지 방법으로 사용된다.  이러한 방식을 사용하는 장점은 사용자에게 contract를 명시하고 더이상은 아니라는 것이다.  사용자가 ADT를 이해하는 것 오직 그뿐  interface 에는 인스턴스 변수를 넣을 수가 없기에 의도치 않은 종속성이 생성될 위험이 없음  구현은 서로 다른 클래스에서 분리된다.  Interface는 여러 클래스와 프로그램에서 동시에 존재가 가능하다.  하나의 클래스로만 추상 데이터 타입을 표시한다면 더 어려워진다. → 일반적인 클래스는 두 표현을 동시에 적을 수 없다.  자바의 Static checking은 ADT에 대해서 컴파일러가 여러 실수를 잡을 수 있게도 도와준다.**Example: MyString**      MyString 의 예제를 다시 보자      /** MyString represents an immutable sequence of characters. */  public interface MyString {          // We'll skip this creator operation for now      // /** @param b a boolean value      //  *  @return string representation of b, either \"true\" or \"false\" */      // public static MyString valueOf(boolean b) { ... }          /** @return number of characters in this string */      public int length();          /** @param i character position (requires 0 &lt;= i &lt; string length)       *  @return character at position i */      public char charAt(int i);          /** Get the substring between start (inclusive) and end (exclusive).       *  @param start starting index       *  @param end ending index.  Requires 0 &lt;= start &lt;= end &lt;= string length.       *  @return string consisting of charAt(start)...charAt(end-1) */      public MyString substring(int start, int end);  }            Constructort를 사용하서 아래의 첫번째 구현      public class SimpleMyString implements MyString {          private char[] a;          /* Create an uninitialized SimpleMyString. */      private SimpleMyString() {}          /** Create a string representation of b, either \"true\" or \"false\".       *  @param b a boolean value */      public SimpleMyString(boolean b) {          a = b ? new char[] { 't', 'r', 'u', 'e' }                : new char[] { 'f', 'a', 'l', 's', 'e' };      }          @Override public int length() { return a.length; }          @Override public char charAt(int i) { return a[i]; }          @Override public MyString substring(int start, int end) {          SimpleMyString that = new SimpleMyString();          that.a = new char[end - start];          System.arraycopy(this.a, start, that.a, 0, end - start);          return that;      }  }            최적화 구현      public class FastMyString implements MyString {          private char[] a;      private int start;      private int end;          /* Create an uninitialized FastMyString. */      private FastMyString() {}          /** Create a string representation of b, either \"true\" or \"false\".       *  @param b a boolean value */      public FastMyString(boolean b) {          a = b ? new char[] { 't', 'r', 'u', 'e' }                : new char[] { 'f', 'a', 'l', 's', 'e' };          start = 0;          end = a.length;      }          @Override public int length() { return end - start; }          @Override public char charAt(int i) { return a[start + i]; }          @Override public MyString substring(int start, int end) {          FastMyString that = new FastMyString();          that.a = this.a;          that.start = this.start + start;          that.end = this.start + end;          return that;      }  }        이전의 ADT와 비교한다면 static valueOf 가 현재 생성자 안에서 나타나며 this 를 사용하고 있다.  또한 @Override 의 표현의 사용 해당 annotation은 컴파일러에게 인터페이스의 메소드 중 하나와 동일한 시그니쳐를 가짐을 알린다.  물론 코드의 이해를 돕기 위해서도 사용된다.  우리가 새로 만든 substring(...) 에 집중하자면 이건 데이터의  빈 생성자의 경우 자바가 기본적으로 명시해준다.  하지만 boolean b를 받는 생성자를 추가함으로써 기본 생성자 또한 적어줘야한다.  좋은 ADT는 자신의 불변량을 보존한다.  아무것도 하지 않은 생성자는 좋지 않은 패턴이다. → 불변량을 설정하지 않으니깐…      사용자가 해당 ADT를 사용한다면..?      MyString s = new FastMyString(true);   System.out.println(\"The first character is: \" + s.charAt(0));            아래 코드와 많이 유사하다.      List&lt;String&gt; s = new ArrayList&lt;String&gt;();  ...        이 코드는 오히려 추상화 장벽을 무너트린다… 왜?  Client가 구체적인 class 이름을 알아야함  Java의 인터페이스는 생성자를 포함할 수 없기 때문에 실제로 생성자는 관련된 클래스 중에서 하나를 직접 호출해야하지만 그 생성자의 spec은 인터페이스에 적어져 있지 않음. → 동일한 생성자가 적용된다는 보장이 없음  Java 8 이상에서는 static methods가 포함되도록 허용되어 Creator 연산을 흉내낼 수 있다.      valueOf 방식으로 static factory method 추가한 코드      public interface MyString {          /** @param b a boolean value       *  @return string representation of b, either \"true\" or \"false\" */      public static MyString valueOf(boolean b) {          return new FastMyString(true);      }          // ...              추상화 장벽을 허물지 않고 ADT를 사용          MyString s = MyString.valueOf(true);  System.out.println(\"The first character is: \" + s.charAt(0));      Example : Set  Java Collection 제공하는 interface와 구현을 분리하는 예      Set 인터페이스      /** A mutable set.   *  @param &lt;E&gt; type of elements in the set */  public interface Set&lt;E&gt; {            Set 은 generic 타입이다. → 타입은 추후에 결정됨          // example creator operation      /** Make an empty set.       *  @param &lt;E&gt; type of elements in the set       *  @return a new set instance, initially empty */      public static &lt;E&gt; Set&lt;E&gt; make() { ... }        make  는 static factory 방식으로 구현됩니다.  Set&lt;String&gt; strings = Set.make();      그리고 컴파일러는 새로운 Set 과 String object를 만드는 것으로 이해합니다.      // example observer operations          /** Get size of the set.       *  @return the number of elements in this set */      public int size();          /** Test for membership.       *  @param e an element       *  @return true iff this set contains e */      public boolean contains(E e);        다음으로 두개의 observer 메서드 가 있다.  집합(set)에 대한 추상적인 개념으로 볼때 spec이 어떤지 .      특정 private field가 있는 집합의 특정 구현에 새부적인 구현을 언급하는것은 옳지 않다.       // example mutator operations          /** Modifies this set by adding e to the set.       *  @param e element to add */      public void add(E e);          /** Modifies this set by removing e, if found.       *  If e is not found in the set, has no effect.       *  @param e element to remove */      public void remove(E e);      **Why Interfaces?**  왜 인터페이스를 사용하는가?  컴파일러와 인간 모두를 위한 문서 : 인터페이스는 컴파일러가 버그를 static Checking 하는 것 뿐만 아니라 다른 사람이 코드를 읽기 쉽게 한다.  성능 절충 허용 : 지역 독립적인 코드 사용의 제공  선택적인 메소드 : mutable / immutable 를 선택적으로 제공  과소 결정된 메서드 : ADT는 요소 순서를 지정하지 않은채로 정렬, 비 정렬로 변환을 제공한다.  클래스의 다양한 시각 : 자바 클래스는 다양한 메서드로 구현 될 수 있습니다. 하나의 인터페이스로 구현된 클래스로 서로 다른 UI를 제공가능하다. (위젯과 위젯 목록 UI)  신뢰성이 떨어지는 구현 : 인터페이스는 버그를 포함할 수 있습니다. 그렇기에 계속해서 더 우수한 인터페이스를 구현해 버그가 발생하는 가능성을 낮출 수 있다.**Realizing ADT Concepts in Java**            ADT concept      Ways to do it in Java      Examples                  Abstract data type      Single class      http://docs.oracle.com/javase/8/docs/api/java/lang/String.html                     Interface + class(es)      http://docs.oracle.com/javase/8/docs/api/java/util/List.html and http://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html              Creator operation      Constructor      http://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#ArrayList–                     Static (factory) method      http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#singletonList-T-, http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T…-                     Constant      http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html#ZERO              Observer operation      Instance method      http://docs.oracle.com/javase/8/docs/api/java/util/List.html#get-int-                     Static method      http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#max-java.util.Collection-              Producer operation      Instance method      http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#trim–                     Static method      http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-java.util.List-              Mutator operation      Instance method      http://docs.oracle.com/javase/8/docs/api/java/util/List.html#add-E-                     Static method      http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#copy-java.util.List-java.util.List-              Representation      private fields             Summary  자바 인터페이스는 추상적인 데이터 타입을 연산을 지원하는 집합으로 공식화 하는데 도움을 준다."
  },
  
  {
    "title": "Exception",
    "url": "/learninghub/study/mit6.005-software%20construction/Exception/",
    "categories": "Study, MIT6.005-Software Construction",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Exceptions for signaling bugs  자바 프로그래밍에는 다양한 예외가 있다.          ArrayIndex-OutOfBoundsExceions 같은…      NullPointerException 또한 일반적인 예외이다.      NumberFormatException 은 Interger.parseInt 정수로 구문 분석할수 ...",
    "content": "Exceptions for signaling bugs  자바 프로그래밍에는 다양한 예외가 있다.          ArrayIndex-OutOfBoundsExceions 같은…      NullPointerException 또한 일반적인 예외이다.      NumberFormatException 은 Interger.parseInt 정수로 구문 분석할수 없는 문자열을 전달하는 경우의 예외도 있다.      Exceptions for special results  예외는 신호적인 버그뿐만 아니라 그들은 코드의 구조를 향상시킬수 있다. 특별한 결과함께 절차적인 것을 포함하여  자바의 Look up 은 양의 정수를 기대해거나 또는 객체에 대한 null 참조를 할때 -1의 인덱스를 얻을 수 있다.  어느정도는 이러한 방식을 사용해도 괜찮습니다. 하지만 두가지 문제점이 있다.          리턴값을 매번 확인해야한다.      이걸 잊어버리기 쉽다.            또한 특별한 값을 찾는것은 쉽지 않다. 아래 BirthdayBook 을 가정해보자.      class BirthdayBook {      LocalDate lookup(String name) { ... }  }        해당 메소드에 어떤 사람의 생일인지를 고려하지 않는 경우  우리는 이런 경우 특별한 결과를 리턴할 수 있다. (ex: 99.9.9) 같은 경우      예외를 사용하는 경우      LocalDate lookup(String name) throws NotFoundException {      ...      if ( ...not found... )          throw new NotFoundException();      ...      BirthdayBook birthdays = ...try {    LocalDate birthdate = birthdays.lookup(\"Alyssa\");    // we know Alyssa's birthday} catch (NotFoundException nfe) {    // her birthday was not in the birthday book}Checked and unChecked exceptions  위에서 우리는 특별한 결과와 버그를 위해 예외를 사용했다.  Checked exception은 다음과 같이 불린다.          RuntimeException 을 상속하지 않은 클래스      메소드에서 예외를 체크한다면 확인된 예외를 미리 선언을 해야한다. thowrs 를 활용      만약 다른 메소드가 호출한다면 마찬가지로 선언해야한다 그렇지 않으면 예외가 전파된다.        이런식으로 예외를 미리 선언하지 않으면 컴파일러가 거부한다.  ← 매우 유용  unChecked exception 같은 경우 버그를 알리는데 사용된다.          RuntimeException 을 상속하는 클래스        이 예외는 아마 가장 높은 수준을 제외하고는 밑에서는 다루지 못한다.  우리는 모든 메소드가 낮은 콜 레밸에서 선언되져야 할것을 원하지는 않는다. 다양한 버그의 예외가  결과적으로 unchecked exception은 컴파일러가 체크하지 못합니다. try - catch 나 a throws 같은 선언으로  자바는 여전히 허용합니다 당신이 a throws 를 사용하는 것을 unchecked exception의 부분으로써 그러나 추천하진 않는다,.Throwable hierarchy  어떻게 자바가 예외를 결정하는지를 이해하기 위해서는 계층 구조를 봐야한다.  Throwable 클래스는 thrown 하거나 caught할 수 있다.          어디서 예외를 던지는지에 대한 스택 포인터의 추적      예외의 optional string을 묘사한다.        어떤 객체가 throw 나 try-cathc 를 사용한다면 또는 선언한다면 이 클래스의 자식이 된다.  Error 클래스는 Throwable 의 자식으로써 자바 런타임 시스템에 의해 생성된 오류가 예약되어 있다.          stackoverflow 나 OutOfMemory 같은…      AssertionError 같은거 또한 Error의 확장이다, 이것이 런타임이 아닌 유저코드에서 나타나는 버그임에도 불구하고 에러는 회복 불가능한걸로 고려되며. 일반적으로 발견되지 않는다      간단하게 처리 할수 없는 에러!        확인된 예외와 확인되지 않은 예외를 구분하는 방법          RuntimeException , Error 이것들의 자식은 unchecked Exception이다. 컴파일러는 이것들에게 선언할것을 강요하지 않는다. 물론 호출자 또한      Throwable 과 Exception 의 모든 자식들은 checked Exception이다.  이런것들은 컴파일러가 throws 할것을 요구한다. (RuntimeException 의 자식이 아니라면)        예외를 정의할때, 서브클래스 중 하나를 선택해야한다. RunTimeException 또는 Exception 들 중에 Error 와 Throwable 는 자바 자체적으로 예약되어 있기에 하지 않아도 된다.Exception design considerations  특별한 결과에 대해선 checked exceptions을 버그에 대해서는 unchecked exception을 사용하는 규칙은 좋지만 자바의 예외는 끝이 아니다.  성능적인 패널티 외에도 예외에 대한 새로운 클래스를 만든느 것은 더 큰 비용을 요구한다. 만약 checked exception가 야기될수 있는 메소드일 경우 try-catch로 덮어야한다. 만약에 절대 던지지 않을 것이라고 알고 있는 경우 딜레마를 야기  예를 들어 큐 추상화를 디자인 할 경우          큐가 비어있을 때 pop의 경우 예외를 던져야 하는건 맞다.      만약 클라이언트가 예외가 아닌 대기열이 비지 않았을때만 pop하게 한다면 메소드를 사용하는 클라이언트 또한 try-catch를 던져야하는가?        이러한 규칙에 대해서 제시한다.          unchecked Exception은 버그를 알리는데에만 사용되여야 한다.      또한 편리하고 저렴하게 예외를 피할 방법이 있는 경우 에만 uncheckd exception을 작성한다.      그렇지 않으면 checked exception을 사용한다.        Example          큐에서 pop 할 경우 큐가 비어져있다면 EmptyQueueException 을 던질경우 caller 가 큐가 비었음을 먼저 테스트 해서 이를 피할수 있다.      Url.getWebPage() 같은 경우는 호출자가 예외를 피하기 쉽지 않기 때문에 checked IOException을 활용      int integerSquareRoot(int x) 깉은 경우 x가 완벽한 제곱근인지 찾는 것은 매우 어렵다 그렇기에 예외를 사용한다.      Abuse of exceptions      예외 남용의 예      try {      int i = 0;      while (true)          a[i++].f();  } catch (ArrayIndexOutOfBoundsException e) { }              이건 무한루프로써 예외를 통해 끝내는 경우          for (int i = 0; i &lt; a.length; i++) {      a[i].f();  }              이거와 완전하게 동일        자바의 Exception은 예외적인 상황에서 동작하게 만들었다 성능적인것은 기대하지 않는다.  또한 다른 버그가 숨어 있을 수 도 있다.  일반적인 루프를 사용시 예상되지 않은 엘 발생 할 경우 스택을 추적하여 종료한다.  하지만 예외기반 루프는 버그 기반 예외일 경우 일반적인 루프의 종료로 해석한다."
  },
  
  {
    "title": "Equality",
    "url": "/learninghub/study/mit6.005-software%20construction/Equality/",
    "categories": "Study, MIT6.005-Software Construction",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Introduction추상화 함수에서 equality 연산을 정의 하는 방법Three Ways to Regard Equality  equality를 바라보는 다양한 방법  추상화 함수 사용(Using an abstraction function)          추상화 함수 $F$ 를 정의해 $F(a) = F(b)$ 인 경우에만 equality를 확정 ...",
    "content": "Introduction추상화 함수에서 equality 연산을 정의 하는 방법Three Ways to Regard Equality  equality를 바라보는 다양한 방법  추상화 함수 사용(Using an abstraction function)          추상화 함수 $F$ 를 정의해 $F(a) = F(b)$ 인 경우에만 equality를 확정        관계를 이용(Using a relation)          equilvalence(동치) E ⊆ T X T 아래와 같다.                  reflexive(반사): E(t,t) ∀ t ∈ T          symmetric(대칭): E(t,u) ⇒ E(u,t)          transitive(추론): E(t,u) ∧ E(u,v) ⇒ E(t,v)                    E의 equality를 정의를 사용한다면 우리는 오직 E(a,b) 일때만 equals하다고 말 할수 있다.        위는 추상화 함수로 유도된 동등성 관계이다.  Using observation(관찰 이용)          호출해서 직접 관찰하기                                                                              {1,2}                  = 2 and                  {2,1}                  = 2                                                              1 ∈ {1,2} is true, and 1 ∈ {2,1} is true          2 ∈ {1,2} is true, and 2 ∈ {2,1} is true          3 ∈ {1,2} is false, and 3 ∈ {2,1} is false          … and so on                    Example: Durationpublic class Duration {    private final int mins;    private final int secs;    // rep invariant:    //    mins &gt;= 0, secs &gt;= 0    // abstraction function:    //    represents a span of time of mins minutes and secs seconds    /** Make a duration lasting for m minutes and s seconds. */    public Duration(int m, int s) {        mins = m; secs = s;    }    /** @return length of this duration in seconds */    public long getLength() {        return mins*60 + secs;    }}  equal 한가?Duration d1 = new Duration (1, 2);Duration d2 = new Duration (1, 3);Duration d3 = new Duration (0, 62);Duration d4 = new Duration (1, 2);**== vs. equals()**  Java가 가지고 있는 동등성 연산          == 참조를 비교 한다. (참조 평등을 테스트) , 메모리의 같은 저장소를 가르킨다면 동일하다.      equals() 개체의 내용의 동일성      **Equality of Immutable Types**  equals 의 정의public class Object {    ...    public boolean equals(Object that) {        return this == that;    }}  기본적으로 == 와 동일하다.  그런데 immutable 타입도 이렇게 할수 있을까…?  Duration 의 equlaspublic class Duration {    ...    // Problematic definition of equals()    public boolean equals(Duration that) {        return this.getLength() == that.getLength();    }}      해당 코드의 반례      Duration d1 = new Duration (1, 2);  Duration d2 = new Duration (1, 2);  Object o2 = d2;  d1.equals(d2) → true  d1.equals(o2) → false              오버로드의 발생으로 위의 메소드가 실현되버린다.            equlas 를 표현한다면?      public class Duration extends Object {      // explicit method that we declared:      public boolean equals (Duration that) {          return this.getLength() == that.getLength();      }      // implicit method inherited from Object:      public boolean equals (Object that) {          return this == that;      }  }              Static checking에서 자바 컴파일러는 매개변수에 따라 메소드 오버로딩을 실행      d1.equals(o2) 와 d1.equals(d2) 는 같은 객체를 가르키지만 평등성이 어긋나는 예            개선된 equals()      @Override  public boolean equals (Object thatObject) {      if (!(thatObject instanceof Duration)) return false;      Duration thatDuration = (Duration) thatObject;      return this.getLength() == thatDuration.getLength();  }              해결          Duration d1 = new Duration(1, 2);  Duration d2 = new Duration(1, 2);  Object o2 = d2;  d1.equals(d2) → true  d1.equals(o2) → true      Object Contract  Object 클래스의 명세는 중요하다.  equals 를 정의할때 Object 의 equals 를 오버로딩 하는 방식으로 진행된다.          equals 의 동치 관계를 정의해야한다. → 반사적, 대칭적, 전이적 관계의 정의      equals 가 일치해야한다. 메소드의 반복 호출에도 항상 같은 결과를 반환      x.equals(null) 는 언제나 false를 반환해야한다.      hasCode 는 equals 에 대해 언제나 같은 값을 생산하다.      **Breaking the Equivalence Relation**  equlas() 를 정의 한다면 동치 관계(반사, 대칭, 전이)부터 시작되어야한다.      그렇지 않은 경우 동일성은 불규칙적으로 예측 불가능하게 동작한다. → a와 b는 동등하다. 하지만 b는 a와 동등하지 않는다는 결과      private static final int CLOCK_SKEW = 5; // seconds      @Override  public boolean equals (Object thatObject) {      if (!(thatObject instanceof Duration)) return false;      Duration thatDuration = (Duration) thatObject;      return Math.abs(this.getLength() - thatDuration.getLength()) &lt;= CLOCK_SKEW;  }      Breaking Hash Tables  hashcode 가 어떻게 작동하는지 어느정도 이해해야한다.  HashSet , HashMap 은 HashCode 에 의존하여 hashtable 을 사용하여 데이터를 저장한다.  메소드는 객체를 저장하고 map 에서 key를 사용해 구현한다.  해쉬 테이블은 mapping으로 나타내는데 key로 값을 매핑한다.  다른 트리 보다 우수함  key는 equals 나 hashcode 를 제외하고 특정 속성을 가질 필요가 없다.  저장할 객체가 생기면 key의 hashcode를 계산하고 배열범위의 인덱스로 변환한뒤에 삽입  hashtable의 표현 불변성은 결정된 값에 키가 있다는 제약조건이 있다.  hash 코드는 키가 인덱스 전체에 퍼지도록 설정, 충돌 발생시 각자 처리  Object 는 동일한 개체가 동일한 hashcode를 가져야한다.      hashcode() 를 활용한 equals      private static final int CLOCK_SKEW = 5; // seconds      @Override  public boolean equals (Object thatObject) {      if (!(thatObject instanceof Duration)) return false;      Duration thatDuration = (Duration) thatObject;      return Math.abs(this.getLength() - thatDuration.getLength()) &lt;= CLOCK_SKEW;  }            불변 객체 같은 경우 다른 구현이 필요하다.      Duration d1 = new Duration(1, 2);  Duration d2 = new Duration(1, 2);  d1.equals(d2) → true  d1.hashCode() → 2392  d2.hashCode() → 4823              당연히 다른 객체니 hashcode 는 다르다.        이런 경우의 eqaul성은 어떻게 수정해야할까      가장 합리적인 방법 hashcode()를 @Override 한다. → 나의 equals 한 추상 함수로      @Override  public int hashCode() {      return (int) getLength();  }              성능이 안좋은 해쉬 함수라도 부정확한 함수보다는 낫다.        equals 를 override 할 때에는 항상 hashCode 를 override 할것Equality of Mutable Types  mutable 한 친구들의 equality는?  가변 객체의 equality는 두가지로 나뉜다.          상태가 바뀌지 않고 관찰자로 구분할 수 없을 때 observational equality(관찰 평등) 이라고 불린다.      상태가 바뀜(돌연변이)이며 관찰자로 구분 할수 없을때 bejavioral equality(행동 평등) 이라고 불린다.        immutable의 경우 일반적으로 관찰과 행동이 동일하다.      관찰 동일성은 편하지만 버그가 잠재될 가능성이 있다.      List&lt;String&gt; list = new ArrayList&lt;&gt;();  list.add(\"a\");      Set&lt;List&lt;String&gt;&gt; set = new HashSet&lt;List&lt;String&gt;&gt;();  set.add(list);              이러한 상황에서 아래와 같은 결과        set.contains(list) → true    list.add(\"goodbye\");    set.contains(list) → false! → 더이상 equal 하지 않음      for (List&lt;String&gt; l : set) {      set.contains(l) → false!  }              이런식으로 반복한다면 상황은 더욱 심해진다.      list에 객체가 추가됨으로써 내부주고자 변경된다.(내부요소의 해시코드 기반이기에) hashcode가 변경된다.            java.util.Set 의 명세          Note: Great care must be exercised if mutable objects are used as set elements. The behavior of a set is not specified if the value of an object is changed in a manner that affects equals comparisons while the object is an element in the set.        이러한 주의를 명시하고 immutable 한 객체를 사용하는것도 방법  이러한 상황에서는 행동 평등 의 구현의 필요성**The Final Rule for equals and hashCode()**  Immtable 타입의 경우          equals() 는 추상적인 값을 비교해야합니다. ( 행동 평등 구현 )      hashCode() 는 추상 값으로 매핑해야한다.        Mutable 타입의 경우          equals() 의 경우 참조를 비교해야한다. ( 행동 평등 구현 )      hashCode() 도 참조 값으로 매핑해야한다.      Autoboxing and Equality  Object 형과 원시형의 동등성은…?Integer x = new Integer(3);Integer y = new Integer(3);x.equals(y) → truex == y -&gt; false(int)x == (int)y // returns true      이런 버그를 조심하자      Map&lt;String, Integer&gt; a = new HashMap(), b = new HashMap();  a.put(\"c\", 130); // put ints into the map  b.put(\"c\", 130);  a.get(\"c\") == b.get(\"c\") → ?? // what do we get out of the map?              둘다 결과물이 Integer 라서 false가 나온다!      Summary  Equality 는 동치 관계(반사, 대칭, 추이) 여야한다.  Equality 는 hashCode와 일치해야한다. 그래야 제대로 작동 한다.  추상화 함수는 불변 데이터 형의 Equality 에 기초로 만들어진다.  참조 Equality 는가변 데이터 유형에서 일관성있게 보장하는 방식이다."
  },
  
  {
    "title": "Designing specifications",
    "url": "/learninghub/study/mit6.005-software%20construction/Designing-Specifications/",
    "categories": "Study, MIT6.005-Software Construction",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "이 장의 목표  underdetermined specs(결정되지 않은 스펙)을 이해하고 식별하고 평가할 수 있다.  선언과 옵셔널을 이해하고 선언 사양을 작성할 수 있다.  전제조건과 사후 조건의 스펙을 이해하고 스펙 강도와 비교할 수 있다.  적절한 스펙을 논리적으로 쓸 수 있습니다.Introduction  유사한 기능에 대한 스펙을 비교하고 그것들...",
    "content": "이 장의 목표  underdetermined specs(결정되지 않은 스펙)을 이해하고 식별하고 평가할 수 있다.  선언과 옵셔널을 이해하고 선언 사양을 작성할 수 있다.  전제조건과 사후 조건의 스펙을 이해하고 스펙 강도와 비교할 수 있다.  적절한 스펙을 논리적으로 쓸 수 있습니다.Introduction  유사한 기능에 대한 스펙을 비교하고 그것들에 상충 관계에 대해 이야기한다.          얼마나 결정적인가? : 스펙은 주어진 입력에 대한 가능한 출력만 정의하는가? 아니면 가능한 아웃풋의 집합 중에 하나를 선택하는가?      얼마나 선언적인가? : 스펙은 출력이 무엇인지를 말하는가? 아니면 출력이 어떻게 이뤄지는지를 말하는가?      얼마나 강한가? : 스펙은 작거나 큰 가능한 구현 집합이 있는가?      Deterministic vs. underdetermined specsstatic int findFirst(int[] arr, int val) {    for (int i = 0; i &lt; arr.length; i++) {        if (arr[i] == val) return i;    }    return arr.length;}static int findLast(int[] arr, int val) {    for (int i = arr.length - 1 ; i &gt;= 0; i--) {        if (arr[i] == val) return i;    }    return -1;}  first와 last는 임시적인 명칭      find 의 명세      static int findExactlyOne(int[] arr, int val)  requires: val occursexactly once in arr  effects:  returns index i such that arr[i] = val        이 명세는 결정론 적이다.  전제 조건이 만족되어질때 출력이 결정되어진다.  위 명세는 오직 하나의 return 값과 하나의 final static 값만 가능하다.  둘 이상의 유효한 출력에 대한 입력 값은 없다.      find 의 또 다른 명세      static int findOneOrMore,AnyIndex(int[] arr, int val)    requires: val occurs in arr    effects:  returns index i such that arr[i] = val        이 명세는 결정적이지 않는데 어떤 인덱스가 하나이상 반환 되어야 하는지는 적어져 있지 않다.  이것은 단순히 return 된 인덱스가 val임만을 의미한다.  이 명세는 하나의 입력에 대해 여러 출력을 허용한다.  비결정적 코드는 동일한 입력에 대해서도 다른 방향으로 동작할 수 있다.          임의의 숫자 및, 프로레스 순서 실행에 따라서…        그러나 명세가 비결정적이라도 구현까지 결정적이지 않을 필요는 없다.  결정적이지 않은 명세는 과소 결정적(underdetermined)이라고 표현한다.  underdetermined find 스펙은 결정적 비결정적 모두를 만족한다. 각각 underdetermined 방식으로 해결  위의 명세는 val 이 두번 이상 나타난다는 명세에 대해 어떤 인덱스가 반환되어야 하는지에 대해서는 의존하지 않는다.  위 명세는 또한 배열의 낮은 곳에서부터 탐색할지 높은곳에서 탐색할지에 대해 비결정적 명세 또한 만족한다.  결국 구현자가 이걸 선택한다.  미결정적 사양은 결정적 구현으로 마무리 짓는다.선언 vs 운영 명세  명세에는 두가지 종류가 있다.  Operational 명세는 메소드가 어떻게 작동하는지에 대한 일련의 과정을 서술          일반적으로 의사코드        Declarative 명세는 단계에 대한 내용이 아닌 최종 결과와 초기 상태에 대한 관계를 알린다.  대부분은 선언 명세가 좋다.          이해하기 쉬움      클라이언트가 의존할 수 이는 구현 세부 정보를 노출하지 않는다. → 변경 될 때 유지보수가 불가능하는 상황)      Ex) 배열에서 val을 발견 할때까지 아래로 내려가고 가장 낮은 인덱스가 반환된다는 것 이건 알릴 필요가 없음      이걸 활용해서 유지 관리자에게 설명하는건 옳지 않다. 그냥 메소드 본문을 설명하자            선언적 명세는 다양한 방법이 가능하다.      static boolean startsWith(String str, String prefix)  effects: returns true if and only if there exists String suffix              such that prefix + suffix == str              static boolean startsWith(String str, String prefix)  effects: returns true if and only if there exists integer i              such that str.substring(0, i) == prefix              static boolean startsWith(String str, String prefix)  effects: returns true if the first prefix.length() characters of str              are the characters of prefix, false otherwise      Stronger vs weaker specs  메소드를 변경하고자 할 때 해당 메소드가 의존하는 사양이 있다. 둘 다에게 안전성을 보장하고 싶은 경우 어떻게 비교할 것인가?  S2 가 S1보다 강하거나 같으면          S2의 전제조건이 S1의 전제조건보다 약하거나 같고      S2의 전제조건을 만족하는 상태에서 S2의 후조건은 S1의 후조건보다 강하거나 같을때        이러한 경우 S2를 만족하는 구현을 통해 S1 또한 만족 할수 있다.  더 나아가 S1는 S2로 대체가 가능하다.  이러한 두 가지 규칙은 몇개의 아이디어가 생긴다.      전제 조건을 약하게 해서 사용자를 만족시키고 메소드내의 약속을 통해 사후조건을 강하게 하는 방법이 있다.      static int findExactlyOne(int[] a, int val)  requires: val occursexactly once in a  effects:  returns index i such that a[i] = val          static int findOneOrMore,AnyIndex(int[] a, int val)  requires: val occursat least once in a  effects:  returns index i such that a[i] = val              전제 조건은 약해졌다.          static int findOneOrMore,FirstIndex(int[] a, int val)  requires: val occursat least once in a  effects:  returnslowest index i such that a[i] = val              하지만 후조건은 강해졌다!      Digramming Specifications  모든 자바 메소드를 하나의 그림으로 상상한다면…  모든 구현 가능한 공간의 영역을 정의하고 지정된 구현은 명세와 각 사전 사후 조건 관계에 따라 영역에 집어 넣는다.  구현의 경계선을 통해 메소드의 구현 범위 또한 알 수 있다.  Client는 이 다이어그램을 보고 명세 내부를 자유롭게 확인하고 변경이 가능하다.  또한 Client의 변경에도 유연성을 제공한다.  유사한 명세의 경우 어떻게 다른것과 관련을 지을 수 있는가?          우리는 S1로 시작하여 S2를 생성한다고 가정한다      전제 조건을 강화한다.                  s2 &gt; s1 이면 s2가 강한 사양으로 인지          사후 조건을 강화하는것은 구현자에게 어떤 의미인것인가? → 실행자의 자유는 적어지고 output의 요구 사항은 더 강해진다.          가장 낮은 index i 를 구현하도록 사후 조건을 강화한다면…          find OneOrMore,AnyIndex 를 내부 구현을 수정한다. → find OneOrMore,FirstIndex          find OneOrMore,AnyIndex 를 보이면서  find OneOrMore,FirstIndex   를 내부에 구현 할 수 있을까? 사후조건이 더강력한 find OneOrMore,FirstIndex 을 사용한다.                      다이어그램에서 강한 명세일수록 더 작은 영역을, 약한 명세이다면 더 큰 영역을 정의함을 볼 수 있다.  find Last 는 모든 다이어그램에서 만족하지만 그곳에서는 find OneOrMore,FirstIndex 는 만족하지 못할 것이다…Designing good Specifications  우수한 메소드란 무엇인가? 주로 명세를 작성한다는것  명세는 읽기 쉬어야하고 깔끔하게 잘 작성해야한다.  명세서의 내용을 규정하기는 어렵다 하지만 몇가지 지침이 있다.**The specification should be coherent**      명세에는 다양한 case를 사용하지 말아야한다 깊게 중첩된 분기문이 주로 예시      static int sumFind(int[] a, int[] b, int val)  effects: returns the sum of all indices in arrays a and b at which               val appears        이건 잘 설계 된 명세인가?          아마 그렇진 않을것이다.      관련 없는 두 작업 (두 array에서 찾고 합산)을 수행하기에 일관성이 떨어진다.      이런 경우 두개의 개별 절차를 적자            또 다른 예시      public static int LONG_WORD_LENGTH = 5;  public static String longestWord;      /**   * Update longestWord to be the longest element of words, and print   * the number of elements with length &gt; LONG_WORD_LENGTH to the console.   * @param words list to search for long words   */  public static void countLongWords(List&lt;String&gt; words)              전역 변수를 사용하는 것도 일관성이 없다.      이것 또한 두 가지 절차로 분리 한다면 조금 더 우수한 명세      **The results of a call should be informative**      또 다른 하나의 명세      static V put (Map&lt;K,V&gt; map, K key, V val)  requires: val may be null, and map may contain null values  effects:  inserts (key, val) into the mapping,                overriding any existing mapping for key, and                returns old value for key, unless none,                in which case it returns null        전제 조건이 null이 저장 될 수 있도록 적으세요  사후 조건에는 null 이 값을 찾지 못했다는 특별한 값으로 사용된다.  이것은 null이 리턴 될 때 실제로 바인딩이 된건지 알 수 없다.  삽입해서 null 인지 아니면 그냥 null인지 알 수 없는 이 디자인은 좋지 않다.**The specification should be strong enough**  사양은 일반적인 경우에서도 충분히 강력한 보증을 가져야한다.  특별한 케이스의 경우 메소드 사용에 있어 특별한 주의를 가져야한다.  예를 들어 허용되지 않은 값이나 인자에 대해 예외를 던지지 않을 경우  사용자가 실제로 어떤게 변화되었는지 결정하지 못할 때 애매한 값에 대해 exception을 던지는 것에 대해서는 별 의미가 없다.      여기 그 예시가 있다.      static void addAll(List&lt;T&gt; list1, List&lt;T&gt; list2)  effects: adds the elements of list2 to list1,               unless it encounters a null element,               at which point it throws a NullPointerException        만약 nullPointException 이 던져 졌을때, 고객들은 lis1인지 list2인지 애매해진다.**The specification should also be weak enough**      파일을 여는 방식에 따른 메소드      static File open(String filename)  effects: opens a file named filename        나쁜 명세의 대표적 예시  중요한 세부사항이 부족하다.  파일이 이미 열렸는지 아니면 생성되었는지 모른다.  파일을 열 방법이 없기 때문에 너무나 강력하다.  또한 다양한 문제가 있을 수 있다 (파일을 열 수 있는 권한이 없거나… 통제 파일 부재)  파일을 여는데 성공한다면 그에 대한 적절한 내용을 표시해야하는 등 더 약한 내용을 표시해야한다.**The specification should use abstract types where possible  앞선 Basic Java에서 추상적인 개념을 구별하는법을 공부 했다.  추상 타입에 대한 명세를 작성할 때 사용자와 구현자 모두 더 많은 자유를 가진다.      자바에서 종종 사용되는 List 나 Map 등은 다음과 같은 명세를 고려한다.      static ArrayList&lt;T&gt; reverse(ArrayList&lt;T&gt; list)  effects: returns a new list which is the reversal of list, i.e.               newList[i] == list[n-i-1]               for all 0 &lt;= i &lt; n, where n = list.size()        사용자는 어떤 List 를 사용할지 모르기에 List 로  추상화 하는것은 현명한 선택이다.**Precondition or postcondition?**  또 다른 설계의 문제는 Precondition 의 여부이다.  전제조건을 사용시 메소드 코드에서 이에 대한 확인 여부가 필요하다.  실제로 전제조건을 사용하는 이유는 메소드 내에서 이를 전제 조건 없이는 힘들기 때문에 이뤄진다.  하지만 전제 조건은 사용자에게 불편을 겪게 한다.  하지만 이렇게 하지 않는다면 오류를 복구 할수 있는 예측가능한 방법이 없다.  그래서 유저들은 전제 조건을 좋아하지 않는다.  자바 API는 적절하지 않은 인자가 확인 될 때 PostCondition 으로 예외를 던지도록 설정한다,.  이러한 방식은 호출자가 버그를 쉽게 찾을 수 있다.  Fall Fast 방식 달성 가능  또한 이러한 방법으로 이진 탐색 때 배열이 정렬되었는지(전제조건)을 미리 확인해 비용을 줄인다.  전제조건의 사용 유무는 공학적 판단 핵심 요소는 점검 비용과 방법의 범위를 색출 하는 것  로컬로만 호출 시 모든 경우를 다 체크하기 가능하다  하지만 모든 개발자가 사용하는 API의 경우는 자바 API처럼 해야한다.**About access control**  일반적으로 우리는 public 을 사용한다.  이러한 방식은 프로그램 어디서든지 접근하게 한다.  하지만 이러한 방식은 프로그램이 로컬로만 사용되지 않는다.  즉 코드가 변경될 준비가 되지 않았다.  이런 내부 도우미 메소드가 공개 된다면 인터페이스에 혼란이 가중된다.  private 를 활용하는 것은 모듈을 더 작고 일관성 있게 한다.  또한 이해하기 쉬워진다.  또한 버그로도 안전해진다.**About static vs. instance methods**  또한 논의 없이 static 을 사용하는것도 문제가 된다.  static 은 일반적으로 정적 객체에서 불러와진다.      일반적으로 지금까지 사용된 예      static int find(int[] arr, int val)  requires: val occurs in arr  effects:  returns index i such that arr[i] = val            int [] 을 사용하여 이걸 대신한다.      int find(int val)  requires: val occurs in this array  effects:  returns index i such thatthe value at index i in this array                is val      요약  명세는 구현자와 사용자 간의 중요한 방화벽의 역할을 한다.  소스코드를 전부 볼 필요 없이 이용 가능한 모듈을 개발이 가능하다.  구현자 또한 설계예 도움  선언적 명세가 가장 유용하다.  전제 조건은 이용자에게 부담을 주지만 결과적으로 가장 도움이 된다."
  },
  
  {
    "title": "Debugguing",
    "url": "/learninghub/study/mit6.005-software%20construction/Debugguing/",
    "categories": "Study, MIT6.005-Software Construction",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "  Objects          체계적인 디버깅      디버깅이 선택되어 질 때가 있다. (전체 시스템이 함께 연결되거나, 배포 후에 사용자 보고)      버그가 현지화가 불가능 할때에는 디버깅이 좋은 전략이 될 수도 있다.      Reproduce the Bug  고장을 야기하는 테스트케이스를 반복해서 시도한다.  regression tesi...",
    "content": "  Objects          체계적인 디버깅      디버깅이 선택되어 질 때가 있다. (전체 시스템이 함께 연결되거나, 배포 후에 사용자 보고)      버그가 현지화가 불가능 할때에는 디버깅이 좋은 전략이 될 수도 있다.      Reproduce the Bug  고장을 야기하는 테스트케이스를 반복해서 시도한다.  regression tesing을 통해 버그를 찾는데 성공 했다면, 운이 좋은편  사용자가 버그를 제보 했다면 이에 반해 약간의 노력이 필요하다.  하지만 이 환경이 그래픽 사용 인터페이스 또는 멀티 스레드 환경이라면 버그를 찾는 것은 더 어려워진다.  물론 작은 테스트 케이스를 만들어 반복적으로 실행하는 것은 도움이 된다.  반복해서 실행 하고 버그를 찾아 수정하고 이를 통해 regression test에 추가하는 것은 추후 이러한 버그를 지속해서 방지할 수 있기 때문이다.      다음과 같은 예시를 보자      /**   * Find the most common word in a string.   * @param text string containing zero or more words, where a word   *     is a string of alphanumeric characters bounded by nonalphanumerics.   * @return a word that occurs maximally often in text, ignoring alphabetic case.   */  public static String mostCommonWord(String text) {      ...  }        유저에게 세익스피어의 텍스트를 전달하는 메소드이다.  \"the\" 나\"a\" 를 반환 하는 대신에 \"e\" 를 반환 해버리는 문제가 발생한다면?  세익스피어는 100,000 줄과 800.000개의 단어가 있다.  일반적인 디버깅 방식으로는 매우 디버깅 난이도가 높음  만약에 버그가 작은 범위에서도 유의미하게 발생한다면..?          세익스피어의 전반부에서도 발생하는가?      연극 하나에도 같은 버그가 발생하는가?      하나의 문장에서도 같은 버그가 발생하는가?        작은 테스트 케이스를 찾았다면 이를 통해 수정한 후 전체에서도 같은 버그가 발생하는지 확인한다!**Understand the Location and Cause of the Bug**  버그를 지역화 하는데 사용할 수 있는 과학적 방법          Study the data : 버그를 야기시키는 테스트 케이스를 확인하고 잘못된 결과로부터 재추적      Hypothesize : 버그가 어디에서 발생할 수 있는지, 어디서 발생할 일은 없는지에 대한 데이터에 기반한 가설을 세운다.      Experiment : 가설을 검증하는 실험을 생각한다. 프로그램을 최소한으로 방해하지 않으면서 정보를 수집한 뒤 이를 관찰한다.      Repeat : 실험에서 데이터를 수집하고 이를 바탕으로 새로운 가설을 만든다. 반복을 통해 버그가 발생할 곳을 점차적으로 줄여 나간다.            이러한 방식을 바탕으로 다음과 같은 예시      /**   * Find the most common word in a string.   * @param text string containing zero or more words,   *     where a word is a string of alphanumeric   *     characters bounded by nonalphanumerics.   * @return a word that occurs maximally often in text,   *         ignoring alphabetic case.   */  public static String mostCommonWord(String text) {      ... words = splitIntoWords(text); ...      ... frequencies = countOccurrences(words); ...      ... winner = findMostCommon(frequencies); ...      ... return winner;  }      /** Split a string into words ... */  private static List&lt;String&gt; splitIntoWords(String text) {      ...  }      /** Count how many times each word appears ... */  private static Map&lt;String,Integer&gt; countOccurrences(List&lt;String&gt; words) {      ...  }      /** Find the word with the highest frequency count ... */  private static String findMostCommon(Map&lt;String,Integer&gt; frequencies) {      ...  }      Study the Data  Data의 중요한 것 중 하나는 exceoption으로 부터 발생한 Stack trace이다.  Stack trace하는 능력을 연습한다면 버그를 찾을 수 있는 엄청난 능력을 갖게 되는것  작은 테스트 케이스를 조정하는 사이에 특정 입력에 대한 버그의 발생 차이를 알게 될 수도 있다.          mostCommonWords(\"c c, b\") → 버그 발생      mostCommonWords(\"c c b\") → 버그가 발생하지 않음      **Hypothesize**  프로그램을 모듈로써 생각하고 알고리즘의 단계로 생각하는 것은 프로그램의 나머지 전체를 배제하는데 도움이 된다.      전체적인 데이터의 흐름          버그의 증상이 countOccurrences() 의 Exception인 경우 findMostFrequent() 가 배제 가능하다.      그렇다면 splitIntoWords() 에 버그가 있다고 가정하고 실험을 진행해볼 수도 있다.      만약 위의 가정이 true라면 countOccurrences() 또한 배제가 가능하다.      만약 false 라면 splitIntoWords() 를 배제 가능하다.      Experiment  좋은 experiment는 최대한 시스템을 방해하지 않고 진행한다.          Run a different test case : 윗 단계에서 진행 한것이 테스트 케이스를 감소시키는 과정      Insert a print statement or assertion : 프로그램 실행중에 내부 상태를 체크      Set a breakpoint : 중단점을 설정해 코드를 한 단계씩 체크(내부 변수 값, 개체 값)        증명 없이 가설에 기반한 수정을 사용하는 것은 매우 매력적이다  하지만 이러한 시도는 결과적으로 이해하기 어려운 코드를 생성하는 원인이 된다.  설사 버그가 수정되어 진 것처럼 보이더라도 이는 전체적인 수정이 아니라 버그가 단순히 숨었을 수도 있다.  ArrayOutOfBoundsException 의 버그 발생 시 실제 문제를 해결하지 않고 단순히 exception을 피할 수 있는 코드만을 추가하는 것과 비슷한 문제Other tips  Bug localization by binary search          버그를 찾는것 또한 결과적으로 search라고 볼 수 있다.      binary search를 사용한다면 이러한 속도를 높일 수 있다.      mostCommonWords 를 예로 든다면 workflow를 절반으로 나누고 버그가 발생 되는 부분을 다시 한번 반으로 나누는 식으로 속도를 증가 시킬 수 있다.        Prioritize your hypotheses          가설의 우선순위를 세우는 것은 중요하다      테스트가 오래 진행된 예전의 코드에 비해 새로 추가된 코드에서 버그가 발생 할 확률이 높다.      또한 자바 라이브러리는 일반적으로 사용자가 적는 코드 보다는 신뢰성이 높다      마찬가지로 자바의 컴파일러, 운영체제, 하드웨어 등도 버그의 가능성은 낮다.        Swap components          모듈을 만족하는 다른 구현이 있다면 swap 또한 좋은 시도가 될 수 있다.      예를 들어 binary search()에서 문제가 발생했다면 단순한 linear search()로 대체도 가능하다.      마찬가지로 java.util.ArrayList가 문제가 발생한 경우 java.util.LinkedList로 대체도 가능하다.      여전히 문제가 발생한다면 Java 버전을 변경해보고, OS 자체가 의심된다면 다른 OS 환경에서도 테스트 해볼 수 있다.      하지만 이러한 방식은 많은 시간을 요구하기에 충분한 이유가 있어야하다.        Make sure your source code and object code are up to date          git 등을 통해 최신 버전을 새로 받아오고 새로 컴파일한다      Clean  명령어도 비슷한 기능을 실행한다.        Get help          다른 사람에게 문제를 설명하고 도움을 요청해본다.        Sleep on it          자고 내일 다시 본다.      **Fix the Bug**  버그를 발견한다면 어떻게 해결해야할까  단순히 빨리 패치를 하지 않고 버그가 코딩 에러인지 잘못된 오타인지 생각해보자  디자인 에러, 불충분한 인터페이스 등등 다른 문제가 있을 수도 있다는걸 명심하자  또한 비슷한 버그가 있는지도 항상 명심하자  이러한 방법은 미래의 버그를 방지할 수 있는 기회를 제공한다.  마지막으로 회귀 테스트를 통해 해당 버그가 다음에 나타나지 않도록 주의한다.Summary  효율적인 디버깅을 위해서는          버그를 회귀테스트 케이스에 추가      과학적 방법 및 신중한 버그 수정      "
  },
  
  {
    "title": "Code review",
    "url": "/learninghub/study/mit6.005-software%20construction/Code-Review/",
    "categories": "Study, MIT6.005-Software Construction",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Code Review  본래 코드를 적은 사람이 아닌 다른 사람에게 코드를 보여주고 함께 하는것은 좋다.  코드 리뷰의 두가지 목적          Improving the code : 버그(예상되는)를 찾고 코드의 스타일을 서로 점검하면서 프로젝트의 기준의 일관성을 만든다.      Improving the programmer : 코드 리뷰는 프로그...",
    "content": "Code Review  본래 코드를 적은 사람이 아닌 다른 사람에게 코드를 보여주고 함께 하는것은 좋다.  코드 리뷰의 두가지 목적          Improving the code : 버그(예상되는)를 찾고 코드의 스타일을 서로 점검하면서 프로젝트의 기준의 일관성을 만든다.      Improving the programmer : 코드 리뷰는 프로그래머가 서로 배우고 학습하는데 좋은 방법, 또한 오픈소스 프로젝트에서 일어나는 다양한 사건에 대해 코드 리뷰는 좋은 대화 수단이 될 수 있다.        코드리뷰는 또한 산업현장에서 또한 동료 개발자들의 Code Review 없이는 push를 불가능하게 함Style Standards  대부분의 회사나 거대한 프로젝트에서는 코딩 스타일을 가진다 (ex: 들여쓰기의 간격, 대괄호와 중괄호의 위치…)      JAVA 또한 일반적인 코드스타일이 있다      if (condition) {statements;  }  if (condition) {  statements;  } else {  statements;  }  if (condition) {  statements;  } else if (condition) {  statements;  } else {  statements;  }        더 자세한 기준은 https://www.oracle.com/java/technologies/javase/codeconventions-statements.html#15395 (업데이트 안됨)    하나의 프로젝트에 소속되어 있다면 그 소속의 코드 스타일을 따르는것은 중요하다.Smeely Examplepublic static int dayOfYear(int month, int dayOfMonth, int year) {    if (month == 2) {        dayOfMonth += 31;    } else if (month == 3) {        dayOfMonth += 59;    } else if (month == 4) {        dayOfMonth += 90;    } else if (month == 5) {        dayOfMonth += 31 + 28 + 31 + 30;    } else if (month == 6) {        dayOfMonth += 31 + 28 + 31 + 30 + 31;    } else if (month == 7) {        dayOfMonth += 31 + 28 + 31 + 30 + 31 + 30;    } else if (month == 8) {        dayOfMonth += 31 + 28 + 31 + 30 + 31 + 30 + 31;    } else if (month == 9) {        dayOfMonth += 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31;    } else if (month == 10) {        dayOfMonth += 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30;    } else if (month == 11) {        dayOfMonth += 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31;    } else if (month == 12) {        dayOfMonth += 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 31;    }    return dayOfMonth;}Don’t Repeat Yourself  위 코드 처럼 복사/붙여넣기 하는 것을 매우 위험한 행위          원본에 버그가 있는 상태에서 복사본 생성시 원본만 수정 할 경우 복사본의 버그는 남아 있음        위 코드에서 “4월” 은 총 8번 중복됨  만약.. 2월이 28일이 아니라 30일이라면..? 총 10줄의 코드를 실행해야함  DRY 원칙을 준수하기 위해 조금 작은 단위로 코드를 나누는 습관을 가지고 그것을 호출에서 사용Comments Where Needed  좋은 프로그래머들은 코드와 Comments(주석)과 함께 한다.  Comments는 코드를 이해하기 쉽게 하고 버그로 부터 더욱 더 안전하게 그리고 변화에 더 유연하게  좋은 Comment를 나타내기 위한 방법 중 하나는 메소드 또는 상위의 클래스의 동작을 문서화 하는 것이다.  자바에서는 Javadoc를 활용      @param , @return 을 사용  아래 예시      /**   * Compute the hailstone sequence.   * See http://en.wikipedia.org/wiki/Collatz_conjecture#Statement_of_the_problem   * @param n starting number of sequence; requires n &gt; 0.   * @return the hailstone sequence starting at n and ending with 1.   * For example, hailstone(3)=[3,10,5,16,8,4,2,1].   */  public static List&lt;Integer&gt; hailstoneSequence(int n) {  ...  }        또다른 Comment의 용도는 출저 명시 및 코드를 어느 부분에서 복사하고 적용 했는지를 적는 것이다.  특정 라이센스는 제한적인 코드가 있기에 이러한 행동은 코드 저작권 문제를 방지한다.  또한 이런 문서화는 코드가 구식이 되는 것을 방지한다.          예를들어 언제 스택 오버플로우 같은 곳에서 코드를 가져온지 적어놓는 것은 이 코드가 언제 작성된지 또한 확인 할수 있다.        하지만 코드를 직접 영어로 번역 하는것은 읽는 이가 JAVA를 이미 알고 있다고 있기에 좋지 않다.          ++i //increment i  ← 어차피 자바는 모두가 안다.        Comments로 코드의 의도를 설명하는 것보다는 코드로 의도를 표현하자          if (a.flags &amp;&amp;.... b.age&gt; 65) 보다는 if (a.isEligible() 등을 통해 코드에서 설명      단 라이브러리 사용시에 의도를 표현하기 모호한 경우 사용        해야 할 일이 있다면 TODO를 사용하는것도 좋은 방법Fail Fast  버그를 찾는것을 빠를 수록 좋다 → Fail Fast  빠른 문제의 관찰되어짐으로 빠르게 수정 가능 이런 방식은 Staic Checking이 Dynamic Checking보다 우월하다. 물론 잘못된 결과를 생성하는 것보단 Dynamic Chekcing이 더 빠르다.          Fail-fast에 적절한 방식 ( Static Checking &gt; Dynamic Checking &gt; Wrong answer )        위의 DayOfYear 코드는 fail fast라곤 볼 수 없다. 인자를 잘못 준다면 Wrong Answer가 나온다.  빠른 Fail Fast를 위해 static Checking과 Dynamic Checking을 사용          Static Checking 사용 → 파라미터 형식 강제          public enum Month { JANUARY, FEBRUARY, MARCH, ..., DECEMBER };  public static int dayOfYear(Month month, int dayOfMonth, int year) {    ...  }              Dynamic Checking 사용 → 런타임 시에 예외 처리          public static int dayOfYear(int month, int dayOfMonth, int year) {    if (month &lt; 1 || month &gt; 12) {      throw new IllegalArgumentException(); //예외를 처리해서 프로그래머에게 알리는 것은 에러가 뒤로 숨는걸 막아준다.    }    ...  }         Iterator VS Enumeration          Enumeration : 기존의 Iterator와 비슷하다. new 연산자로 생성이 안되며 Vector이용      Iterator : java Collections 저장 요소를 읽어오는 표준화 방법      두 기능은 비슷하지만 결정적 차이가 존재 Enumeration는 fail-safe 방식을 채택하지만 Iterator는 fail- fast 방식      Fail-Safe : 부분적인 실패가 발생할시 바로 예외를 발생시키고 중단하는것이 아닌 계속 작동하고 안정적으로 종료되게 하는것      Enumeration은 순차적 접근 중 Collection 변경이 발생시 이를 무시하고 끝까지 동작      Iterator 같은 경우 Collecion 변경시 예외 발생      Avoid Magic Numbers  대부분의 컴퓨터는 0과 1밖에 인지하지 못한다.  다른 숫자 또한 대부분 설명이 필요하다 (Comments라던가..)      차라리 명확한 이름 또는 상수로 대체하는게 더 좋아보인다.      if (password.length() &gt; 7) {      throw new InvalidArgumentException(\"password\");  }          public static final int MAX_PASSWORD_SIZE = 7; // Constatnt로 의미 부여      if (password.length() &gt; MAX_PASSWORD_SIZE) {      throw new InvalidArgumentException(\"password\");  }        dayOfYear 의 Magic Number를 피하는 방법          months 같은 경우 FEBRUARY , …,DECEMBER 등으로 → 더 읽기 쉬움      days 같은 경우는 숫자는 유지한채 array나 list를 활용해서 MONTH_LENGTH[month] 를 사용      59나 90 같은 프로그래머가 손으로 계산한 코드이다. → 이런 손으로 계산한 상수의 사용x MONTH_LENGTH[JANUARY] + MONTH_LENGTH[FEBRUARY] 를 사용        Magic Numbers는 SFB(not safe form bugs), ETU(not easy to understand), RFC(not ready for change) 등을 유발          일반적인 상수를 사용했더라도 의미 부여를 하지 않으면 위의 3개가 유발          final int FIVE = 5;  final int THIRTY_SIX = 36;  final int SEVENTY_TWO = 72;  for (int i = 0; i &lt; FIVE; ++i) {    turtle.forward(THIRTY_SIX);    turtle.turn(SEVENTY_TWO);  }              적절한 name을 통한 의미 부여          final double FULL_CIRCLE_DEGREES = 360.0;  final int NUM_SIDES = 5;  final int SIDE_LENGTH = 36;  for (int i = 0; i &lt; NUM_SIDES; ++i) {    turtle.forward(SIDE_LENGTH);    turtle.turn(FULL_CIRCLE_DEGREES / NUM_SIDES);  }      One purpose For Each Variable  dayOfYear 는 다른 값을 사용하는데 재사용된다. (파라미터로 사용, 식의 계산, 리턴값)  매개변수와 변수를 재사용하는것을 지양, 적극적으로 변수를 새롭게 사용  특히 매개변수는 함부러 수정하지 않고 사용 ( final 키워드를 사용하는것도 좋음 )Use Good Names  변수나 메소드에 좋은 이름을 좋은 것은 가독성에 효과를 준다.  JAVA의 명명 규칙은 아래와 같다.          메소드의 이름은 CamelCase      변수도 CamelCase      상수는 모두 대문자      클래스는 앞문자가 대문자      메소드는 동사 구문, 변수와 클래스는 명사구      CamelCase  낙타의 두개의 등과 비슷하다고 해서 명명된 방식  lowercamelCase          phoneNumber      createdAt        UpperCamelCase (PascalCse)          PhoneNumber      CreateAt      Use Whitespace to Help the Reader  일관된 공백의 사용  Tab은 각각의 IDE 같은 환경마다 기준이 다르다. → 다른 환경에서 사용시 들여쓰기가 망가짐.  Space를 활용한 공백 문자의 사용을 지향Smelly Examlpe(2)public static int LONG_WORD_LENGTH = 5;public static String longestWord;public static void countLongWords(List&lt;String&gt; words) {   int n = 0;   longestWord = \"\";   for (String word: words) {       if (word.length() &gt; LONG_WORD_LENGTH) ++n;       if (word.length() &gt; longestWord.length()) longestWord = word;   }   System.out.println(n);}Dont’use Global Variables  전역 변수: 프로그램 어디서나 접근이 가능한 변수 → 사용 자제          병행성 문제      긴 생명 주기 → 리소스 소비량이 늘어남      암묵적 결합 → 각 모듈간의 응집도를 떨어트림        public , static 이 자바의 전역 변수  전역변수를 사용하기 보단 return values를 사용 또는 메소드를 호출하는 객체를 사용  변수를 상수( final )로 사용하는 것은 전역변수의 위험을 일부 피할 수 있다.  위의 code에서는 n 과 LONG_WORD_LENGTH , word 가 상수화 가능          변수가 재할당 되지 않음 → 즉 상수화 가능        반복문 내에서 재 할당이 이뤄지는 longestWord 등은 상수화 불가능Method Should Return Results, not Print Them  위 코드는 결과의 일부를 콘솔로 직접 전달한다. 즉 변화에 대해 약한 RFC이다.  만약 다른 문맥이나 숫자에 대해 계산할려고 하면 코드를 재작성 해야한다.  프로그램은 가장 높은 수준만 사람과 상호작용하는게 원칙적          단 디버깅 output은 예외      Summary  코드를 붙여 넣지 말것 (Don’t Repeat Yourself)  필요한 부분에 적절한 Comments  빠른 버그 찾기 (Fall fast)  Magic Number 피하기  변수에는 하나의 목적만 수행하기  이름 잘 짓기  전역변수 사용 지양  메소드는 결과만 반환, 출력은 사용안함  적절한 공백의 사용"
  },
  
  {
    "title": "Avoiding debugging",
    "url": "/learninghub/study/mit6.005-software%20construction/Avoiding-Debugging/",
    "categories": "Study, MIT6.005-Software Construction",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "First Defense: Make Bugs Impossible  버그에 대한 최고의 방법은 설계상 불가능하게 하는것.      이전에 이야기한 static checking → 컴파일 시간에 버그를 제거함    불변성 : 한번 생성된 값은 절대 바뀌지 못한다. → 버그를 예방하는 또 다른 원리  String은 불변이다.버그를 방지하기 위한 디자인중 하...",
    "content": "First Defense: Make Bugs Impossible  버그에 대한 최고의 방법은 설계상 불가능하게 하는것.      이전에 이야기한 static checking → 컴파일 시간에 버그를 제거함    불변성 : 한번 생성된 값은 절대 바뀌지 못한다. → 버그를 예방하는 또 다른 원리  String은 불변이다.버그를 방지하기 위한 디자인중 하나이다.  String을 호출 할때 해당 String이 변화 할것임을 걱정하지 않아도 된다.  자바는 또한 불별 참조를 제공한다. final 예약어를 통해서 절대 재할당 하지 못하게 막을 수 있다.  parameter에 final 을 선언하는 것은 상당히 유효하다.  변수의 유형처럼 선언은 중요한 문서입니다. 컴파일러가 static checking 할 수 있게 도와줄수 있기에.  final은 불변 객체이다. 하지만 다음과 같은 예시는?          final char[] vowels = new char[] { 'a', 'e', 'i', 'o', 'u' };      vowels = new char[] { 'x', 'y', 'z' };      vowels[0] = 'z';      final은 참조를 불별하게 만들 뿐이다.      즉 참조가 가리키는 개체를 보장하진 않는다.            또 다른 예시      char[] vowel4 = new char[] { vowel0, 'e', 'i', 'o', 'u' };  final char[] vowel5 = vowel4;      vowel4[0] = 'x';  vowel5[0] = 'z';      vowel4 = \"zeiou\"  vowel5 = \"zeiou\"              voewl4와 vowel5 는 같은 배열 객체를 가르키고 있기에 값이 같이 변경된다.      **Second Defense: Localize Bugs**  버그를 방지하지 못할 때, 프로그램의 작은 부분으로 지역화 시켜서 우리가 버그를 찾기 어렵지 않도록 설정해야한다.  메소드를 작게 하거나 모듈화 할 때 버그는 프로그램 텍스트를 학습 하는것으로 버그를 찾을 수 있다.  이건 fall fast 와도 비슷하다.      예시      /**   * @param x  requires x &gt;= 0   * @return approximation to square root of x   */  public double sqrt(double x) { ... }              만약 sqrt 를 호출 할때 x 인자를 -1을 주었다고 가정하자.      sqrt 는 모호한 값을 return 하거나, 무한 루프에 빠질 수 있다.      가장 유효한 방법은 버그를 빠르게 탐지해서 이를 지적하는것 이다.      우리는 Assertion 을 사용 할 수 있다.          /**   * @param x  requires x &gt;= 0   * @return approximation to square root of x   */  public double sqrt(double x) {      if (! (x &gt;= 0)) throw new AssertionError();      ...  }              Precondition이 충족 되지 않으면 코드는 Assertion 에러를 던진다.      이러한 효과는 호출자가 버그의 영향이 전파되는걸 방지한다.      이러한 precondition을 체크하는 것은 방어적 프로그래밍이라고 한다.      이런 방어적 프로그래밍은 버그의 영향을 안화할 수 있게 제공한다.      Assertions  일반적으로 프로시저의 다양한 방어 점검을 할때 사용하는 것은 assert 라고 한다.  assert (x &gt;= 0);  이러한 접근은 실패할 때 정확히 발생하는 방식이다.          주로 실패한 곳에서 로그 파일에 기록한다. → 유지보수자에게 이메일로알림        또한 Asserstions은 프로그램의 상태에 대한 가정을 문서화하는 이점을 갖는다.  assert (x &gt;= 0); 는 이 순간에 x는 항상 참이여야 한다는 걸 알인다.  주석과는 다른것이 이건 실제 코드에서 강제한다.  이건 Java 언어의 내장된 기능이다.  간단하게 boolean을 사용해서 AssertionError를 던진다.  주로 Assertion문은 식으로 묘사되며 대게 스트링으로 다뤄지지만, 원시 타입 및 객체에 대한 참조일 수도 있다.  Asserstion의 실패는  에러 메세지로 print 되며 이것은 프로그래머에게 실패를 야기 할수 있는 추가적인 정보를 제공하는데 사용될 수 있습니다.  이 expression은 콜론으로 분리됩니다. 예시는 아래와 같아요          assert (x &gt;= 0) : \"x is \" + x;        만약 x == -1 이라면 이렇게 나온다          x is -1        이와 함께 스택을 추적해서 프로그램 안의 코드나 sequence 호출 등 어디서 assert 에러를 찾았는지 위치를 말해줍니다.  이러한 정보는 버그를 찾기에는 충분한 정보  일반적으로 Assertion은 해제되어 있다. → 비용 문제  하지만… 일반적으로 Assertion을 통해 얻는 이득이 더 크다!  -ea 옵션을 VM 인수에 넣어 활성화 한다.      JUNIT 테스트시에 Assertion을 키고 실행하자 케이스의 예시      @Test(expected=AssertionError.class)  public void testAssertionsEnabled() {      assert false;  }        Assertions false 일 경우에 AssertionError를 thorws 한다.  자바의 assert 와 JUnuit의 assertTrue() 와 assertEquals()  는  서로 다르다.  그들은 모두 사용자의 코드에서 다른 문맥만을 비교한다.  assert 문은 구현된 코드 내에서 방어적 점검을 위해 사용된다.What to Assert      Assert 를 활용한 sqrt      public double sqrt(double x) {      assert x &gt;= 0;      double r;      ... // compute result r      assert Math.abs(r*r - x) &lt; .0001;      return r;  }              메소드 인자에 대한 요구 사항      메소드 리턴값에 대한 요구 사항 →자기 점검          switch (vowel) {    case 'a':    case 'e':    case 'i':    case 'o':    case 'u': return \"A\";    default: Assert.fail();  }              모든 사례를 테스트하기            런타임 assertions을 언제 작성해야할까?          코드를 다 쓰고 난 뒤가 아닌… 코드를 적으면서 적자 (잊어먹으니깐)      What Not to Assert  Runtime assertions은 무료가 아니다.  그것들은 코드를 어수선하게 만들 수 있기에, 남발해서는 안된다.      사소한 assertions은 생략한다.      // don't do this:  x = y + 1;  assert x == y+1;        이 assert는 버그를 찾을 수 없는 대표적인 예  모든것을 의심하지 말고 믿을건 믿는 방식이 필요  프로그램 외부의 조건( 사람의 입력, 네트워크 상태) 에는 assertion을 사용하지 않는다.  assertion은 프로그램 내부의 상태에서 보장한다. 명세의 내부에 있는지에 대해  assertion 실패할 경우 프로그램은 제대로 작동하지 않은 경우를 말한다.  그러므로 assertion의 실패 = 버그 존재 라고 볼수 있다.  외부의 장애는 Exceoption으로 처리한다.  많은 assertion의 메커니즘은 이걸 테스팅이나 디버깅동안 실행하기고, 유저에게 릴리즈 할때는 끄는게 원칙이다.  자바의 assert는 이러한 길을 자기오 있다.  이러한 접근법의 이득은 당신의 프로그램이 매우 비싼 assertion을 작성하게 도운다.  예를 들어 이진 탐색을 통해 탐색 하는 프로시저가 있을때, asserting은 전체 배열을 스캔할 수 있다. 그러나 이런 방식은 긴 시간이 걸린다.      테스팅 동안은 그런 비용을 지불할수 있다. 왜냐하면 디버깅을 쉽게 해주니깐! 그러나 릴리즈 후에는 이러한 테스트는 불가능하다.    그러나 release 할 동안 assertion을 비활성화 하는 것은 심각하게 손해이다. 그러나 assertion이 가져다 주는 이득은 강력하기에 전부 지우지는 않는다.  assertion이 비활성화될 프로그램내에서 의존이 존재 하면 안된다.  특히 side-effect가 없어야한다.          리스트 안에서 요소를 삭제하는 expression          // don't do this:  assert list.remove(x);              assertion이 비활성화 된다면, 전체 식이 실행되지 않는다. 그리고 x는 절대 식에서 제거 되지 않는다.      이렇게 바꿀것.          boolean found = list.remove(x);  assert found;  // good!      Incremental Development  지역화된 버그릐 최적의 길은 점진적으로 조금씩 부분으로 개발하는것이다.  작은 프로그램만 빌드하고, 철저한 테스트  이러한 방법은 버그를 찾을때 이전의 더미 보다 방금 짠 부분에서 버그가 있을 확률이 높다.  자세한 내용은 사전의 test에…          Unit Testing      Regression Testing      Modularity &amp; Encapsulation  좋은 소프트웨어 디자인을 위해 버그를 지역화 시킬 수 있다.  Modularity          모둘화는 시스템의 컴포넌트, 모둘 단위로 설계, 구현, 테스트 등으로 각각 별도로 기능하도록 나누는 것을 의미한다.      그리고 각 시스템을 반복적으로 재사용한다.      모듈 시스템의 반대는 모노톨릭(단일) 시스템이다.      서로가 뒤영켜 의존하는 상태      하나의 긴 main()이 있기에 이해하기 어렵고… 버그를 찾기가 힘들다.        Encapsulation          캡슐화는 모듈의 외각에 벽을 짓는것과 같다.      모듈의 내부 행동, 버그, 작은 문제가 다른 모듈에게 데미지가 가지 않도록 모듈의 외곽에 벽을 세우는것과 같다.      이런 캡슐화는 접근 컨트롤의 종류중 하나로 사용되는데 pulic 과 private 는 모듈(메소드, 변수)의 가시성과 접근성을 조종 가능하다.      public 변수와 메소드는 접근 가능한데 코드의 어떤 곳에서든지.      private 는 오직 같은 클래스 내에서만 접근 가능하다.      가능한한 private 를 유지하자… 특히 변수에 대해서 캡슐화를 제공하는 것은 부주의한 코드로부터 버그가 야기되는 것을 제한해줍니다.      캡슐화는 변수 범위에 대해서도 제공한다.      Scope은 전체 프로그램의 텍스트의 부분으로 정의됩니다. 식 또는 문에서 변수를 참조할 경우 메소드의 파라미터는 메소드의 body안으로 제한됩니다.      지역 변수의 범위는 다음 중괄호 닫힘까지입니다.      변수의 범위를 최대한 작게 유지하는 것은 프로그램에서 버그를 찾는것을 더 쉽게 해줍니다.              다음과 같은 예시가 있습니다.          for (i = 0; i &lt; 100; ++i) {      ...      doSomeThings();      ...  }                          i 는 무한번 반복된다.                  public static int i;  ...  for (i =0; i &lt; 100; ++i) {      ...      doSomeThings();      ...  }                          i 의 범위는 프로그램의 전체가 되었습니다. 어디서든지 참조 가능하고 루프는 100번 반복                  public static int i;  ...  for (i =0; i &lt; 100; ++i) {      ...      doSomeThings();      ...  }                          지역 변수를 활용해서 범위를 제한하였다.          i 는 문 내에서만 변경이 가능하다.                    최소화된 변수 범위의 활용 은 버그 지역화에 가장 강력합니다.              항상 루프의 변수를 초기화 하세요.          int i;  for (i = 0; i &lt; 100; ++i) {                          지역화도 추가하세요.                for (int i = 0; i &lt; 100; ++i) {            i 를 루프 안에서만 한정시켜야 합니다.                  자바의 변수는 중괄호 안에서 선언해서 지역 변수로 만든다.          하지만 함수를 시작할때 모든 변수를 선언하지 말아야한다 → 함수가 너무 커진다.          전역 변수는 언제나 피할것… 필요할때 마다 코드를 파라미터로써 전달하는 방식이 좋다.          전역변수는 언제나 재할당의 실수가 있음을 명시                    Summary  avoid debugging          static typing을 활용해 버그 자체를 방지하다 자동화된 dynamic checking, 불변 타입 또한 활용        keep bugs confined          fail fast를 assertion을 활용해서 도달한다.      버그가 퍼지는 것을 막는다      점진적 개발과 모듈화를 이용한다.      "
  },
  
  {
    "title": "Abstraction functions & rep invariants",
    "url": "/learninghub/study/mit6.005-software%20construction/Abstraction-Functions-&-Rep-Invariants/",
    "categories": "Study, MIT6.005-Software Construction",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Objectives  Invariants  representation exposure  abstraction functions      representation Invariants    추상화 함수 그리고 Invariants(상수)의 개념을 통해 class에 ADT를 구현하는것이 무엇을 의미하는지에 대해 공부한다.  이러한 수학적 개념은 소프트웨어 ...",
    "content": "Objectives  Invariants  representation exposure  abstraction functions      representation Invariants    추상화 함수 그리고 Invariants(상수)의 개념을 통해 class에 ADT를 구현하는것이 무엇을 의미하는지에 대해 공부한다.  이러한 수학적 개념은 소프트웨어 디자인에 있어 매우 실용적이다.  추상함수는 데이터 유형에 따른 equality를 정의하는 방법을 제공한다.  rep invariant는 데이터 구조로 인해 발생되는 버그를 더 쉽게 찾을 수 있게 제공한다.Invariants  좋은 ADT를 만드는것에 대한 논의에 대해서 가장 중요한 속성은 그 자체로 불변성을 보존하는 것이다.  불변성이란? → 프로그램의 런타임 상황에서 항상 True를 유지하는 상태  불변의 대상은 lifeTime 내내 같은 값을 유지해야한다.  ADT가 고유 불변량을 보존한다는 것은 그에 대한 책임이 있다는 말입니다.  ADT가 자신의 불변성을 보장할때 코드는 더 쉬워집니다. String 같은 불변 객체를 다룰 때에는 대게 String을 배제합니다.Immutability      첫번째 예시      /**   * This immutable data type represents a tweet from Twitter.   */  public class Tweet {          public String author;      public String text;      public Date timestamp;          /**       * Make a Tweet.       * @param author    Twitter user who wrote the tweet.       * @param text      text of the tweet       * @param timestamp date/time when the tweet was sent       */      public Tweet(String author, String text, Date timestamp) {          this.author = author;          this.text = text;          this.timestamp = timestamp;      }  }        어떻게 해당 Tweet 객체를 불변으로 할 수 있을까요?      immutabiliy에 대한 첫 번째 위협으로 뽑자면 누군가가 해당 객체를 수정하는데 있습니다.      Tweet t = new Tweet(\"justinbieber\",                      \"Thanks to all those beliebers out there inspiring me every day\",                      new Date());  t.author = \"rbmllr\";        이런 클래스 변수를 노출하는 것은 representaion exposure 의 한 예이다.  이런 representation exposure는 오직 invariants 뿐만 아니라 representation independence까지 위협한다.      접근 제어자를 사용한 예      public class Tweet {          private final String author;      private final String text;      private final Date timestamp;          public Tweet(String author, String text, Date timestamp) {          this.author = author;          this.text = text;          this.timestamp = timestamp;      }          /** @return Twitter user who wrote the tweet */      public String getAuthor() {          return author;      }          /** @return text of the tweet */      public String getText() {          return text;      }          /** @return date/time when the tweet was sent */      public Date getTimestamp() {          return timestamp;      }      }        public private 같은 접근 제어자는 외부에서 접근 할 수 있는 필드를 나타낸다.  앞전에 배웠던 final 도 마찬가지.      그러나 여전히 노출 된곳은 존재한다…      /** @return a tweet that retweets t, one hour later*/  public static Tweet retweetLater(Tweet t) {      Date d = t.getTimestamp();      d.setHours(d.getHours()+1);      return new Tweet(\"rbmllr\", t.getText(), d);  }        retweetLater 는 리트윗을 시도하는 코드입니다. ( 한시간 뒤에 )  d 는 mutable 객체라는 것을 명심하자. → d를 수정시 t까지 수정함  해당 코드는 객체 Tweet에 대한 불변성이 깨진 상태      이건 앞에서 배운 defensive copying으로 조절 가능      public Date getTimestamp() {      return new Date(Date.getTime());  }        clone()  은 가변객체를 복제하는 기능을 제공한다.      defensive copying으로도 여전히 문제되는 부분이 존재한다.      /** @return a list of 24 inspiring tweets, one per hour today */  public static List&lt;Tweet&gt; tweetEveryHourToday () {      List&lt;Tweet&gt; list = new ArrayList&lt;Tweet&gt;();      Date date = new Date();      for (int i=0; i &lt; 24; i++) {          date.setHours(i);          list.add(new Tweet(\"rbmllr\", \"keep it up! you can do it\", date));      }      return list;  }        이 코드는 24시간 마다 새로운 Date 객체를 만들어 매 시간마다 트윗한다.  하지만 이 코드는 모든 Tweet이 하나의 Date 객체를 참조한다…      defensive copying을 활용해서 이를 해결      public Tweet(String author, String text, Date timestamp) {      this.author = author;      this.text = text;      this.timestamp = new Date(timestamp.getTime());  }        일반적으로 모든 인자 타입과 리턴 타입을 주의 깊게 검사해야한다.  유형 중에 하나라도 mutable 한 경우 직접 그 참조를 반환하지 않도록 주의한다… 노출이 생기지 않게 주의하자      그렇다면 이렇게 코드로 하지 말고 상세한 명세로 회피 할순 없는걸까?      /**   * Make a Tweet.   * @param author    Twitter user who wrote the tweet.   * @param text      text of the tweet   * @param timestamp date/time when the tweet was sent. Caller must never   *                   mutate this Date object again!   */  public Tweet(String author, String text, Date timestamp) {        이러한 접근은 다른 대안이 없을때 주로 사용된다.  예를들어 가변 객체가 너무 클 경우가 있다.  하지만 이러한 방식은 프로그램을 추론하는데 들어가는 비용이 너무 큼을 명시하자.  불변성을 보장하는 것은 항상 가치가 높다는 것을 명심하자.  물론 처음부터 불변 유형을 고르는게 가장 합리적이다.**Immutable Wrappers Around Mutable Data Types**  자바 collections는 immutable wrappers라는 걸 제공한다.  Collections.unmodifiableList() 를 사용하면 일반적인 List로 보이지만 불변 개체로 wrapping한다.  하지만 여전히 runTime의 불변성은 보장되지만 Compile 시간에는 불변성이 보장 되지 못한다.Rep Invariant and Abstraction Function  추상 데이터에 대한 기초가 되는 이론을 더 자세히 공부  밑의 이론은 그 자체로 추상 유형의 설계와 구현에 도움을 준다.  추상 유형을 생각할 때 두 개체의 관계를 고려하는건 도움이 된다.  rep values(표현 값 공간)은 실제 개체의 값으로 구성된다.  rep values 값의 공간은 설계된 값으로 구성된다. → 추상 값 공간 (플라토닉 엔티티)  그들은 정신적 객체로써 실존하진 않는다. 그러나 추상적인 타입으로써 클라이언트가 보기 원하는 방식이다.  예를 들어 일반적인 경계가 없는 정수의 경우는 수학정 정수 전체가 추상 값의 공간(AF)이다.  하지만 경계가 있는 정수 배열은 이러한 정수의 경계는 중요하지 않다.      물론 추상 유형의 생성자는 실제 경계를 생각을 해야한다.      public class CharSet {      private String s;      ...  }              표현공간 R(문자열) 그리고 추상공간 A(수학적 문자 집합)이다.      R &gt;- A 라고 볼 수 있다.      몇가지 주의할 점                  모든 추상값은 어떤 참조 값에 의해 mapped된다.          일분 추상 값은 둘 이상의 참조 값에 의해 mapped된다. {”abc”, “bac”} → {a, b, c}          모든 참조 값이 mapped된건 아니다. {”aabbcc” → x } → 중복을 허용하지 않는다면…                      우리는 몇개의 요소와 관게를 설명한다.                  참조 값을 추상값에 매핑하는 추상화 함수                  $AF : R → A$                      이 관계가 일대일 대응이라고는 볼수 없지만… 종종 부분적이라고는 말할 수 있다.                                      참조 값을 booleans에 매핑하는 rep invariant                  $RI : R → boolean$                      참조 값 r 같은 경우 r이 AF에 의해서 매핑될 때만 RI(r)가 참이다.            즉 주어진 참조 값이 잘 형성되었는지 여부를 알인다.                                    rep invariant와 추상화 함수는 코드 옆에 문서화 되어야함을 기억하자      public class CharSet {      private String s;      // Rep invariant:      //    s contains no repeated characters      // Abstraction Function:      //   represents the set of characters found in s      ...  }        추상 함수와 rep invariants의 일반적인 혼란은 그들이 참조와 추상 값의 공간에 대해서 결정된다는 것이다.  추상 값의 공간 만으로는 AF와 RI를 결정할 순 없다.  동일한 추상 타입에 대해 여러 표현 기능이 가능할 수 있다. 예를 들어 문자 집합은 문자열 또는 bit vector와 동일하게 표현될 수도 있다.  두 공간의 AF와 RI를 결정하지 않은 이유는 덜 명확할 수 있다.  표현 값 공간에 대한 유형을 정의하고 그것을 선택한다고 해서 그중 어떤 표현 값이 유요하다고 판단 될것이고 유효한 값중에는 어떻게 해석할지가 결정되지 않는다는 것이다.      위 처럼 문자열에 중복이 없다고 결정하는 대신 중복을 허용하지만 비 내림차순으로 나타난다고 요구하는것도 가능하다.      public class CharSet {      private String s;      // Rep invariant:      //    s[0] &lt;= s[1] &lt;= ... &lt;= s[s.length()-1]      // Abstraction Function:      //   represents the set of characters found in s      ...  }        각각의 가능성 있는 문자들은 서로 다른 추상함수로 매핑 될수 도 있다.  동일한 rep value를 가지더라도 다른 AF를 가진다.  RI 가 모든 문자열을 가진다고 가정한다면 위에서처럼 AF를 정의해 배열 요소의 집합 요소로 해석 가능하다.  $AF(s)={[s1−s1],[s2−s2],…,[sn−sn]}$  연속된 문자 쌍을 부분범위로 해석해 “acgg” sms {a-c}, {g-g}로 해석이 가능한 형태로 {a,b,c,g} 로 나타낼수 있다.  $RI(s)=true for any string s$      RI 가 같더라도 다양한 추상화함수가 아래와 같이 정의 가능하다.      public class CharSet {      private String s;      // Rep invariant:      //    s.length is even      //    s[0] &lt;= s[1] &lt;= ... &lt;= s[s.length()-1]      // Abstraction Function:      //   represents the union of the ranges      //   {s[i]...s[i+1]} for each adjacent pair of characters      //   in s      ...  }        추상 타입을 설계한다는 것은 두 공간(추상 값 공간, 대표 값 공간)을 선택하는것 뿐만 아니라, 어떤 rep values를 결정하고 그거를 해석할지를 결정 한다는 것이다.Example: Rational Numberspublic class RatNum {    private final int numer;    private final int denom;    // Rep invariant:    //   denom &gt; 0    //   numer/denom is in reduced form    // Abstraction Function:    //   represents the rational number numer / denom    /** Make a new Ratnum == n. */    public RatNum(int n) {        numer = n;        denom = 1;        checkRep();    }    /**     * Make a new RatNum == (n / d).     * @param n numerator     * @param d denominator     * @throws ArithmeticException if d == 0     */    public RatNum(int n, int d) throws ArithmeticException {        // reduce ratio to lowest terms        int g = gcd(n, d);        n = n / g;        d = d / g;        // make denominator positive        if (d &lt; 0) {            numer = -n;            denom = -d;        } else {            numer = n;            denom = d;        }        checkRep();    }}  RI 는 numerator/denominator가 감소된 상태, (2,4), (18,12) 같은 쌍은 RI 외부에 그린다.  더 많은 허용적인 RI로 동일한 ADT를 구현하는 것이 훨씬 합리적이다.Checking the Rep Invariant  RI 는 단순하게 깔끔한 수학적 아이디어라곤 볼 수 없다.  RI 불변성을 초기에 주장하는 경우 버그를 조기에 발견 할 수도 있다.      RatNum의 RI를 테스트 하는 방법      // Check that the rep invariant is true  // *** Warning: this does nothing unless you turn on assertion checking  // by passing -enableassertions to Java  private void checkRep() {      assert denom &gt; 0;      assert gcd(numer, denom) == 1;  }        전체적으로 checkRep() 을 호출하여 모든 생성과 변형 작업에서 RI 불변성을 주장해야한다.  위 코드는 각각의 constructors의 끝에 checkRep()을 호출하고 있다.  Obersver methods는 일반적으로 checkRep() 을 호출할 필요는 없지만 이렇게 하는 방식은 좀더 defensive 한 방식.  왜?  모든 방향에서 checkRep() 을 호출하는것은 당신이 RI를 조금더 잘 잡을수 있다는 것.  왜 checkRep이 private인가? → RI를 체크하고 RI를 확인할 책임은 누가져야하는가? clients? 구현자?No Null Values in the Rep  이전 파트에서 읽었듯이 null values는 여러가지 문제를 일으킨다.  null은 우리 공부에서 언제나 가장 제거해야하는 항목이다.  추상 데이터 타입에 또한  null 참조를 금지하는 것이 좋다.class CharSet {    String s;}  s 는 당연히 null이 아님  하지만 checkRep() 을 구현 할때 여전히 s != null 이라는걸 체크가 필요함  s 가 null 이라면 바로 실패      자바에서 기본으로 제공해주는 s를 null 인지 알려주는 예시      private void checkRep() {      assert s.length() % 2 == 0;      ...  }              assert가 있는데 이렇게 굳이 할 필요는 없지..        assert s != null 매우 명시적이다.**Documenting the AF, RI, and Safety from Rep Exposure**  class 안의 RI 와 AF를 문서화하은 좋은편  또다른 논쟁은 Rep Exposure argument safety. 이는 rep의 각 부분을 조사하고 코드에에서 rep를 다루는 부분에서(특히 파라미터와 return값)을 살펴보고 rep가 노출하지 않은 이유를 서술      Tweet 은 Invariant, abstraction function 안정성이 완전히 문서화된 예      // Immutable type representing a tweet.  public class Tweet {          private final String author;      private final String text;      private final Date timestamp;          // Rep invariant:      //   author is a Twitter username (a nonempty string of letters, digits, underscores)      //   text.length &lt;= 140      // Abstraction Function:      //   represents a tweet posted by author, with content text, at time timestamp      // Safety from rep exposure:      //   All fields are private;      //   author and text are Strings, so are guaranteed immutable;      //   timestamp is a mutable Date, so Tweet() constructor and getTimestamp()      //        make defensive copies to avoid sharing the rep's Date object with clients.          // Operations (specs and method bodies omitted to save space)      public Tweet(String author, String text, Date timestamp) { ... }      public String getAuthor() { ... }      public String getText() { ... }      public Date getTimestamp() { ... }  }        우리는 어떠한 명시적인 불변 조건도 timestamp 에 가지고 있지 않는다 timestamp != null 그러나 여전히 timestamp 의 전체 유형의 불변성 속성은 변경되지 않은 immutability  왜냐하면 전체 내부 argument에서 이것을 변경할 것이 없다.      RatNum 의 argument      // Immutable type representing a rational number.  public class RatNum {      private final int numer;      private final int denom;          // Rep invariant:      //   denom &gt; 0      //   numer/denom is in reduced form, i.e. gcd(|numer|,denom) = 1      // Abstraction Function:      //   represents the rational number numer / denom      // Safety from rep exposure:      //   All fields are private, and all types in the rep are immutable.          // Operations (specs and method bodies omitted to save space)      public RatNum(int n) { ... }      public RatNum(int n, int d) throws ArithmeticException { ... }      ...  }      How to Establish InvariantsInvariant는 프로그램 전체에서 항상 참인 특성임. 객체의 invariant는 객체 수명 동안 유지되어야 함.Invariant를 유지하려면 다음을 해야 함:객체 초기 상태에서 invariant를 참으로 설정해야 함.객체가 변경될 때마다 invariant를 참으로 유지해야 함.ADT 연산자로 보면 의미는 이렇다:creators랑 producers는 새로운 객체 인스턴스에 대해 invariant를 설정해야 함.mutators랑 observers는 invariant를 계속 유지해야 함.rep exposure는 항상 문제를 더 복잡하게 만듦.만약 rep이 노출되면 ADT 연산뿐 아니라 프로그램 어디서든 객체가 수정될 수 있음.이렇게 되면 invariant를 보장할 수 없게 됨.  Structural Induction 추상 데이터 타입의 invariant가 다음과 같은 경우          creators와 producers에 의해 설립됨      mutators와 observers에 보존됨      rep exposure가 노출되지 않음      **ADT invariants replace preconditions**  지금까지 공부한것을 합쳐 잘 설계된 추상 타입은 규정해야할 전제 조건을 캡슐화 할 수 있다는 것      예를 들어 spec이 다음과 같을때 정교한 precondition      /**   * @param set1 is a sorted set of characters with no repeats   * @param set2 is likewise   * @return characters that appear in one set but not the other,   *  in sorted order with no repeats   */  static String exclusiveOr(String set1, String set2);            이를 대체하는 ADT를 사용할 수 있다. (precondition을 대신함)      /** @return characters that appear in one set but not the other */  static SortedSet&lt;Character&gt; exclusiveOr(SortedSet&lt;Character&gt;  set1, SortedSet&lt;Character&gt; set2);        ADT의 이름 같은 경우 이 프로그램을 사용하는 모든 프로그래머가 사용하기에 이해가 더 쉽다.  또한 Static Checking이 가능하다.Summary  invariant는 개체의 수명동안 ADt 개체가 항상 참인 것이다.  좋은 ADT는 그 자체에 대한 불변성을 보존한다.  → 버그로부터 안전해짐  Rep exposure는 RI와 invariant preservation을 모두 보존한다.  AF는 구체적인 값을 추상적인 값에 매핑해주는 함수이다.  ADT를 활용해 이해하기 쉽고 변화할 준비가 된 코드를 작성 가능하다."
  },
  
  {
    "title": "Abstract data types(23.10.04)",
    "url": "/learninghub/study/mit6.005-software%20construction/Abstract-Data-Types(23.10.04)/",
    "categories": "Study, MIT6.005-Software Construction",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Objects  추상 자료형  표현 독립성  추상 데이터 유형의 위험한 문제를 해결하고, 클라이언트가 내부 표현에 대한 가정이 왜 위험하고, 어떻게 그것을 피할 수 있는가?  연산의 분류와 추상적인 데이터 유형에 대한 좋은 설계 원리를 세우는법What Abstraction Means  추상화 데이터 유형은 소프트웨어 공학의 일반적인 원리 중 하나  다...",
    "content": "Objects  추상 자료형  표현 독립성  추상 데이터 유형의 위험한 문제를 해결하고, 클라이언트가 내부 표현에 대한 가정이 왜 위험하고, 어떻게 그것을 피할 수 있는가?  연산의 분류와 추상적인 데이터 유형에 대한 좋은 설계 원리를 세우는법What Abstraction Means  추상화 데이터 유형은 소프트웨어 공학의 일반적인 원리 중 하나  다양한 의미로 이야기 되어진다.          추상화 : 낮은 정보를 숨기고 더 단순하게 표현      모듈화 : 시스템을 모듈로 나누고, 각 구성 요소에 설계, 구현 등의 기능을 추가      캡슐화 : 모듈 주위에 벽을 만들어 모듈 내부가 각자 스스로에게 책임을 부여, 다른 부분의 무결성 보장      정보 숨김 : 모듈의 세부 정보를 숨겨 추후 시스템 변경시 다른 모듈을 변경할 필요가 없음      관심사 분리 : 기능을 만들때는 하나의 모듈에만 책임을 남긴다.        소프트웨어 공학에서는 이러한 용어를 잘 아는 것이 중요하다.User-Defined Types  컴퓨팅 시대의 초기에는 내장된 타입과 프로시저들로 input과 output를 조절하였다.  이러한 하나의 프로시저를 정의하기 위해 거대한 프로그램의 제작에 들어갔다.  사용자 정의 유형을 허용하는 것은 상당히 진보적인 아이디어  Dahi(Simula 언어 개발자), Hoare(현재 사용죽인 추상화 타입의 발명), Parnas(캡슐화와 정보 숨기기 등의 정의) 등등이 제안  MIT에서 추상타입의 명세에 대해 개발  데이터 추상화의 핵심 아이디어는 어떤 동작에 따라 유형이 특정화 된다는 것  숫자는 더하고 곱하고, 문자열은 연결 가능하는것 불리언은 참 거짓을 구별하는 등…  다른 의미로 프로그래머는 초기 프로그래밍언어로 자신의 유형을 정의가 가능하다.  예를 들어 년/월/일을 나타내는 날짜형  하지만 계산을 못함 → 이게 추상화의 핵심  사용자가 저장되는 방식에 벗어나 자유롭게 저장하고 계산하는 것.  자바에서는 내장형 타입과 사용자 정의형이 구분된다.  Integer 나 boolean 은 java.lang 에 존재 하지만 java.util 을 기본으로 제공하는 건지와는 덜 명확하다.  이는 자바가 여전히 객체가 아닌 원시형의 데이터를 가지고 있음으로써 나타나는 문제          int 와 boolean 은 사용자가 확장이 불가능하다…      Classifiying Types and Operations  내장형이던 사용자 정의 형이던 확실하게 분류할 수 있는건 mutable 인가 immutable 로 분류 된다.  mutable한 객체는 변경 될 수 있다. 즉 실행될 때 다른 작업을 할 경우 다른 결과를 기대할 수 있다.  Date 는 mutable 하다. 그렇기에 setMonth 로 변경을 가지고 getMonth 로 이것을 관찰 할 수 있다.  String 은 immutable 하다. 하지만 StringBuiler 는 mutable 하다.  추상 유형의 연산은 다음과 같이 분류된다.          Creators : 새 객체를 만든다. 객체의 인자로 활용 될 순 있지만, 구성되어진 객체는 사용할 수 없다.      Producers : 오래된 객체로 새 객체를 만든다. String 의 concat() 매소드가 대표적                  concat() : 두 문자열을 연결하여 새로운 String 객체 생성                    Observers : 추상 객체의 정보를 다른 객체에 return 해준다 size 메소드가 대표적      Mutators : 객체를 바꾼다. add 가 대표적        이러한 연산을 요약한다면          creator: t* → T      producer: T+, t* → T      observer: T+, t* → t                                                  mutator: T+, t* → void              t              T                                            다양한 class 들의 연산 signatures를 보여준다  T 는 추상적 유형 그 자체로 각각 다른 타입이다. + 는 한번이상 발생을, * 는 0 번 이상 발생을 말한다.  creator operation은 생성사로 구현되는 경우가 많다. new ArrayList() 처럼.  그러나 creator는 단순히 static method가 될 수는 없는데 Arrays.asList() 가 대표적이다.  이런 creator는 종종 Factory method 라고도 불린다. String.valueOf 가 대표적인 factory method 중 하나.  Mutators는 종종 void return type에 불린다. 아무것도 반환하지 않은 것을 여러가지 부작용을 동반 할수 잇다. boolean 을 활용해 정상적으로 변경되었는지 알리는 부울을 반환라면 돌연변이를 줄일 수있다.Abstract Data Type Examples  추상 데이터 유형과 몇가지 작업의 유형  int 는 원시형 타입이고 immutable 하다.          creators: the numeric literals 0, 1, 2, …      producers: arithmetic operators +, -, ×, ÷      observers: comparison operators ==, !=, &lt;, &gt;      mutators: none (it’s immutable)        List 는 mutable 하다.          creators: ArrayList and LinkedList constructors, [Collections.singletonList](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#singletonList-T-)      producers: [Collections.unmodifiableList](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-T-)      observers: size, get      mutators: add, remove, addAll, [Collections.sort](http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#sort-java.util.List-)        String 은 immutable          creators: String constructors      producers: concat, substring, toUpperCase      observers: length, charAt      mutators: none (it’s immutable)      Designing an Abstract Type  추상적 유형을 설계하는데에는 좋은 작업을 선택하고 어떻게 동작을 가져야하는지에 대한 결정이 필요하다.  복잡한 작업 하나보다는 쉬운 작업 몇개가 좋다는것을 명심하자  각각의 작동은 잘 정의된 목적을 가져야 하며 일관된 행동을 가져야한다 ( 애매해서는 안된다. )  만약에 멋대로 List 에 sum 을 추가한다면 단순히 Integers, String, nested 등등 모든 케이스에 대해서 강력하게 적용시켜야한다.  각 연산 집합은 다양한 상황에서 충분히 적합해야한다.  좋은 테스트는 모든 객체에 대해서 확인하는 것이다.  예를들어 get 연산자가 없다면 우리는 리스트의 요소를 알아낼수 없다.  기본적인 정보를 얻어내기에 어렵지 않아야함을 명시하자.  또다른 예로 size 연산자는 indices가 실패할때까지 증가 하는 식으로 알아낼수 있지만 이건 매우 비 효율적이다.  타입은 집합일 수도 그래프 일수도 있다.  하지만 일반적인 기능과 도메인별 기능을 혼동해서는 안된다.**Representation Independence**  좋은 추상 데이터 타입은 표현 독립적이여야한다.  추상 타입이 실제 사용자의 표현(실제 데이터 구조) 등과 독립적이므로 표현의 변화가 외부 코드에 영향을 미치지 않게 한다는것을 의미  예를 들어 List가 연결된 list인지 배열인지는 중요하지 않다.  ADT의 표현은 전제 조건과 사후 조건을 완전히 지정하지 않은 한 변경해서는 안된다.  고객은 이러한 조건을 확실하게 알고 의존관계를 파악한 후에 변경여부를 파악한다.**Example: Different Representations for Strings**  **Representation Independence**가 정확히 무엇을 의미하는지 예시  실제 String 을 표현한 MyString 코드/** MyString represents an immutable sequence of characters. */public class MyString {    //////////////////// Example of a creator operation ///////////////    /** @param b a boolean value     *  @return string representation of b, either \"true\" or \"false\" */    public static MyString valueOf(boolean b) { ... }    //////////////////// Examples of observer operations ///////////////    /** @return number of characters in this string */    public int length() { ... }    /** @param i character position (requires 0 &lt;= i &lt; string length)     *  @return character at position i */    public char charAt(int i) { ... }    //////////////////// Example of a producer operation ///////////////    /** Get the substring between start (inclusive) and end (exclusive).     *  @param start starting index     *  @param end ending index.  Requires 0 &lt;= start &lt;= end &lt;= string length.     *  @return string consisting of charAt(start)...charAt(end-1) */    public MyString substring(int start, int end) { ... }}  이러한 연산자와 명세는 오직 사용자가 알수 있는 유일한 정보  이러한 자료형에 대해 테스트를 시도한다.  하지만 assertEquals 는 시도할 수 없다?          왜? equailty를 정의하지 않았기에 → equailty를 어떻게 신중하게 구현할지도 추후 공부        현재로썬 구현되어 있는 5가지 메소드에 대해서만 테스트 한다.      valueOf 테스트      MyString s = MyString.valueOf(true);  assertEquals(4, s.length());  assertEquals('t', s.charAt(0));  assertEquals('r', s.charAt(1));  assertEquals('u', s.charAt(2));  assertEquals('e', s.charAt(3));              이것에 대한 테스트는 마지막에..        MyString 에 대한 표현에 있어 char 배열은 정확히 string의 길이이다. 끝에 추가적인 공간은 있으면 안된다.  내부 표현은 다음과 같이 선언되어 있다.          private char[] a;            이러한 표현을 선택한다면 연산자의 구현은 다음과 같을 것이다.      public static MyString valueOf(boolean b) {      MyString s = new MyString();      s.a = b ? new char[] { 't', 'r', 'u', 'e' }              : new char[] { 'f', 'a', 'l', 's', 'e' };      return s;  }      public int length() {      return a.length;  }      public char charAt(int i) {      return a[i];  }      public MyString substring(int start, int end) {      MyString that = new MyString();      that.a = new char[end - start];      System.arraycopy(this.a, start, that.a, 0, end - start);      return that;  }        이러한 구현의 문제점은 성능 개선의 기회가 없다는 것이다.  데이터 타입이 immutable이기에 굳이 subString 에서 새로운 문자열로 복사할 필요가 없다.  기존에 존재하는 문자열의 시작과 끝을 추적하는 방식으로 성능 개선의 여지가 있다.      최적화를 구현하기 위해 내부 표현을 변경      private char[] a;  private int start;  private int end;            새로운 연산자 구현          public static MyString valueOf(boolean b) {          MyString s = new MyString();          s.a = b ? new char[] { 't', 'r', 'u', 'e' }                  : new char[] { 'f', 'a', 'l', 's', 'e' };          s.start = 0;          s.end = s.a.length;          return s;      }          public int length() {          return end - start;      }          public char charAt(int i) {        return a[start + i];      }          public MyString substring(int start, int end) {          MyString that = new MyString();          that.a = this.a;          that.start = this.start + start;          that.end = this.start + end;          return that;      }        이러한 구현의 변경은 MyString 이 개인의 영역이 아닌 오직 공개된 명세에만 의존하기에 바로 변경이 가능하다. 이것이 표현 독립성의 힘**Realizing ADT Concepts in Java**  우리는 ADT 아이디어를 통해 Java 언어 기능을 사용하여 공부해보았다  자바 언어에 존재하는 ADT 개념들은 다음과 같다            ADT concept      Ways to do it in Java      Examples                  Creator operation      Constructor      http://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#ArrayList–                     Static (factory) method      http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#singletonList-T-, http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T…-                     Constant      http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html#ZERO              Observer operation      Instance method      http://docs.oracle.com/javase/8/docs/api/java/util/List.html#get-int-                     Static method      http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#max-java.util.Collection-              Producer operation      Instance method      http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#trim–                     Static method      http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-java.util.List-              Mutator operation      Instance method      http://docs.oracle.com/javase/8/docs/api/java/util/List.html#add-E-                     Static method      http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#copy-java.util.List-java.util.List-              Representation      private fields             Summary  추상 데이터 타입은 그들의 연산에 따라 특정되어진다.  좋은 ADT는 일괄적이며 적절하고, 간단하며 표현 독립적이다.  ADT의 명세는 연산자의 집합과 그들의 스펙이다.  연산자는 creators, producers, observers 그리고 mutators로 분리된다.  좋은 ADT는 명확한 명세를 제공하기에 잠재적 버그를 줄이고 간단한 연산 뒤에 구현을 숨겨 이해하기 쉽게 하며 표현독립성으로 변화에 준비 되었다.**Testing an Abstract Data Type**  ADT에 대한 테스트 케이스는 서로와 상호작용한다.  creators, producers, mutators 같은 경우는 실제 값을 관찰하여 테스트 하는게 가장 효율적이다.      input Test를 분할한 경우      // testing strategy for each operation of MyString:  //  // valueOf():  //    true, false  // length():  //    string len = 0, 1, n  //    string = produced by valueOf(), produced by substring()  // charAt():  //    string len = 1, n  //    i = 0, middle, len-1  //    string = produced by valueOf(), produced by substring()  // substring():  //    string len = 0, 1, n  //    start = 0, middle, len  //    end = 0, middle, len  //    end-start = 0, n  //    string = produced by valueOf(), produced by substring()            이를 바탕으로 test suite는 다음과 같다.      @Test public void testValueOfTrue() {      MyString s = MyString.valueOf(true);      assertEquals(4, s.length());      assertEquals('t', s.charAt(0));      assertEquals('r', s.charAt(1));      assertEquals('u', s.charAt(2));      assertEquals('e', s.charAt(3));  }      @Test public void testValueOfFalse() {      MyString s = MyString.valueOf(false);      assertEquals(5, s.length());      assertEquals('f', s.charAt(0));      assertEquals('a', s.charAt(1));      assertEquals('l', s.charAt(2));      assertEquals('s', s.charAt(3));      assertEquals('e', s.charAt(4));  }      @Test public void testEndSubstring() {      MyString s = MyString.valueOf(true).substring(2, 4);      assertEquals(2, s.length());      assertEquals('u', s.charAt(0));      assertEquals('e', s.charAt(1));  }      @Test public void testMiddleSubstring() {      MyString s = MyString.valueOf(false).substring(1, 2);      assertEquals(1, s.length());      assertEquals('a', s.charAt(0));  }      @Test public void testSubstringIsWholeString() {      MyString s = MyString.valueOf(false).substring(0, 5);      assertEquals(5, s.length());      assertEquals('f', s.charAt(0));      assertEquals('a', s.charAt(1));      assertEquals('l', s.charAt(2));      assertEquals('s', s.charAt(3));      assertEquals('e', s.charAt(4));  }      @Test public void testSubstringOfEmptySubstring() {      MyString s = MyString.valueOf(false).substring(1, 1).substring(0, 0);      assertEquals(0, s.length());  }        각 테스트는 일반적으로 객체를 만들고 수정한다.  그리고 각 작업과 유형을 감시하는 작업 또한 호출한다."
  },
  
  {
    "title": "9. mvc",
    "url": "/learninghub/nhn%20academy/servlet-jsp/9.-MVC/",
    "categories": "NHN Academy, Servlet-JSP",
    "tags": "Web, NHN Acedemy, Servlet",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "MVC (23. 11. 27)  Model: 비즈니스 로직 및 데이터 처리 담당  View: 모델이 처리한 결과 데이터의 화면 생성 담당  Controller: 요청 처리 및 흐름 제어 담당장점  변화 유연  유지 보수 우수기존 Servlet (비즈니스와 뷰가 함께 있음)resp.setContentType(\"text/html\");resp.setChar...",
    "content": "MVC (23. 11. 27)  Model: 비즈니스 로직 및 데이터 처리 담당  View: 모델이 처리한 결과 데이터의 화면 생성 담당  Controller: 요청 처리 및 흐름 제어 담당장점  변화 유연  유지 보수 우수기존 Servlet (비즈니스와 뷰가 함께 있음)resp.setContentType(\"text/html\");resp.setCharacterEncoding(\"UTF-8\");resp.setCharacterEncoding(\"UTF-8\");// ...try {    RequestDispatcher rd = req.getRequestDispatcher(\"...\");    rd.forward(req, resp);    // resp.sendRedirect(\"...\");} catch (ServletException | IOException ex) {    log.error(\"\", ex);}Front Controller Pattern      공통 처리 부분을 나눠보자 !        View 를 담당하는 부분을 추출해서 처리  front controller 가 어떤 서블릿에서 어떤 요청을 처리할지 결정한다!@Slf4j@WebServlet(name = \"frontServlet\", urlPatterns = \"*.do\")public class FrontServlet extends HttpServlet {    private static final String REDIRECT_PREFIX = \"redirect:\";    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp)        throws ServletException, IOException {        // 공통 처리 - 응답 content-type, character encoding 지정.        resp.setContentType(\"text/html\");        resp.setCharacterEncoding(\"UTF-8\");        try {            // 실제 요청 처리할 Servlet 결정.            String processingServletPath = resolveServlet(req.getServletPath());            // 실제 요청을 처리할 Servlet으로 요청을 전달하여 처리 결과를 include시킴.            RequestDispatcher rd = req.getRequestDispatcher(processingServletPath);            rd.include(req, resp);            // 실제 요청을 처리한 Servlet이 `view`라는 request 속성 값으로 view를 전달해 줌.            String view = (String) req.getAttribute(\"view\");            if (view.startsWith(REDIRECT_PREFIX)) {                // `redirect:`로 시작하면 redirect 처리.                resp.sendRedirect(view.substring(REDIRECT_PREFIX.length()));            } else {                // redirect 아니면 JSP에게 view 처리를 위임하여 그 결과를 include시킴.                rd = req.getRequestDispatcher(view);                rd.include(req, resp);            }        } catch (Exception ex) {            // 에러가 발생한 경우는 error page로 지정된 `/error.jsp`에게 view 처리를 위임.            log.error(\"\", ex);            req.setAttribute(\"exception\", ex);            RequestDispatcher rd = req.getRequestDispatcher(\"/error.jsp\");            rd.forward(req, resp);        }    }    // ...}MVC 실습  https://github.com/UNGGU0704/nhnacademy-study/tree/main/servlet-jsp/%5BMVC%5D%20학생%20관리%20시스템"
  },
  
  {
    "title": "8. jsp",
    "url": "/learninghub/nhn%20academy/servlet-jsp/8.-JSP/",
    "categories": "NHN Academy, Servlet-JSP",
    "tags": "Web, NHN Acedemy, Servlet",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "JSP (23. 11. 26)  JSP란?          자바 스크립트와는 다르다.      Java Server Pages의 약자      HTML에 JAVA 코드를 넣어 동적 웹 페이지를 생성하는 웹 어플리케이션 도구      JSP 실행시 JAVA Servlet으로 변환되어 웹이 동작한다!        Servlet 의 확장형          ...",
    "content": "JSP (23. 11. 26)  JSP란?          자바 스크립트와는 다르다.      Java Server Pages의 약자      HTML에 JAVA 코드를 넣어 동적 웹 페이지를 생성하는 웹 어플리케이션 도구      JSP 실행시 JAVA Servlet으로 변환되어 웹이 동작한다!        Servlet 의 확장형          서블릿의 모든 기능에 대해 추가적인 기능을 가진다!            html과 동작 원리 차이            JSP 와 Servlet의 차이            전체적인 JSP 동작 구조              Client가 서버에 Hello.jsp를 요청한다.      JSP 컨테이너가 JSP 파일을 읽는다.      JSP 컨테이너가 Generate 작업을 통해 Serlvet 파일을 생성한다.      .java는 컴파일 되어 .class 파일이 된다.      HTML을 Client에 제공한다.      즉 jsp → Servlet + a 로 변경된다.기본 문법&lt;%@ %&gt;  page: JSP 페이지에 대한 정보&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;  include: JSP 파일 안에 다른 JSP나 HTML 파일을 포함&lt;%@ include file=\"/some/path/content.html\" %&gt;  tablib: 태그 라이브러리 선언&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;%= %&gt;  변수, 메서드 호출 등 표현식(expression)의 실행 결과를 출력&lt;%= \"Hello, World!\" %&gt;&lt;%= 17 * 5 %&gt;&lt;%= request.getParameter('name') %&gt;  전역변수          outside the _jspService() method      &lt;%! %&gt;  변수나 메서드 등을 선언&lt;%! String name = \"James\" %&gt;&lt;%!    public int minus(int i, int j) {        return i - j;    }%&gt;  지역변수          inside the _jspService() method.      &lt;% %&gt;  &lt;% 와 %&gt; 사이에 있는 코드를 실행`&lt;%    int a = 3;    int b = 2;    if (a &gt; b) {        out.println(minus(a, b));    }%&gt;`if-else&lt;% if (x &lt; 0) { %&gt;    &lt;p&gt;negative&lt;/p&gt;&lt;% } else { %&gt;    &lt;p&gt;zero or positive&lt;/p&gt;&lt;% } %&gt;for, while, do/while&lt;table&gt;&lt;tr&gt;&lt;% for (i = 0; i &lt; 10; i++) { %&gt;    &lt;td&gt;&lt;%= i + 1 %&gt;&lt;/td&gt;&lt;% } %&gt;&lt;/tr&gt;&lt;/table&gt;JSP 내장 객체            객체      타입      설명                  page      javax.servlet.jsp.HttpJspPage      page의 Servlet 인스턴스              config      javax.servlet.ServletConfig      ServletConfig              request      HttpServletRequest      요청 객체              response      HttpServletResponse      응답 객체              out      javax.servlet.jsp.JspWriter      page 컨텐트 출력용 스트림              session      javax.servlet.http.HttpSession      세션              application      javax.servlet.ServletContext      ServletContext              pageContext      javax.servlet.jsp.PageContext      JSP page의 실행 context              exception      java.lang.Throwable      처리되지 않은 에러나 예외      forward vs include  /pageContext.jsp?type=include          include는 해당 URL로 제어권을 넘기지만 include처리가 끝나면 다시 제어권은 원래의 페이지로 돌아옴 ( 즉 해당 페이지에 삽입하는것과 같음 )            /pageContext.jsp?type=forward          forward는 요청과 응답에 대한 제어권을 URL로 지정된 주소로 영구적으로 넘김. -&gt; 종료          Java Beans  Java로 작성된 재사용 가능한 소프트웨어 컴포넌트  자바빈 규격이라는 엄격한 지침에 따라 어디서나 재사용성이 높음  java로 작성된 소프트웨어 컴포넌트  Java Beans 지켜야할 관례          클래스는 직렬화 되어야 합니다.      클래스는 기본 생성자를 가지고 있어야 합니다.      클래스의 속성들은 get, set 혹은 표준 명명법을 따르는 메서드들을 사용해 접근할 수 있어야 합니다.      클래스는 필요한 이벤트 처리 메소드들을 포함하고 있어야 합니다.      POJO  특정 기술과 환경에 종속한 Java는 재사용성이 매우 떨어진다.  객체 지향의 장점을 잃어버리는 현상  컨벤션, 프레임워크를 따르지 않은 Java 오브젝트를 의미          특정 규약, 환경에 종속되지 않는다.      객체 지향적 원리에 충실        POJO 프레임 워크          Spring 프레임 워크가 대표적인 POJO이다.      Java beans의 간단한 예제public class User implements Serializable {    private String userName;    private int userAge;    private boolean coding;    public User(){}    public String getUserName() {        return userName;    }    public void setUserName(String userName) {        this.userName = userName;    }    public int getUserAge() {        return userAge;    }    public void setUserAge(int userAge) {        this.userAge = userAge;    }    public boolean isCoding() {        return coding;    }POJO VS Java Beans            POJO      JavaBeans                  Java language에 의해 강제되는 것 외에는 특별한 제한이 없습니다.      몇 가지 제한 사항이 있는 특수 POJO 객체입니다.              Field에 대한 통제를 제공하지 않습니다.      Field에 대한 통제를 제공합니다.              직렬화 가능한 인터페이스를 구현할 수 있습니다.      반드시 직렬화 가능한 인터페이스를 구현해야 합니다.              필드는 이름으로 접근할 수 있습니다.      필드는 getter, setter에서만 접근할 수 있습니다.              인수가 없는 default생성자가 있을 수도 있고 없을 수도 있습니다.      반드시 인수가 없는 default생성자가 존재해야 합니다.      Servlet &amp; JSP 실습  https://github.com/UNGGU0704/nhnacademy-study/tree/main/servlet-jsp/%5Bservlet-jsp%5D%20학생관리%20시스템%20실습"
  },
  
  {
    "title": "7. requestdispatcher, servlet filter",
    "url": "/learninghub/nhn%20academy/servlet-jsp/7.-RequestDispatcher,-Servlet-Filter/",
    "categories": "NHN Academy, Servlet-JSP",
    "tags": "Web, NHN Acedemy, Servlet",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "RequestDispatcher, Servlet Filter (23. 11. 04)RequestDispatcher  RequestDispatcher는 다른 페이지나 서블릿으로 현재 요청을 보내거나 다른 페이지나 서블릿의 출력을 현재 페이지에 포함시키는 데 사용  클라이언트로부터 들어온 요청을 Servlet내에서 원하는 자원으로 요청을 보내는 역할 수행...",
    "content": "RequestDispatcher, Servlet Filter (23. 11. 04)RequestDispatcher  RequestDispatcher는 다른 페이지나 서블릿으로 현재 요청을 보내거나 다른 페이지나 서블릿의 출력을 현재 페이지에 포함시키는 데 사용  클라이언트로부터 들어온 요청을 Servlet내에서 원하는 자원으로 요청을 보내는 역할 수행  a에서 들어온 요청을 RequestDispathcer를 사용해 b로 전송  웹 애플리케이션에서 유연한 처리가 가능해지며, 코드의 재사용성 증가sendRedirect()와의 차이점      기존의 sendRedirect는 클라이언트에 redirect()한 뒤 응답을 받는 형태            상태 또한 지속적으로 유지될 수 없음 (쿠키나 세션을 통해 공유는 가능)  자원의 낭비RequestDispathcer 사용방법      Servlet name으로 생성      RequestDispatcher rd = getServletContext().getNamedDispatcher(\"loginServlet\");            URL로 설정      RequestDispatcher rd = getServletContext().getRequestDispatcher(\"/login\");      forward() 메서드  대상 자원으로 제어를 넘긴다.  a 에서 요청했을때 a 는 forward() 를 실행 하여 b 로 제어를 넘기고 브라우저에 출력은 b 가 한다.  브라우저 입장에서는 a 에게 요청했지만 결과는 b 에게 받는다.  redircet 와는 달리 하나의 HTTP 요청에 의해 동작이 이루어졌다.login 실패시 sendRedirect를 forwad로 변경resp.sendRedirect(\"/login.html\");아래와 같이 변경한다.RequestDispatcher dispatcher = req.getRequestDispatcher(\"/login.html\");            dispatcher.forward(req, resp);Servlet Filter  지정한 URL 패턴에 해당하는 요청에 대해          서블릿 실행 전 후에      해당 요청이나 응답에 공통적으로 적용할 작업을 수행하는 객체        필터 체인 형태로 제공  서블릿에 전달하기 전 뿐만 아니라 후에도 필터 적용이 가능하다.Interfacepublic interface Filter {    default public void init(FilterConfig filterConfig) throws ServletException {}    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) /* .. */;    default public void destroy() {}}책임 연쇄 패턴  객체 지향 디자인에서 chain-of-responsibility pattern은 명령 객체와 일련의 처리 객체를 포함하는 디자인 패턴이다.  각각의 처리 객체는 명령 객체를 처리할 수 있는 연산의 집합이고, 체인 안의 처리 객체가 핸들할 수 없는 명령은 다음 처리 객체로 넘겨진다.  이 작동방식은 새로운 처리 객체부터 체인의 끝까지 다시 반복된다.Listener  Servlet Container가 수행한 특정한 타입의 동작(이벤트)을 감지하여  해당 이벤트에 대해 별도의 작업을 수행하는 객체Listener 종류            Event Source      Event      Event Listener                         ServletContext      ServletContextEvent      ServletContextListener      웹 애플리케이션 시작, 종료              ServletContext      ServletContextAttributeEvent      ServletContextAttributeListener      ServletContext 속성 변경              HttpSession      HttpSessionEvent      HttpSessionListener      세션 시작, 종료              HttpSession      HttpSessionBindingEvent      HttpSessionAttributeListener      세션 속성 변경              ServletRequest      ServletRequestEvent      ServletRequestListener      ServletRequest 생성, 종료              ServletRequest      ServletRequestAttributeEvent      ServletRequestAttributeListener      ServletRequest 속성 변경      "
  },
  
  {
    "title": "5. web.xml",
    "url": "/learninghub/nhn%20academy/servlet-jsp/5.-web.xml/",
    "categories": "NHN Academy, Servlet-JSP",
    "tags": "Web, NHN Acedemy, Servlet",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "web.xml(23. 11. 23)배치 기술서 (Deployment Descriptor: DD)  웹 애플리케이션의 배치 정보를 담고 있는 XML 파일  /WEB-INF/ 디렉터리 하위에 위치      &lt;web-app&gt; 이라는 하나의 태그 하위로 설정을 기술      web.xml은 Java 웹 애플리케이션에서 사용되는 배치 서술자(desc...",
    "content": "web.xml(23. 11. 23)배치 기술서 (Deployment Descriptor: DD)  웹 애플리케이션의 배치 정보를 담고 있는 XML 파일  /WEB-INF/ 디렉터리 하위에 위치      &lt;web-app&gt; 이라는 하나의 태그 하위로 설정을 기술      web.xml은 Java 웹 애플리케이션에서 사용되는 배치 서술자(descriptor) 파일 중 하나입니다.  이 파일은 웹 애플리케이션의 구성과 설정 정보를 정의하는 데 사용됩니다.       - 웹 애플리케이션의 구성 요소: 서블릿, 필터, 리스너 등과 같은 구성 요소를 정의할 수 있습니다.   - 서블릿 매핑: 웹 애플리케이션에서 URL과 서블릿 클래스 사이의 매핑을 정의할 수 있습니다.   - 필터 설정: HTTP 요청 및 응답을 변경하거나 필터링하는 데 사용되는 필터를 정의할 수 있습니다.   - 보안 설정: 웹 애플리케이션에 대한 보안 설정을 정의할 수 있습니다.   - 초기화 매개변수: 웹 애플리케이션에 대한 초기화 매개변수를 정의할 수 있습니다.      Web.xml 파일 내  하위 태그들Servlet: Servlet 등록 정보  servlet-name: Servlet 이름  servlet-class: Servlet class의 FQCN  init-param: Servlet의 초기 파라미터  param-name  param-value  load-on-startup: 웹 애플리케이션 구동 시 로딩 여부servlet-mapping : Servlet과 URL 맵핑 정보  servlet-name  url-pattern: 와일드카드 * 사용 가능, *. 는 확장자로 매칭  /foo/bar/*  .jspcontext-param : ServletContext의 초기 파라미터  param-name  param-valuewelcome-file-list : welcome file 리스트  welcome-file : index.html 같은 파일… -&gt; 기본페이지error-page  둘 중 하나 선택  error-code : 404, 500 같은 http status code  exception-type: Java 예외 class FQCN  location: 예외 처리할 UR, /로 시작해야 함**filter : Servlet Filter 등록 정보****filter-mapping : Servlet Filter와 URL 맵핑 정보****listener : Listener 등록 정보**"
  },
  
  {
    "title": "4. java ee, proxy",
    "url": "/learninghub/nhn%20academy/servlet-jsp/4.-Java-EE,-Proxy/",
    "categories": "NHN Academy, Servlet-JSP",
    "tags": "Web, NHN Acedemy, Servlet",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Java EE, Proxy(23. 11. 21)Jave EE  Java 언어 플랫폼 중의 하나  대용량, 멀티 티어의 엔터프라이즈 애플리케이션을 실행하고 운영할 수 있는 기술과 환경을 제공  특정 운영체제와 미들웨어에 종속되지 않고 정보 교환 및 애플리케이션 호환이 가능한 플랫폼을 제공하는 것이 목적Java 언어 플랫폼의 종류Java SE ( Stan...",
    "content": "Java EE, Proxy(23. 11. 21)Jave EE  Java 언어 플랫폼 중의 하나  대용량, 멀티 티어의 엔터프라이즈 애플리케이션을 실행하고 운영할 수 있는 기술과 환경을 제공  특정 운영체제와 미들웨어에 종속되지 않고 정보 교환 및 애플리케이션 호환이 가능한 플랫폼을 제공하는 것이 목적Java 언어 플랫폼의 종류Java SE ( Standard Edition )  Java 2 Platform, Standard Edition 줄여서 J2SE 라고 불렸음  일반적인 응용 프로그램 개발 용도Java EE ( Enterprise Edition )  Java 2 Platform, Enterprise Edition 줄여서 J2EE라고 불렸음  Java SE를 확장하여 분산 컴퓨팅, 웹서비스와 같은 엔터프라이즈 환경을 지원Java ME( Micro Edition )  Java 2 Platform, Micro Edition 줄여서 J2ME라고 불렸음  임베디드 시스템이나 모바일 디바이스를 위한 개발 환경을 지원JavaFx  데스크톱 애플리케이션 및 리치 웹 애플리케이션 개발 환경을 지원  cf.) Fx = special effectsJakarta EE ?  오라클이 2017년 Java EE 8 릴리스를 마지막으로  오픈소스 SW를 지원하는 비영리 단체인 Eclipse 재단에 Java EE 프로젝트를 이관Proxy  자원을 요청하는 서버와 클라이언트 사이에서 중재자 역할을 함Forward Proxy  Client → 서버 요청시에 서버가 직접 주는 것이 아닌 중간의 Foward proxy Server가 서버에 대신 연결하여 그 결과를 전달  caching을 통한 성능 향상 추구  웹 사용 보안 강화 ‘Reverse Proxy  서버를 외부에 두고 WAS 를 내부망으로 연결  WAS을 유연하게 조절 가능정리Servlet  Java를 사용하여 동적 웹 콘텐츠를 생성하는 서버 측 프로그램  CGI 단점 해결 → Servlet Container 도입Servlet Container  Servlet의 생명주기를 관리하고, URL과 특정 서블릿을 맵핑 하며 URL 요청 처리  Java EE 아키텍처에 속함Java EE  Java 언어로 엔터프라이즈 애플리케이션을 개발하고 운영할 수 있도록 지원해 주는 플랫폼  현재는 Eclipse 재단으로 운영이 넘어가서 Jakarta EE 로 변경됨WAS  Web Application Server  = Servlet Containertomcat  apache 재단에서 만든 WAS 중의 하나  Servlet Container의 reference 구현  사실상, Servlet Container = WAS = tomcat"
  },
  
  {
    "title": "3. servlet",
    "url": "/learninghub/nhn%20academy/servlet-jsp/3.-servlet/",
    "categories": "NHN Academy, Servlet-JSP",
    "tags": "Web, NHN Acedemy, Servlet",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Servlet(23. 11 .21)정의  Java를 사용하여 동적 웹 콘텐츠를 생성하는 서버 측 프로그램  쉽게 말해, Java로 만든 CGI 프로그램 같은 것  Servlet 인터페이스를 정의          즉 Servlet 인터페이스를 구현 → java로 구현한 CGI 프로그램이라 할 수 있습니다.      기존 CGI보다 뭐가 더 좋아졌는가? ...",
    "content": "Servlet(23. 11 .21)정의  Java를 사용하여 동적 웹 콘텐츠를 생성하는 서버 측 프로그램  쉽게 말해, Java로 만든 CGI 프로그램 같은 것  Servlet 인터페이스를 정의          즉 Servlet 인터페이스를 구현 → java로 구현한 CGI 프로그램이라 할 수 있습니다.      기존 CGI보다 뭐가 더 좋아졌는가?  요청마다 새로운 프로세스가 생성 (CGI) → 멀티 스레드로 해결  스레드는 누가 생성하고 관리하나 → 컨테이너의 등장Servlet ArchitectureServlet Container ( wiki )  웹 컨테이너(web container, 또는 서블릿 컨테이너)는 웹 서버의 컴포넌트 중 하나로 자바 서블릿과 상호작용한다.  웹 컨테이너는 서블릿의 생명주기를 관리하고, URL과 특정 서블릿을 맵핑 하며 URL 요청이 올바른 접근 권한을 갖도록 보장한다.  웹 컨테이너는 서블릿, Java Server Page(JSP) 파일, 그리고 서버-사이드 코드가 포함된 다른 타입의 파일들에 대한 요청을 다룬다.  웹 컨테이너는 서블릿 객체를 생성하고, 서블릿을 로드와 언 로드하며, 요청과 응답 객체를 생성하고 관리하고, 다른 서블릿 관리 작업을 수행한다.  웹 컨테이너는 웹 컴포넌트 Java EE 아키텍처 제약을 구현하고, 보안, 병행성(concurrency), 생명주기 관리, 트랜잭션, 배포 등 다른 서비스를 포함하는 웹 컴포넌트의 실행 환경을 명세한다(specify).Servlet 실습  https://github.com/UNGGU0704/nhnacademy-study/tree/main/servlet-jsp/servletSurvlet Lifecycle  Instantiation and Loading  Initalizaiotn  Ready  Destruction      GC    HelloServlet클래스에 아래와 같은 메서드를 추가          init      service      destroy            log를 통해 확인 HelloServlet.java      package com.nhnacademy.study;      import java.io.*;      import java.util.logging.Logger;  import javax.servlet.ServletConfig;  import javax.servlet.ServletException;  import javax.servlet.annotation.WebServlet;  import javax.servlet.http.HttpServlet;  import javax.servlet.http.HttpServletRequest;  import javax.servlet.http.HttpServletResponse;      public class HelloServlet extends HttpServlet {      private String message;      private static Logger log = Logger.getLogger(HelloServlet.class.getName());      public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {          System.out.println(\"init 실행\");          response.setCharacterEncoding(\"utf-8\");          try(PrintWriter writer = response.getWriter()) {              writer.println(\"&lt;!DOCTYPE html&gt;\");              writer.println(\"&lt;html&gt;\");              writer.println(\"&lt;head&gt;\");              writer.println(\"&lt;meta charset='utf-8'&gt;\");              writer.println(\"&lt;/head&gt;\");              writer.println(\"&lt;body&gt;\");              writer.println(\"&lt;h1&gt;hello servlet!&lt;/h1&gt;\");              writer.println(\"&lt;h1&gt;안녕 서블릿!&lt;/h1&gt;\");              writer.println(\"&lt;/body&gt;\");              writer.println(\"&lt;/html&gt;\");          } catch (IOException e) {              throw new RuntimeException(e);          }      }          @Override      public void init(ServletConfig config) throws ServletException {          log.info(\"before init!\");          super.init(config);      }          @Override      protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {          log.info(\"before service!\");          super.service(req, resp);      }          @Override      public void destroy() {          log.info(\"before destroy!\");          super.destroy();      }  }      Servlet lifecycle 정리  init() 메서드          Servlet Container가 Servlet을 생성한 후 초기화 작업을 수행하기 위해 호출      클라이언트의 요청을 처리하기 전에 준비할 작업이 있는 경우 여기에서 처리                  ex.) 데이터베이스 접속, 외부 스토리지 연결, property 로딩 등                      service() 메서드는 굳이 override 할 필요 없음  GET, POST, PUT, DELETE 각각의 http method 에 대해          구현이 필요한 doXXX() 메서드 override 해서 구현        destroy() 메서드          Servlet Container가 종료되거나 해당 서블릿을 비활성화시킬 때 호출      서비스 수행을 위해 확보되었던 자원 해제, 데이터 저장등의 마무리 작업 시 여기에서 처리                  ex.) 데이터베이스 연결 종료                    Generic Servlet  http 이외의 프로토콜을 위한 범용 Servlet          http 프로토콜 → HttpServlet 확장      http 이외의 프로토콜 → GenericServlet 확장        abstract class 로서 기본 구현 제공          Servlet interface 에서 service() 메서드를 제외한 나머지 메서드들에 대한 기본 구현 제공      Servlet Context  Servlet Container 실행 환경  Servlet과 Servlet Container 간에 연동을 위해 사용  웹 애플리케이션마다 하나의 ServletContext 생성  하나의 웹 애플리케이션에 포함된 Servlet 들은 동일한 ServletContext 공유  Servlet끼리 자원을 공유하는 데 활용  Servlet Container 실행 시 생성되고 Servlet Container 종료 시 소멸ServletContext 기능  환경정보, 설정정보 제공  서블릿 내에서의 파일 접근WAS  (Java) Application Server라고 불림  정적 웹 서버와 구분하기 위한 용도  Servlet Container, EJB Container등의 역할을 수행함  동적 웹을 제작하기 위한 웹 어플리케이션과 서버 환경을 만들어 동작시키는 기능 제공  서블릿에만 한정적으로 WAS = Servlet Conatiner라고 봐도 좋다.Servlet API  Java EE 에서는 Servlet API Spec 만 정의  실제 구현은 WAS에서 담당  ex)          Servlet API: javax.servlet.http.HttpServletRequest interface      tomcat 구현: org.apache.catalina.connector.Request class      tomcat  apache 재단에서 개발한 무료 오픈 소스 WAS(Web Application Server)  Servlet Container의 reference 구현  Servlet-api 의존 라이브러리가 scope가 provided인 이유→ tomcat 에서 기본적으로 servlet api를 제공하기에 scope를 provided로 지정한다면 패키징시에 제외된다."
  },
  
  {
    "title": "2. cgi",
    "url": "/learninghub/nhn%20academy/servlet-jsp/2.-CGI/",
    "categories": "NHN Academy, Servlet-JSP",
    "tags": "Web, NHN Acedemy, Servlet",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "CGI(23. 11. 20)  Common Gateway Interface  웹 서버가 외부 프로그램을 실행할 수 있도록 해주는 인터페이스 명세(specification)          외부 프로그램 = 동적 웹 콘텐츠 생성하는 역할      c, c++, java, php , go …        웹 서버와 CGI 프로그램(Application) ...",
    "content": "CGI(23. 11. 20)  Common Gateway Interface  웹 서버가 외부 프로그램을 실행할 수 있도록 해주는 인터페이스 명세(specification)          외부 프로그램 = 동적 웹 콘텐츠 생성하는 역할      c, c++, java, php , go …        웹 서버와 CGI 프로그램(Application) 간의 규칙  환경변수나 표준입출력을 다룰 수 있는 프로그램 언어라면 어떤 언어든지 확장하여 이용 가능  실행속도나 텍스트 처리의 용이함 등의 이유로 perl이나 python, ruby 등의 스크립트 언어를 주로 사용CGI 프로그램  컴파일 방식          기계어. 컴파일된 상태      c++, c        인터프리터 방식          스크립트 언어      Asp, Php, Python, Per      스크립트 엔진                  해당 스크립트를 실행할 수 있는 엔진                    즉시 코드를 수정할 수 있음      CGI Spec입출력  주로 표준 입출력 사용Meta-Variables ( 메타 변수 )  웹서버에서 CGI 프로그램으로 전달되는 요청 관련 데이터  주로 환경변수 (environment variable) 형태로 구현          SERVER_NAME      SERVER_PORT      REMOTE_ADDR      REQUEST_METHOD      CONTENT_TYPE      CONTENT_LENGTH      Script ( 스크립트)  서버에 의해 호출되는 소프트웨어  런타임에 해석되는 일련의 명령문장점  언어, 플랫폼에 독립적  구조가 단순하고 다른 서버 사이드 프로그래밍 언어에 비해 쉽게 수행단점  속도가 느림          매 요청마다 DB Connection을 새로 열어야 합니다.        Http 요청마다 새로운 프로세스를 만들어 서버 메모리를 사용합니다.  데이터가 메모리에 캐시 될 수 없다.Java CGI  일반적인 컴파일된 .class는 java application server와 통신이 불가능하다  다른 프로그램 JCGI 가 필요Fest CGI  일반적인 CGI는 느리다…  그래서 나온게 Fest CGI  대부분의 웹서버가 Fast CGI를 제공          Apache      Nginx      IIS          "
  },
  
  {
    "title": "12. war",
    "url": "/learninghub/nhn%20academy/servlet-jsp/12.-WAR/",
    "categories": "NHN Academy, Servlet-JSP",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "WAR(23. 11. 23)war ( Web Application Archive)  웹 애플리케이션 배포를 위한 패키지  참고  tar (Tape Archive) : Uninx / linux archive utility  jar ( Java Archive )  war ( Web application Archive )  /WEB-INF/*. ← 디렉터리...",
    "content": "WAR(23. 11. 23)war ( Web Application Archive)  웹 애플리케이션 배포를 위한 패키지  참고  tar (Tape Archive) : Uninx / linux archive utility  jar ( Java Archive )  war ( Web application Archive )  /WEB-INF/*. ← 디렉터리 하위는 외부 요청에서 직접 참조 불가  /WEB-INF/classes class ← 파일들 위치  /WEB-INF/LIB ← 라이브러리 파일들 위치  web.xml          배치 기술자 파일      maven-war-plugin  pom.xml의 dependency에 선언된 각종 라이브러리, java class 파일, resources를 모아서 하나의 Web Application Archive 형태의 압축 파일을 생성합니다.  pom.xml&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;            &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;            &lt;version&gt;3.3.2&lt;/version&gt;            &lt;configuration&gt;                &lt;warSourceDirectory&gt;src/main/webapp&lt;/warSourceDirectory&gt;                &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;  goal          war:war                  war로 압축된 상태로 배포 ( 사실 확장자만 war일뿐 zip으로 압축되어 있음)                    war:exploded                  압축이 풀린 상태로 배포                    war:in-place      소스코드 /src, /target 디렉터리가 함께 생성됩니다.        주로 war, exploded를 사용합니다."
  },
  
  {
    "title": "11. annotation",
    "url": "/learninghub/nhn%20academy/servlet-jsp/11.-Annotation/",
    "categories": "NHN Academy, Servlet-JSP",
    "tags": "Web, NHN Acedemy, Servlet",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Annotation (23. 11. 30)  프로그램을 구성하는 직접적인 코드는 아니지만 프로그램 작성에 도움을 주거나 필요한 데이터를 제공→ javadoc은 anootaion은 아니다..Annotation의 용도  컴파일러에게 문법을 알리는 제공  SW 개발툴을 통해 코드 자동 생성 기능          Lombok        AOP 관전 지향 프...",
    "content": "Annotation (23. 11. 30)  프로그램을 구성하는 직접적인 코드는 아니지만 프로그램 작성에 도움을 주거나 필요한 데이터를 제공→ javadoc은 anootaion은 아니다..Annotation의 용도  컴파일러에게 문법을 알리는 제공  SW 개발툴을 통해 코드 자동 생성 기능          Lombok        AOP 관전 지향 프로그래밍Java 내장 Annoation@Override  메소드 재정의@SuppressWarnings  컴파일 경고를 무시          cast : cast 경고 무시      finally , null 등등…      @SafeVarags  제네릭 타입에 사용@FunctionalInterface  java에서 함수형 프로그램을 하기 위해서 인터페이스를 일급함수를 만들기 위해서 사용Reflection &amp; Annotaion 실습  https://github.com/UNGGU0704/nhnacademy-study/tree/main/servlet-jsp/refection%20%2B%20annotaion%20실습"
  },
  
  {
    "title": "10. reflection",
    "url": "/learninghub/nhn%20academy/servlet-jsp/10.-Reflection/",
    "categories": "NHN Academy, Servlet-JSP",
    "tags": "Web, NHN Acedemy, Servlet",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Reflection(23. 11. 30)reflection을 이용한 객체 생성public static void main(String[] args) {    try {        Class userClass = Class.forName(User.class.getName());        Constructor&lt;?&gt; constructor = ...",
    "content": "Reflection(23. 11. 30)reflection을 이용한 객체 생성public static void main(String[] args) {    try {        Class userClass = Class.forName(User.class.getName());        Constructor&lt;?&gt; constructor = userClass.getConstructor();        User user = (User) constructor.newInstance();        System.out.println(user);    } catch (ClassNotFoundException | NoSuchMethodException e){        e.printStackTrace();    } catch (InvocationTargetException e) {        e.printStackTrace();    } catch (InstantiationException e) {        e.printStackTrace();    } catch (IllegalAccessException e) {        e.printStackTrace();    }}  Class.forName(className)          물리적인 클래스 파일명을 인자로 넘겨주면 이에 해당하는 클래스를 반환합니다.        Class.getConstructor()          public 접근자를 가진 생성자를 반환합니다.      Class.forName(User.class.getName()).getConstructor(String.class ,Integer.TYPE); 이런식으로 타입을 지정 할 수 도있다.        getDeclaredMethod          method를 복사하는 기능      getter 를 복하      ``Method setUserNameMethod =clazz.getDeclaredMethod(“setUserName”,String.class);`      private 도 접근이 가능할까? → userAgeField.setAccessible(true); 로 가능!      의존성 주입  의존성 주입을 위한 @Autowired annotation 를 이용한다.      UserRepository.java      public class UserRepository {      private List&lt;User&gt; users = new ArrayList&lt;&gt;();      public User findByName(String userName){      \treturn users.stream()          \t.filter(o-&gt;o.getUserName().equals(userName)).findFirst().orElse(null);      }          public void save(User user){     \t\tthis.users.add(user);      }  }            UserService.java      public class UserService {       @Autowired   private UserRepository userRepository;       public User getUser(String userName){   \treturn userRepository.findByName(userName);   }   public void addUser(User user){  \t userRepository.save(user);   }            InjectUtil      public final class InjectUtil {          public static &lt;T&gt; T getObject(Class&lt;T&gt; classType){          T instance = createInstance(classType);          Field[] fields = classType.getDeclaredFields();      for(Field field : fields){          if (field.getAnnotation(Autowired.class) != null) {              Object fieldInstance = createInstance(field.getType());              field.setAccessible(true);              try {                  field.set(instance, fieldInstance);              } catch (IllegalAccessException e) {                  throw new RuntimeException(e);              }          }      }      return instance;  }      private static &lt;T&gt; T createInstance(Class&lt;T&gt; classType) {      try {          return classType.getConstructor(null).newInstance();      } catch (InstantiationException e) {          e.printStackTrace();      } catch (IllegalAccessException e) {          e.printStackTrace();      } catch (InvocationTargetException e) {          e.printStackTrace();      } catch (NoSuchMethodException e) {          e.printStackTrace();      }      return null;  }              UserService 에 UserRepository 를 자동으로 주입해주는 class      UserService 의 Reflection API를 이용해 모든 Fields를 조회 Field[] 배열로 반환      배열 순회하면서 @Autosired annotaion 이 있는 field를 조회 createInstance() 를 통해 객체 생성      객체의 생성을 프로그램에 의해서 컨트롤 → InjectUtil이 객체 의존성을 제어한다.      "
  },
  
  {
    "title": "1. web",
    "url": "/learninghub/nhn%20academy/servlet-jsp/1.-Web/",
    "categories": "NHN Academy, Servlet-JSP",
    "tags": "Web, NHN Acedemy, Servlet",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Web(23. 11. 20)Wep Application이란?Server  Client가 요청한 서비스 제공자Client  서비스를 사용하는 사용자Server - Client  메일 서버…  파일 서버…  웹서버…Web Application Architecture이란?  application의 구성요소, 미들웨어 시스템, UI와 DB의 상호작용을 표시하...",
    "content": "Web(23. 11. 20)Wep Application이란?Server  Client가 요청한 서비스 제공자Client  서비스를 사용하는 사용자Server - Client  메일 서버…  파일 서버…  웹서버…Web Application Architecture이란?  application의 구성요소, 미들웨어 시스템, UI와 DB의 상호작용을 표시하는 골격 또는 레이 아웃  데이터를 HTTP를 통해 전달, Client와 BackEnd Server 간의 통신 보조구성요소  웹 브라우저 (HTML, 이미지 파일…)  웹 서버 (apache)  DB 서버 (mysql, oracle)Client - Server Architecture vs Web Application Architecture                   Client - Server Application      Web Application                  아키텍쳐      2 tire      multi tire              상호작용      사용자의 인터페이스 또는 애플리케이션      웹 브라우저              실행      애플리케이션 사전 설치      웹 브라우저에서 직접 실행              쿠키      none      required              보안      상대적으로 사용자가 적기 때문에 위험이 적습니다.      사용자 수가 많을수록 상대적으로 높은 위험              접근      제한적      anywhare      Web Server  http 프로토콜을 통해 웹 브라우저에 요청 하면 데이터를 전송해주는 프로그램          HTML      img      JavaScript Object        아파치, nginx등이 있음Dynamic Web Contents  사이트가 동적으로 움직임  사용자와 상호 작용 가능Static Web Contents  미리 저장되어 있는 콘텐츠  HTML 파일"
  },
  
  {
    "title": "Logging",
    "url": "/learninghub/nhn%20academy/etc/logging/",
    "categories": "NHN Academy, ETC",
    "tags": "NHN Acedemy",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Java Logging(23.09.01)Logging  시스템 동작 시, 시스템의 상태와 작동 정보를 시간 경과에 따라 기록하는 것  java에서의 Logging 방법은 System.out.println, log4j, logback 등이 있음System.out.println()  System.out은 표준 출력 작업을 수행하는 메서드를 제공함  Log...",
    "content": "Java Logging(23.09.01)Logging  시스템 동작 시, 시스템의 상태와 작동 정보를 시간 경과에 따라 기록하는 것  java에서의 Logging 방법은 System.out.println, log4j, logback 등이 있음System.out.println()  System.out은 표준 출력 작업을 수행하는 메서드를 제공함  Logging에도 활용할 수 있다고 생각할 수 있으나, System.out으로 로그를 남기면 안됨로깅 시 해당 메서드를 활용할 수 없는 이유는?  에러 발생 시 추적할 수 있는 최소한의 정보가 남지 않음          날짜 및 시간, 수준(error, info, debug 등), 발생 위치 등의 정보를 기록하기가 어려움        로그 출력 레벨을 사용할 수 없음          로깅 라이브러리를 이용하면 TRACE, DEVUG, INFO, WARN, ERROR 등의 다양한 로그 레벨을 사용할 수 있지만, System.out은 해당 기능을 사용할 수 없음        성능 저하 발생          System.out.println()에서 사용하는 newLine() 메서드에는 synchronized 키워드가 붙어있으므로 해당 메서드는 critical section이 됨. 멀티 쓰레드 환경에서 어떠한 쓰레드가 해당 메서드를 실행하는 도중에는 다른 쓰레드에서 해당 메서드 실행이 불가함. 그러므로 멀티 쓰레드 환경에서 성능 저하가 발생하게 됨.      Java Standard Loggingjava.util.logging.Logger  java에 내장되어 있는 로깅용 유틸 클래스  java.util.logging 패키지에 속해있음  로그 레벨 지원          SEVERE &gt; WARNING &gt; INFO &gt; CONFIG &gt; FINE &gt; FINER &gt; FINEST      로깅을 끄는 OFF, 모든 로깅을 찍는 ALL도 있음        장점          외부 라이브러리를 사용할 필요가 없음        단점          다른 라이브러리와 비교 했을 때, 속도가 느림      타 라이브러리에 비해 기능이 부족함      커스텀 레벨을 만들 때 메모리 누수가 일어남      Logback  slf4j(Simple Logging Facade for Java) 구현체  다양한 Logging framework 중 하나로, log4j보다 향상된 기능을 갖고 있으며 가장 널리 사용되고 있음  로그 레벨          error &gt; warn &gt; info &gt; debug &gt; trace      error : 요청 처리 중 문제가 발생함을 뜻함      warn : 프로그램 실행은 문제가 없지만, 향후 문제를 일으킬수도 있음을 뜻함      info : 정보성 메시지      debug : 개발 시 디버그 용도로 사용됨      trace : 좀 더 상세한 이벤트를 나타낼 때 사용됨            Logback 의존성 주입      &lt;dependencies&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.slf4j&lt;/groupId&gt;          &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;          &lt;version&gt;2.0.7&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;          &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;          &lt;version&gt;1.4.8&lt;/version&gt;      &lt;/dependency&gt;  &lt;/dependencies&gt;        resoures 디렉토리 생성 수 logback.xml 파일 생성  → 로그 설정  로그 명령어 설정log.trace(\"trace log={}\", name);        log.debug(\"debug log={}\", name);        log.info(\"info log={}\", name);        log.warn(\"warn log={}\", name);        log.error(\"error log={}\", name);"
  },
  
  {
    "title": "Maven",
    "url": "/learninghub/nhn%20academy/etc/Maven/",
    "categories": "NHN Academy, ETC",
    "tags": "NHN Acedemy",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Maven(23.08.31)빌드 도구  소프트웨어 개발에 있어서 소스 코드를 실행 가능한 애플리케이션으로 만들어주는 도구  빌드 도구는 반복적이고 오류가 발생하기 쉬운 활동을 자동화하여 생산성 일관성 및 의존성을 개선  빌드 도구의 중요성          자동화                  빌드 도구는 루틴한 작업을 자동화하여 수동 참여와 오류를 제...",
    "content": "Maven(23.08.31)빌드 도구  소프트웨어 개발에 있어서 소스 코드를 실행 가능한 애플리케이션으로 만들어주는 도구  빌드 도구는 반복적이고 오류가 발생하기 쉬운 활동을 자동화하여 생산성 일관성 및 의존성을 개선  빌드 도구의 중요성          자동화                  빌드 도구는 루틴한 작업을 자동화하여 수동 참여와 오류를 제거합니다. 이는 복잡한 프로젝트에서 작업하거나 코드를 자주 수정하는 경우에 유용합니다.                    일관성                  빌드 도구는 지정된 빌드 프로세스를 엄격히 준수하여 다양한 개발 환경 및 플랫폼에서 재현 가능한 결과를 보장합니다. 따라서 잘못된 구성으로 인한 소프트웨어 배포 문제가 줄어듭니다.                    의존성 관리                  외부 라이브러리와 프레임워크의 요구 사항을 처리함으로써 프로젝트에 타사 코드를 포함하기가 더욱 간단해집니다. 이들은 의존성을 자동으로 다운로드, 관리 및 변경하여 개발 프로세스를 간소화할 수 있습니다.                    작업 병렬 처리                  많은 빌드 도구는 여러 작업을 동시에 실행하여 빌드 시간을 줄이고 생산성을 높일 수 있습니다. 이는 많은 부분으로 구성된 대형 프로젝트에 유용합니다.                    점진적 빌드                  빌드 도구를 사용하면 점진적인 빌드가 가능해져 시간과 자원을 절약할 수 있습니다. 전체 애플리케이션을 다시 컴파일하는 대신 소스 코드의 변경 사항을 감지하고 영향을 받은 부분만 다시 컴파일합니다.                    CI/CD 통합                  빌드 도구는 CI/CD 파이프라인과 투명하게 통합되어 개발자에게 완전한 빌드 및 배포 프로세스 자동화를 지원합니다. 이 동기화로 인해 지속적으로 통합하고 업데이트를 본문 설정에 계속 배포함으로써 신뢰성 있는 소프트웨어 전달이 가능해집니다.                    코드 컴파일                  빌드 도구는 소스 코드를 이진 실행 파일이나 중간 표현으로 변환하는 과정을 말합니다. 이 과정은 개발 단계에서 구문 오류 및 기타 문제를 감지하는 데 도움이 됩니다.                    테스트 및 품질 보증                  빌드 프로세스의 일부로 자동화된 테스트를 실행하여 새로운 기능과 코드 수정이 문제를 일으키지 않도록하고 코드가 수립된 품질 기준을 충족하는지 확인할 수 있습니다.                    호환성 및 확장성                  이러한 도구는 다양한 언어, 프레임워크 및 운영 체제와 호환됩니다. 플러그인이나 직접 작성한 스크립트와 같은 새로운 기능을 추가하여 프로젝트 요구 사항에 맞게 수정할 수 있습니다.                    배포 및 패키징                  빌드 도구는 소프트웨어를 최종 사용자나 다른 그룹에 전달하기 쉽게 만들어주며 배포 가능한 형식으로 패키징하는 과정을 도와줍니다.                    xml  마크다운 언어  태그는 아무거나 사용 가능  규칙등을 정의해놓은 문서  ant나 maven을 위한 빌드 내용, 규칙등을 기술maven 이란  Java의 대표적인 빌드 툴(Build Tool) 중 하나  apache 재단에서 개발하는 오픈소스 https://maven.apache.org/  apache ant의 후속으로 개발  XML을 사용하여 빌드 파일을 기술  중앙 저장소를 이용한 편리한 의존 관계 라이브러리 관리  중앙 저장소: 메이븐에서 이용 가능한 라이브러리를 모아서 관리하는 웹 서비스maven의 장점  편리한 의존 관계 라이브러리 관리  일관된 디렉토리 구조와 빌드 프로세스 관리  다양한 플러그인maven의 단점  maven에서 기본적으로 지원하지 않는 빌드 과정 추가가 복잡해짐maven 설치  brew install mvnmaven 프로젝트 생성  mvn -B archetype:generate -DgroupId=com.nhnacademy.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4          B : batch Mode, Interactive한 입력이나 진행상황 표시없이 명령어를 실행      archetype:generate : 미리 정의된 템플릿을 기반으로 새로운 프로젝트를 생성      DgroupId=com.nhnacademy.app : Project의 그룹 ID                  (ex) nhnacademy.com -&gt; com.nhnacademy                    DartifactId=my-app : 프로젝트의 artifact ID                  artifact 사전적 의미 : 인공물, 공예품, 인공 유물, 인공 산물          Project를 식별할 수 있는 ID                    DarchetypeArtifactId=maven-archetype-quickstart                  maven-archetype-quickstart 이라는 archetype을 사용하여 프로젝트를 생성          빠르게 시작할 수 있는 간단한 Java 프로젝트 템플릿을 제공합니다.                    DarchetypeVersion=1.4 archetype version        일관된 프로젝트 템플릿을 제공하기에 많은 사람들이 사용Life Cycleclean  프로젝트를 정리하고 이전 빌드에서 생성된 모든 파일을 제거합니다.          project_root/target 삭제합니다.      기존의 Pacakge는 clean 하고 새로 만들것 → 덮어쓰기가 원칙이기에 삭제한 코드가 있을 수 있음.      vaildate  프로젝트의 상태를 점검하고, 필드에 필요한 정보의 존재유무를 체크합니다.          프로젝트의 POM 및 구성을 검증합니다.      compile  프로젝트의 소스 코드를 컴파일 합니다.test  프로젝트에 대한 테스트를 실행합니다.package  프로젝트에 대한 JAR(Java ARchive) 또는 WAR(Web Archive) 파일을 생성하여 배포 가능한 형식으로 변환합니다.  package 실행시 위의 vaildate ~test까지 동시에 실행한다.Dependency Scopecompile  default scope  모든 상황에 포함provided  compile과 유사하게 모든상화에 포함되어 수행되지만 package단계에서는 포함하지 않음  즉 배포환경(실행환경)에서 해당 Library를 제공runtime  compile시 불필요하지만 runtime시 필요할 경우.  즉 runtime 및 test할 때 classpath에 추가 되지만, compile시 추가 되지 않음test  test에서만 사용  junitDependency ManagementJunit5  JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit VintageJUnit Platform  JUnit 테스트를 실행하고 테스트 엔진과 통신하기 위한 인프라를 제공합니다. 테스트 실행, 확장, 리포팅 등의 기능을 담당합니다.JUnit Jupiter  JUnit 5에서 도입된 새로운 테스트 프레임워크입니다. Jupiter는 JUnit 5의 주요 기능으로서 다양한 테스트 유형을 지원하고, 확장 가능한 테스트 API를 제공합니다. @Test, @Display ,@BeforeEach, @AfterEachJUnit Vintage  JUnit 4 및 이전 버전과 호환성을 제공하기 위한 모듈입니다. 이전에 작성된 JUnit 4 스타일의 테스트 코드를 JUnit 5 플랫폼에서 실행할 수 있도록 도와줍니다.BOM (Bill Of Materials)  프로젝트나 라이브러리에서 사용되는 dependency 버전을 관리하는 데 도움을 주는 메커니즘입니다. Maven BOM은 Maven 프로젝트에서 여러 모듈 또는 하위 프로젝트 간에 공유되는 의존성의 버전을 일관되게 유지하기 위해 사용되는 특별한 종류의 POM 파일입니다. ```           org.junit.platform      junit-platform-launcher      test            org.junit.jupiter      junit-jupiter-engine      test            org.junit.vintage      junit-vintage-engine      test    &lt;/dependencies&gt;                        org.junit            junit-bom            5.10.0            pom            import            ```"
  },
  
  {
    "title": "Junit,package,jar",
    "url": "/learninghub/nhn%20academy/etc/Junit,Package,jar/",
    "categories": "NHN Academy, ETC",
    "tags": "NHN Acedemy",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Junit 5, Package, jar…(23.08.30)  자바 프로그래밍 언어용 유닛 테스트 프레임 워크  왜 Junit을 사용하는가?          함수 및 메소드가 의도한 대로 잘 동작하는지 검증이 필요함      단위 테스트를 통해 안전성을 높일 수 있음            대표적인 사용 예시      public class Junit5Te...",
    "content": "Junit 5, Package, jar…(23.08.30)  자바 프로그래밍 언어용 유닛 테스트 프레임 워크  왜 Junit을 사용하는가?          함수 및 메소드가 의도한 대로 잘 동작하는지 검증이 필요함      단위 테스트를 통해 안전성을 높일 수 있음            대표적인 사용 예시      public class Junit5Test {      @Test      @DisplayName(\"DisplayName 테스트\")          // DisplayName 어노테이션을 통해서 더 우아하게 생성 가능      void test_문자열_출력_테스트() { //test 이름을 정하는게 중요하다.          System.out.println(\"test\");      }  }            테스트의 순서      package NHN_weeks_1;      import org.junit.jupiter.api.Test;      public class Junit5Test {      @Test      void one() {          System.out.println(\"1\");      }          @Test      void two() {          System.out.println(\"2\");      }          @Test      void three() {          System.out.println(\"3\");      }          @Test      void four() {          System.out.println(\"4\");      }          @Test      void five() {          System.out.println(\"5\");      }  }        해당 코드의 순서는 위에서 아래가 아니다    @Order 를 사용해서 순서를 조절 가능  다양한 Annoations들  @Test          테스트 코드 실행 가능        @DisplayName          테스트 이름 지정        Assertions.assertTrue()  Assertions.assertFalse()  Assertions.assertArrayEquals()  Assertions.assertInstanceOf()  Assertions.assertEquals()  Assertions.assertThrows()Assertions      Assertions를 활용하여 테스트 코드를 작성 하는 법 예시    Dice      public class Dice {      private int number;          Dice(int n) {          if (n &lt;= 0 || n &gt;= 7) {              throw new IllegalArgumentException(\"유효하지 않은 값\");          }          this.number = n;      }          public int getNumber() {          return number;      }  }        DiceTest      public class DiceTest {      @Test      @DisplayName(\"Dice 객체 생성 테스트 \")      void diceCreat() {          Dice dice = new Dice(4);              Assertions.assertEquals(4, dice.getNumber());      }          @Test      @DisplayName(\"Dice 객체 생성 반복 테스트 \")      void DiceIteratorTest() {          int[] arr = {1, 2, 3, 4, 5, 6};              for (int i = 0; i &lt; arr.length; i++) {              Dice dice = new Dice(arr[i]);              Assertions.assertEquals(arr[i], dice.getNumber());          }      }      \t\t@ParameterizedTest // 파라미터 주입       @ValueSource(ints = {1, 2, 3, 4, 5, 6})      @DisplayName(\"Dice 객체 Param 테스트\")      void diceParamTest(int number) {          Dice dice = new Dice(number);          Assertions.assertEquals(number, dice.getNumber());      } // ints의 모든 인덱스에 대해 테스트 실행           @Test      @DisplayName(\"Dice 객체 생성 -1 입력 테스트 \")      void negativeDiceCreate() {          Assertions.assertThrows(IllegalArgumentException.class,                  () -&gt; new Dice(-1)); // 예상되는 예외를 받는지 확인      }      }        Assertions.assertEquals 를 통해 생성자를 통해 만들어지는 input되는 값과 객체의 멤버 변수 비교    Assertions.*assertThrows* 를 통해 음수가 들어갈시 적절한 예외를 내보내는지 확인    @ParameterizedTest 와  @test 는 같은 뜻을 가진 어노에이션 중복해서 쓰지 않게 주의          스트림을 사용한다면 더욱 효율적인 테스트 케이스 생성이 가능 하다.            왜 테스트 코드를 작성하고 실행하는 이유?          테스트 코드를 통해 대규모 코드의 안전성을 높일 수 있다. (에러 확률 감소)      코드를 작성하기 전에 테스트 코드를 먼저 작성하면 더 좋을수도?      코딩 테스트에서 TC 채점 할떄 이런식으로 하는 걸까 생각…      PackagePackage란?  class들의 모음고유성  package를 사용하는 이유는 클래스명의 고유성을 보장하기 위해서 사용  만약 다른 java프로그래머가 협업과정에서 서로 다른 목적을 가진 클래스를 생성 했는데 이름이 같다고 가정할 때, 서로 다른 패키지를 사용함으로써 충돌을 피할 수 있다.최상위 패키지명은 도메인  최상위 패키지명에 도메인 주소를 앞뒤로 바꿔서 사용  이미 인터넷 도메인은 고유성을 가지고 있음으로 충돌에 대한 걱정할 필요가 없음      일종의 관례    com.nhnacademy.study ...    ex)      package com.google.gson; // 도메인 뒤집어서 사용해서 고유성을 보장       public final class Gson {   //...  }      폴더형식의 package 구조  Springframework 페키지 구조  폴더구조형태로 계층적으로 구성되어 있음  org.springframework.spring-corejar  java에서 제공하는 압축 파일, zip 압축  class 파일, resource(텍스트,이미지), .. 메타데이터를 하나로 모아서 Java 플랫폼에 응용소프트웨어나 라이브러리를 배포하기위한 소프트애어 패키지 파일  컴파일된 class 파일을 jar 묶어서 배포하면 , 경로나 파일의 위치에 상관없이 프로그램 실행 가능      jar 파일 생성    jar --create --file  hello.jar --main-class com.nhnacademy.hello.Main -c ./com    → --main-class com.nhnacademy.hello.Main main 함수가 다수 존재 할떄 main의 위치를 지정    → ./com 가장 루트 디렉 토리    → hello.jar 라는 실행 가능한 파일을 생성    → unzip 을 활용하여 다시 압축 해제도 가능하다.  "
  },
  
  {
    "title": "9. 관계 대수와 관계 해석",
    "url": "/learninghub/nhn%20academy/database/9.-%EA%B4%80%EA%B3%84-%EB%8C%80%EC%88%98%EC%99%80-%EA%B4%80%EA%B3%84-%ED%95%B4%EC%84%9D/",
    "categories": "NHN Academy, DataBase",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "9. 관계 대수와 관계해석 (23. 11. 17)관계 대수  관계 대수식(Relational Algebra Expression)은 연산자들의 모임을 사용해서 구성된 대수식  하나 또는 두 개의 릴레이션을 파라미터로 하나의 릴레이션 인스턴스를 반환  연산자들을 조합해서 복잡한 질의를 만들기 쉬움  릴레이션, 단항(Unary) 연산자와 이항(Binary)...",
    "content": "9. 관계 대수와 관계해석 (23. 11. 17)관계 대수  관계 대수식(Relational Algebra Expression)은 연산자들의 모임을 사용해서 구성된 대수식  하나 또는 두 개의 릴레이션을 파라미터로 하나의 릴레이션 인스턴스를 반환  연산자들을 조합해서 복잡한 질의를 만들기 쉬움  릴레이션, 단항(Unary) 연산자와 이항(Binary) 연산자로 순환적으로 정의  셀렉션, 프로젝션, 합집합, 차집합, 카티션 프로덕트등의 기본 연산자의 조합으로 구성  관계 질의는 연산자의 적용 순서를 통해 원하는 답을 구하는 계산 절차를 한 단계씩 묘사한 것          대수식은 질의 수행을 위한 계획으로 생각할 수 있음      관계 시스템은 대수식을 질의 수행 계획으로 표현하는데 이용      셀렉션과프로텍션  관계에 있어 튜플을 선택할수 있는 연산자 시그마( δ )  필드들을 추출(Projection)할 수 있는 연산자 파이 ( π )  단일 관계에 있어 데이터 조작하는데 사용            파일럿번호      파일럿이름      등급      나이                  13      홍길동      1      44              32      이순신      10      44              4      안중근      7      32      아래의 관계 대수식은δ등급&gt;5(Pilot1)아래와 같은 릴레이션을 산출            파일럿번호      파일럿이름      등급      나이                  32      이순신      10      47              44      안중근      7      32      집합 연산  합집합, 교집합, 차집합, 카티션 프로덕트와 같은 표준 집합 연산      합집합(Union, ∪)    인스턴스 R이나 인스턴스 S 모두에 속하는 투플들을 포함하는 릴레이션 인스턴스를 만듦    R과 S는 합병 가능해야 하며, 결과 스키마는 R의 스키마와 동일        교집합(Intersection, ∩)    R ∩ S는 양쪽에 함께 속하는 모든 투플로 구성된 릴레이션 인스턴스를 만듦        차집합(Set-different, – )    R – S는 R에는 속하고 S에는 속하지 않는 투플로 구성된 릴레이션 인스턴스를 만듦        카디션 프로덕트(Cartisian Product, X )    R X S는 R의 모든 필드와 S의 모든 필드를 순서대로 가지는 스키마의 릴레이션 인스턴스를 만듦    R X S는 r∈R, s∈S 쌍에 대하여 투플 &lt;r, s&gt;를 하나씩 가짐  이름 바꾸기  릴레이션에서 필드의 이름을 변경(Renaming)할 수 있는 연산자 로우( ρ )  관계 대수식 안에서 이름 충돌이 발생할 수 있음  관계 대수식 안에서 릴레이션 인스턴스의 이름을 주는 것이 편리함  긴 대수식을 작은 부분으로 나누어 결과 인스턴스에 이름을 줄 수 있도록 하는 것이 편리함Join  둘 이상의 릴레이션으로 부터 정보를 조합하는 연산 (⋈)  유도된 연산으로, 카티션 프로덕트와 프로젝션 연산을 함께 실행하여 얻은 결과와 동일            종류      기호      기능                  동등 조인      ⋈      두 릴레이션간의 값을 가진 집합              세타 조인      ⋈θ      두 릴레이션 간의 비교 조건에 만족하는 집합              자연 조인      ⋈N      동등 조인에서 중복 속성을 제거              세미 조인      ⋉ and ⋊      자연 조인 후 기호의 열린쪽의 속성을 제거              외부 조인 Left      ⟕      자연 조인 후 왼쪽의 모든 값을 추출, 값이 없을 경우 한쪽의 값을 NULL로 채용              외부 조인 Right      ⟖      자연 조인 후 오른쪽의 모든 값을 추출, 값이 없을 경우 한 쪽의 값을 NULL로 채용              외부 조인 Full      ⟗      자연 조인 후 양쪽의 모든 값을 추출, 값이 없을 경우 한 쪽의 값을 NULL로 채용      Quiz  관계 대수 질의  아래와 같은 릴레이션 스키마가 있고,  파일럿(파일럿번호: 정수, 파일럿이름: 문자열, 등급: 정수, 나이: 실수) 비행기(비행기번호: 정수, 비행기이름: 문자열, 비행기종류: 문자열) 운항(파일럿번호: 정수, 비행기번호: 정수, 운항일자: 날짜)  각 릴레이션의 인스턴스가 아래와 같다고 할 때,  Pilot1                    파일럿번호        파일럿이름        등급        나이                            13        홍길동        1        44                    32        이순신        10        44                    44        안중근        7        32              AirCraft                    비행기번호        비행기이름        비행기종류                            101        에놀라게이        폭격기                    102        톰캣        전투기                    102        블랙버드        정찰기              Flight                    파일럿번호        비행기번호        운항일자                            13        101        2022-10-09                    44        102        2022-11-23                  비행기 101을 운항하는 파일럿의 이름을 구하세요.    π파일럿이름, Aircraft(δ비행기 번호 = 101)        문제 1을 응용하여 개명 연산을 사용하여 각 대수식을 작은 부분으로 분할한 다음 합쳐 연산하는 관계 대수식을 작성하세요.    ρ(101번비행기(σ비행기 번호 = 101) ∪ ρ(101번비행기이름(π파일럿이름)        전투기를 운항하는 파일럿의 이름을 구하세요.    δ비행기 종류(전투기), π파일럿이름  관계 해석                              **T(투플 변수)          p(T)(Formula - T를 묘시하는 식) }** 형식으로 투플 간의 관계를 해석                      투플 변수          어느 릴레이션 스키마의 투플들을 값을 갖는 변수.      주어진 투플 변수에 대입되는 값들은 모두 동일한 개수와 타입의 필드들을 가짐        Rel이 릴레이션 이름이고 R과 S를 투플 변수로, a를 R의 한 애트리뷰트로, b를 S의 한 애트리뷰트라고 하고, op를 집합 { &lt;, &gt;, =, ≤, ≥, ≠ }에 속하는 연산자라고 할 때, 원자식은          R ∈ Rel      R.a op S.b      R.a op 상수 또는 상수 op R.a        식 (Formula)은 다음 중 하나로 순환적으로 정의          원자식      ㄱp, p∧q, p∨q, 또는 p ⇒q      ∃R(p(R)). 이때 R은 투플 변수      ∀R(p(R)). 이때 R은 투플 변수      "
  },
  
  {
    "title": "8. 파일 조직과 인덱스",
    "url": "/learninghub/nhn%20academy/database/8.-%ED%8C%8C%EC%9D%BC-%EC%A1%B0%EC%A7%81%EA%B3%BC-%EC%9D%B8%EB%8D%B1%EC%8A%A4/",
    "categories": "NHN Academy, DataBase",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "8. 파일 조직과 인덱스 (23. 11. 10)디스크에 저장 된 파일들을 레코드에 배치하는 방법 효율적인 DBMS 조작법을 위해 패턴을 파악해 효율적인 파일조직을 선택한다.비용 모델과 파일 조작법비용 모델 개요  데이터베이스에서는 질의가 요청될 때 여러 실행계획을 세우고 최적화된 방법을 찾아 실행  쿼리 최적화기는 쿼리 기반, 비용 기반 등의 모델로 ...",
    "content": "8. 파일 조직과 인덱스 (23. 11. 10)디스크에 저장 된 파일들을 레코드에 배치하는 방법 효율적인 DBMS 조작법을 위해 패턴을 파악해 효율적인 파일조직을 선택한다.비용 모델과 파일 조작법비용 모델 개요  데이터베이스에서는 질의가 요청될 때 여러 실행계획을 세우고 최적화된 방법을 찾아 실행  쿼리 최적화기는 쿼리 기반, 비용 기반 등의 모델로 실행 계획을 비교  비용 측정          데이터 페이지의 개수 B, 페이지에 속한 레코드의 개수 R, 디스크 페이지를 하나를 읽는 시간을 D로 가정      디스크 페이지 하나를 쓰는데 걸리는 평균 시간 D, 한 레코드를 처리하는데 걸리는 시간 C      한 레코드에 해시 함수를 적용하는데 걸리는 시간 H        여기에서는 파일 입출력 비용만 감안하여 파일 조직 별 비용을 비교  쿼리 최적화기는 두가지로 나눈다.          규칙기반 옵티마이저      비용기반 옵티마이저      파일 조직법 비교 기준 연산  스캔, 동등 설렉션, 범위 설렉션, 삽입, 삭제로 나누어 구분한다.Heap  정렬되지 않은 단순한 형태의 파일  스캔 B(D+RC)  동등 셀렉션 후보 키에 대한 연산일 경우 0.5B(D+RC). 후보 키가 아닌 경우 스캔과 동일  범위 셀렉션 스캔과 동일  삽입 레코드가 항상 파일의 끝에 삽입된다고 가정할 경우 2D+C  삭제 탐색 비용 + C + D  힙은 삽입에 있어 가장 좋은 성능을 낸다.정렬 파일특정 필드를 기준으로 정렬된 파일      스캔    힙 파일과 다르지 않음. B(D+RC)        동등 셀렉션    정럴 기준 필드로 검색할 경우 이진 탐색으로 Dlog2B + Clog2R. 정렬 필드가 아닌 경우 스캔과 동일        범위 셀렉션    정렬 기준 필드로 검색할 경우 첫 레코드를 찾는데 동등 셀렉션과 동일. 이후 범위내 스캔        삽입    정렬 순서를 유지하기 위해 레코드가 삽입될 위치를 검색 후 레코드 추가. 후속 페이지를 모두 로드하여 다시 저장 (뒤로 전부 한칸씩 이동해야함) 탐색 비용 + B(D + RC)    만약에 데이터를 넉넉히 만들어놓은다면 삽일 할때 뒤 데이터를 재조직 할 필요가 없다.  해시 파일해시 함수를 통해 데이터를 버킷 단위로 저장하는 방식 → 해시 (ex: 해시맵)      스캔    해시에서는 일반적으로 페이지의 80% 정도를 채운다 1.25B(D + RC)        동등 셀렉션    해시키에 의한 검색조건이라면 H + D + 0.5RC, 아닌 경우 스캔과 동일        범위 셀렉션    스캔과 동일        삽입    적절한 페이지에 다시 기록  결론  힙 파일은 저장성능이 우수 스캔, 삽입, 삭제 연산은 빠르지만 탐색이 느리다.  정렬 파일 또한 저장 성능이 우수하고 삽입, 삭제에는 느리지만 탐색은 빠르다!  해시 파일은 저장성능이 떨어지지만 삽입과 삭제가 빠르며 동등 탐색에 대해서는 대단히 우수하다. 하지만 범위 탐색을 지원하지 않음탐색의 왕 : 정렬 (넉넉한 메모리 가지고 있을 경우 가장 좋다.)전체적으로 무난 : 힙삽입과 삭제의 왕 : 해시 (쓰기 전문인 log 파일의 경우는 우수)인덱스→ 해당 자료구조의 데이터 검색 속도를 높이기 위한 보조 자료구조클러스터드 인덱스  파일을 조직할 때 레코드의 순서를 파일에 대한 인덱스의 순서와 동일한 순서로 유지          테이블의실제 데이터 순서 = 인덱스의 순서      스캔에 유리        파일의 재조직이 필요한 구조  데이터가 삽입/삭제될 때 마다 정렬 순서를 유지하기 위해서 그 주변의 데이터를 이동해야 함          삽입 / 삭제 느리다.        파일이 동적으로 변하는 경우 유지 관리 오버헤드가 높음  주소록을 성과 이름순으로 정리한다면?          성과 이름이 일치한 사람은 서로 가까이 위치 (본래 주소록은 성과 이름으로 정렬)      데이터가 클러스터드(군집) 형태로 인덱스 순서대로 저장되는 방식넌 클러스터드 인덱스  하나의 데이터 파일은 하나의 탐색키에 대해서만 클러스터링 될 수 있음  하나의 데이터 파일에 대해 하나의 클러스드 인덱스만 만들 수 있음  클러스터드 인덱스 구조 파일의 키가 아닌 필드의 빠른 검색을 위한 보조 자료구조  주소록을 이메일 번호 정리          실제 데이터 구조는 성과 이름이지만 이메일 순으로 인덱스만 정렬함  인덱스(이메일)로는 빨리 찾을수는 있지만… 실제 순서와 일치 하지 않음      밀집 인덱스와 희소 인덱스  밀집 인덱스(Dense Index)          파일에 있는 모든 탐색 키 값에 대해 데이터 엔트리를 구성      복합키 인덱스 라고 불릴려나…?        희소 인덱스(Sparse Index)          데이터 파일의 페이지별로 하나의 데이터 엔트리를 구성      기본키와 보조 인덱스  기본 키를 포함한 필드들에 대한 보조 인덱스를 기본 인덱스라고 부름          기본 키가 존재하는 테이블은 기본 키가 클러스터드 인덱스가 되고 해당 자료구조로 테이블을 조직하는 DBMS도 있음      기본 키를 희소, 클러스터드 인덱스로 지정하는 DBMS도 있음        기본 키 이외의 인덱스들을 보조 인덱스로 부름          동일한 탐색 키 필드에 대해 데이터 엔트리가 두 개 존재하는 경우 중복되었다고 함      키 필드가 아닌 필드에 대한 인덱스에는 중복이 나타날 수 있음        해당 탐색 키에 후보 키가 포함되는 경우, 그 키에 대한 인덱스를 유일 인덱스라고 부름복합 키 인덱스  인덱스가 여러 필드를 참조 할경우 복합 키  특정 쿼리에 대해 높은 성능  ex: 나이, 이름을 통해 인덱스를 만드는것실습  CREATE INDEX idx_Product_CategoryNo ON Product(CategoryNo);      CategoryNo을 Index로 추가        SELECT * FROM Product WHERE CategoryNo &gt; 0;    자동으로 정렬이된다.  Where 식에서 CategoryNo 를 활용해 찾는 도중 Index를 활용함을 알 수 있음  EXPLAIN 을 활용해서 index 보기→ msSQL 은 이런식으로 정렬이 안된다.정렬 하기 위해 Index를 사용하는 것은 위험한 생각…"
  },
  
  {
    "title": "7. 디스크와 파일",
    "url": "/learninghub/nhn%20academy/database/7.-%EB%94%94%EC%8A%A4%ED%81%AC%EC%99%80-%ED%8C%8C%EC%9D%BC/",
    "categories": "NHN Academy, DataBase",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "7. 디스크와 파일 (23. 11. 09)DBMS 내부의 데이터는 디스크나 테이프 같은 저장장치에 저장됩니다. DBMS는 논리적 스키마와 물리적 스키마르 분리하기 위해 데이터가 저장되는 구조와 논리적 기술구조를 분리디스크와 파일 개요  DBMS 내부의 데이터는 디스크나 테이프등의 관리에의해 저장  디스크 관리자는 디스크 공간을 추적 감시하는 역할 수행...",
    "content": "7. 디스크와 파일 (23. 11. 09)DBMS 내부의 데이터는 디스크나 테이프 같은 저장장치에 저장됩니다. DBMS는 논리적 스키마와 물리적 스키마르 분리하기 위해 데이터가 저장되는 구조와 논리적 기술구조를 분리디스크와 파일 개요  DBMS 내부의 데이터는 디스크나 테이프등의 관리에의해 저장  디스크 관리자는 디스크 공간을 추적 감시하는 역할 수행  처리 과정에 레코드가 필요하게 되면 레코드는 디스크로부터 주 기억 장치로부터 fetch  레코드 위치는 파일 관리자가 결정한다.기억장치 계층 구조  기억자치 계증 구조는 다음과 같다.          1차 저장 장치 - 캐쉬      2차 저장 장치 - SSD      3차 저장 장치 - 테이프        1차 저장장치 같은 경우 소멸성 저장장치  비 소멸성 저장장치인 디스크나 테이프를 사용하는 경우도 있음HDD  기계 장치가 포함된 저장장치로, 자기를 이용하여 데이터를 저장하고 읽음  순차 접근 방식이 아닌 직접 접근 방식SSD  플래시 메모리를 기반으로 한 저장 매체로, Random Access 가능한 빠른 속도의 저장 장치  모든 구성요소가 전기장치이며, 기계 장치를 가지지 않음디스크 공간 관리비어 있는 블록의추적 감시  레코드를 삽입함에 따라 데이터베이스를 확장되고 축소됨  DBMS는 사용중인 디스크 블록과 어떤 블록에 존재하는지 추적 감시함  추적 감시  비어있는 블록들의 리스트를 유지  디스크 블록마다 1 비트씩 블록의 사용 여부를 나타내는 비트맵을 유지운영체제 파일 시스템을 이용한 디스크 공간 관리  운영체제는 디스크 공간을 관리함          운영체제는 파일을 바이트의 순서(Sequence)로 고수준 서비스를 제공      고수준의 요청을 운영체제에 따른 저수준 명령어로 바꾸어 처리함        DBMS는 운영체제 파일 시스템을 바탕으로 데이터베이스를 관리하기도 함  대부분의 DBMS는 운영체제의 파일 시스템에 의존하지 않음          특정 운영체제의 세부적 사양에 맞추면 다양한 운영체제에서 동작하는 DBMS를 만들기 어려움      운영체제는 최대 파일 크기를 제한하는 경우가 있음      운영체제 파일은 여러 디스크로 분할되지 못함      페이지 참조 패턴을 일반적인 운영체제보다 더 정확히 예측해야 함      페이지를 디스크에 기록하는 시점에 대해 더 많은 제어를 해 주어야 함      버퍼 관리자버퍼풀      가용한 주 기억장치 공간을 페이지라는 단위로 분할할 데이터 적재 공간        버퍼 관리자 는 필요할때마다 디스크로부터 페이지를 가져와 기억장치에 적재하는 DBMS 의 SW 계층  이런 페이지가 모여있는 공간을 Buffer Pool 이라고 함.  버퍼 풀 내의 페이지를 Frame 이라고 하는데 페이지를 담을 수 있는 슬롯  버퍼 관리자는 버퍼 풀 에서 pin_count 와 dirty 라는 두 개의 변수를 유지  pin_count 는 현재 프레임 내에 있는 페이지를 사용하고 있는 사용자의 수  dirty 는 boolean 타입 변수로서, 페이지가 디스크로부터 버퍼 풀에 적재된 이후 수정된 적이 있는지를 나타낸다.          dirty 비트가 true 라는 것은 데이터가 변조됬다는 것을 표시      즉! 디스크에 새로 써야한다는 것을 표현한다.        처음에는 각 프레임의 pin_count 를 0으로 설정하며 dirty는 false로 설정          diry를 바꿀시에 log 에 적용하여 이를 바탕으로 데이터 베이스를 복원한다.      WAL        페이지 요청시 페이지 풀에 없을 경우 버퍼 관리자는 아래와 같은 작업을 수행          정해진 페이지 교체 알고리즘에 따라 교체 프레임 서택      프레임의 dirty 비트가 true 일경우 디스크에 저장      요청 페이지를 프레임에 로드      요청 페이지의 pin_count 를 1 증가                  이를 Pinning 이라고 한다          지금 현재 페이지를 누군가가 보고 있다.                    버퍼 교체 전략운영체제랑 거의 동일하다!      LRU (Least Recently Used)    pin_count가 0인 프레임들에 대란 포인터로 큐를 생성        Clock    LRU의 변형으로, 1부터 N 사이의 값인 current 변수를 사용하여 교체용 페이지를 선정        FIFO (First In First Out), MRU(Most Recently Used), Random등의 방식을 사용  비교  운영체제의 가상 메모리와 DBMS의 버퍼 관리자는 매우 비슷함  DBMS는 페이지 참조 패턴을 일반적인 운영체제 환경보다 더 정확히 예측해야 함          DBMS는 참조 패턴을 예측할 수 있으므로 페이지 우선 적재 전략을 사용할 수 있음        DBMS는 페이지를 디스크에 강제 출력할 수 있어야 함          손상 복구를 위한 WAL 규약을 실현할 수 있음      WAL : 로그를 적고 그것을 통해 복구 하는것      레코드  고정 길이 레코드  가변 길이 레코드고정 길이 레코드  각 필드의 길이가 고정적이고 필드의 수도 고정된 레코드 형식  필드를 레코드에 연속적으로 저장가변 길이 레코드  필드의 길이가 가변적인 경우 해당 레코드의 길이가 가변적이 됨  필드를 분리자로 구분하여 연속적으로 저장  수정시에 불이익이 존재          필드 추가시 뒤의 정보들을 모두 뒤로 이동      너무 커지면 분할할 필요가 있음      파일과 인덱스힙 파일  가장 간단한 파일 구조로, 레코드가 파일의 빈 공간에 순서 없이 저장  페이지 내의 데이터가 어떠한 형태로도 정렬되지 않으며, 파일의 모든 레코드를 검색하면 다음 레코드를 되풀이해서 요청해야 함  파일의 레코드는 각기 유일한 rid를 가지며, 한 파일에 속하는 페이지는 크기가 모두 같음  파일의 생성(Create)과 제거(Destroy), 레코드의 삽입(Insert)과 rid를 통한 레코드 삭제(Delete), rid를 통한 레코드 선택(get), 파일 내의 모든 레코드 스캔(Scan) 연산 지원인덱스  대부분의 자료 구조에서는 저장된 데이터의 rid를 직접 알 수 없음  정렬되지 않은 자료 구조에서 동등 검색을 수행할 경우, 전체 자료 구조를 스캔해야 함      인덱스(Index)    선택(Selection) 조건에 맞는 rid를 구할 수 있도록 만든 보조 자료 구조      ISAM  색인 순차 접근 방식(Indexed Sequential Access Method) 파일  데이터를 순서대로 저장하거나 특정 항목을 색인으로 처리할 수 있는 파일 처리 방법  인덱스를 순차적으로 구성하여 큰 인덱스의 성능 문제를 해결          인덱스 파일이 클 경우, 인덱스를 계층화하여 인덱스에 대한 인덱스를 생성      완전한 정적 구조로, 인덱스 계층의 페이지가 수정되지 않음        파일 구조                  인덱스 구역(비 단말 페이지)        기본 구역에 있는 레코드들의 위치를 찾아가는 인덱스가 기록되는 구역                    기본 구역(기본 단말 페이지)        실제 레코드들을 기록하는 부분으로, 각 레코드는 키 값 순으로 저장                    오버플로우 구역(오버 플로우 페이지)        기본 구역에 빈 공간이 없을 경우 새 레코드의 삽입을 위한 예비적 구역        오버플로우 구조까지 탐색을 시도 할경우 속도가 기하급수적으로 늦는다.            B+ 트리  ISAM의 오버 플로의 단점을 개선한 동적 트리 자료구조  내부 노드들이 탐색 경로를 유도하고 단말 노드들이 데이터 엔트리를 가지는 균형 트리          트리에서 삽입, 삭제를 수행해도 트리의 균형이 유지됨      레코드를 탐색할 때 루트로부터 알맞은 단말 까지만 가면 됨        일반적으로 ISAM보다 우수한 구조시스템 카탈로그  데이터베이스는 자신이 가지고 있는 모든 데이터에 대한 설명 정보를 저장함  관계형 데이터베이스 관리 시스템은 생성된 모든 릴레이션과 인덱스에 대한 정보를 유지 관리  시스템 카탈로그(System Catalog), 데이터 사전(Data Dictionary), 마스터 데이터베이스(Master Database), 메타데이터(Metadata)라고도 부름"
  },
  
  {
    "title": "6. 스키마 정제와 정규형",
    "url": "/learninghub/nhn%20academy/database/6.-%EC%8A%A4%ED%82%A4%EB%A7%88-%EC%A0%95%EC%A0%9C%EC%99%80-%EC%A0%95%EA%B7%9C%ED%98%95/",
    "categories": "NHN Academy, DataBase",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "6. 스키마 정제와 정규형(23. 10. 26)스키마 정제  정제되지 않은 스키마에서의 문제                  중복 이상        어떤 데이터는 반복적으로 저장됨                    갱신 이상        반복 저장된 데이터 중 한 투플을 갱신할 때 다른 모든 사본을 갱신하지 않으면 불일치 발생               ...",
    "content": "6. 스키마 정제와 정규형(23. 10. 26)스키마 정제  정제되지 않은 스키마에서의 문제                  중복 이상        어떤 데이터는 반복적으로 저장됨                    갱신 이상        반복 저장된 데이터 중 한 투플을 갱신할 때 다른 모든 사본을 갱신하지 않으면 불일치 발생                    삽입 이상        한 정보를 저장하려면 다른 정보도 같이 저장하여야 함                    삭제 이상        어떤 정보를 지우면 다른 정보도 같이 삭제됨              처음 설계 할 때 부터 이런 문제가 안생기게 설계하면 좋겠지만… 한계가 있음분해법  속성을 부자연스럽게 묶어서 한 릴레이션 스키마로 만들면 중복성이 발생  함수 종속(Functional Dependency)를 이용하여 상황을 식별          릴레이션을 더 작은 릴레이션의 모임으로 대치      작은 일레이션은 본래 릴레이션 속성의 부분집합으로 이루어 짐        분해의 문제          릴레이션의 분해가 필요한가?                  제안된 정규형(Normal Form)으로 분해                    분해했을 때 발생할 수 있는 문제는 무엇인가?                  무손실 조인(Lossless Join) 성질에 따라 릴레이션 인스턴스 복구          종속성 유지(Dependency Preservation) 조건에 따라 계약 조건 유지                    함수 종속  함수 종속(Functional Dependency)는 일종의 제약 조건      어떤 릴레이션 스키마를 R이라고 하고 X와 Y를 R에 속한 속성 집합이라고 하고, R의 인스턴스 r에 속한 투플 t1과 t2가 다음의 조건을 만족하면 FD X → Y가 존재한다고 한다    $t1.X = t2.X 이면 t1.Y = t2.Y$    한 릴레이션에 대해 적법한 인스턴스가 되려면 명세된 모든 FD를 만족해야 함  기본 키는 FD의 특수한 경우          키에 대한 속성은 X의 역할을 하게 되며, 나머지 속성은 Y의 역할을 함      X → Y가 만족되고 X의 진부분집합 V가 있어서 V → Y가 만족되면 X는 수퍼키이지 키는 아님            개체 집합 스키마 정제    {EmpID} → {EmpID, Name, Parkingslot, Grade, WagePerHr, Workingtime}      E        E      N       P           G       W           H        등급에 따라 시간당 임금이 결정될 경우 두 FD가 존재    E → ENGWH   G → W    부분적 함수 종속          기본 키 구성 속성의 일부에 종속되거나, 기본 키가 아닌 다른 속성에 종속되는 경우        이행적 함수 종속          함수 종속에 이행이 있을 때 (A → B, B → C = A → C) 암스트롱 공리        완전 함수 종속          함수 종속 X → Y에서 X로부터 속성 A를 제거하면 함수 종속 X → Y가 성립하지 않는 경우      즉, 임의의 속성 A ∈ X 에 대해서 Y가 (X{A})에 함수 종속되지 않는 경우      정규화  속성간의 종속성으로 인한 이상 현상이 발생하는 릴레이션을 분해하여 이상 현상을 없애는 과정  데이터의 중복 방지, 무결성을 충족하기 위한 데이터의 설계 방법  릴레이션 스키마가 어떤 정규형을 만족하는지 확인하는 테스트  정규화 원칙          무손실 법칙: 분해된 릴레이션이 표현하는 정보는 분해되기 전의 정보를 모두 포함      최소 데이터 중복 법칙: 이상 현상을 제거, 데이터 중복을 최소화      분리 법칙: 독립된 함수 종속은 독립된 릴레이션으로 분해        장점          이상 현상 해결      새 속성 추가시 데이터베이스 변경의 최소화      현실 세계의 개념간의 관게 표현      제 1정규형  도메인의 원소들이 나눌 수 없는 단위로 되어 있을 때 원자적이라고 함  어떤 릴레이션 R에 속한 모든 도메인이 원자적일 때 R은 제 1정규형이라고 한다.  1정규 형을 만족시키 못함| 학번 | 지도교수 | 학과 | 과목번호 | 성적 || — | — | — | — | — || 100 | 이순신 | 컴퓨터공학과 | C102, D103 | A, B || 200 | 홍길동 | 컴퓨터공학과 | C102 | B || 300 | 윤동주 | 기계공학과 | D102 | A || 400 | 김영랑 | 수학과 | F201 |  |  어떤 학생에 대해 성적을 얻고 싶다면… 과목번호가 원자적이지 않음.| 학번 | 지도교수 | 학과 | 과목번호 | 성적 || — | — | — | — | — || 100 | 이순신 | 컴퓨터공학과 | C102 | A || 100 | 이순신 | 컴퓨터공학과 | D103 | B || 200 | 홍길동 | 컴퓨터공학과 | C102 | B || 300 | 윤동주 | 기계공학과 | D102 | A || 400 | 김영랑 | 수학과 | F201 | C |  위 테이블은 제 1정규형을 만족한다.제 2정규형  1NF 이고 기본키에 속하지 않은 속성이 기본키에 완전 함수 종속 되는 경우  완전 함수 종속 이란?          함수 종속 X → Y에서, * X로부터 임의의 속성 A를 제거하면 X → Y가 성립되지 않는 경우 * 즉, 임의의 속성 A ∈ X에 대해서 Y가 (X {A})에 함수 종속하지 않는 경우      Grade(StudentNo, Professor, Department, SubjectID, Grade)          S          P          D           J        G| StudentNo | Professor | Department | SubjectID | Grade || — | — | — | — | — || 100 | 이순신 | 컴퓨터공학과 | C102 | A || 100 | 이순신 | 컴퓨터공학과 | C103 | B || 200 | 홍길동 | 컴퓨터공학과 | C102 | B || 300 | 윤동주 | 기계공학과 | D102 | A || 400 | 김영랑 | 수학과 | F201 | C |                              FD1 : S → PD          FD2 : J → G                                    제 2정규형으로 정규화 한다면 이거를 아래와 같이 나누면 제 2 정규형이다.                                            StudentNo              Professor              Department                                                          100              이순신              컴퓨터공학과                                      200              홍길동              컴퓨터공학과                                      300              윤동주              기계공학과                                      400              김영랑              수학과                                                                          StudentNo              SubjectID              Grade                                                          100              C102              A                                      100              C103              B                                      200              C102              B                                      300              D102              A                                      400              F201              C                                          제 3정규형  이행적 종속성(Transitive dependency) 개념에 기반          릴레이션 스키마 R에서, 후보 키가 아니고 어떤 키의 부분집합도 아닌 속성 집합 Z가 있을 때,      X → Z와 Z → Y가 만족될 때, 함수 종속 X → Y를 이행적 함수 종속이라고 부름        Codd의 정의          릴레이션 스키마 R이 2NF이고      R의 어떤 비주요 속성도 기본 키에 이행적으로 종속하지 않으면 R은 3NF에 속함        구분          R: 릴레이션 스키마, X: R에 속하는 릴레이션 인스턴스의 부분집합, A: R의 속성일 때      다음 중 하나에 속하면 제 3 정규형에 속함                  A ∈ X, 즉 평범한 함수 종속          X가 슈퍼키          A가 R의 어떤 키의 일부                      이런 이행적 함수 종속이 없는 것을 제 3정규형이라고 부른다."
  },
  
  {
    "title": "5. er model",
    "url": "/learninghub/nhn%20academy/database/5.-ER-Model/",
    "categories": "NHN Academy, DataBase",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "5. ER Model (23. 10. 26)개체 관계 데이터 모델  데이터를 개체(Entity), 속성(Attribute), 관계(Relationship)로 나타내는 데이터 모델  실 세계를 개체(Entity)라 불리는 기본 객체들과 그 객체들 사이의 관계로 인식  데이터베이스의 전체 논리적 구조를 나타내는 조직의 스키마(Enterprise Schem...",
    "content": "5. ER Model (23. 10. 26)개체 관계 데이터 모델  데이터를 개체(Entity), 속성(Attribute), 관계(Relationship)로 나타내는 데이터 모델  실 세계를 개체(Entity)라 불리는 기본 객체들과 그 객체들 사이의 관계로 인식  데이터베이스의 전체 논리적 구조를 나타내는 조직의 스키마(Enterprise Schema)를 명시함으로써 데이터베이스를 쉽게 설계하도록 개발됨  실세계의 조직의 의미와 상호작용을 개념적 스키마로 나타내는데 매우 유용함개체, 속성, 개체 집합  개체 (Entity)          실제 세계에서 다른 객체와 구별되는 유, 무형의 사물        속성(Attribute)          한 개체를 기술하기 위한 속성      개체 집합에 속한 모든 개체들은 동일한 속성을 가짐      가능한 집합을 Domain으로 설정, 식별을 위한 Key를 가진다.        개체 집합(Entity Set)          개체들의 집합      관계, 관계 집합  관계 (Relationship)          여러 개체들 사이의 연관성        관계 집합(Relationship set)          같은 유형의 관계들의 집합. n ≥ 2 개의 개체집합(중복 허용) 사이의 수학적 관계            만약 E1, E2… 들이 개체 집합일때 관계집합 R은                            ${(e1, e2,… en)          e1 ∈ E1 … en ∈ En}$                      의 부분 집합이다. 여기서 e1, e2… 는 관계  개체 집합 → 관계 집합  개체 집합은 하나의 릴레이션으로 매핑            사번      이름      주차구역번호                  1      이순신      47              2      홍길동      16      이러한 직원 테이블의 DDL 은 다음과 같다 .CREATE TABLE 직원 (\t사번\t        int,\t이름\t        varchar(10)m\t주차구역번호\tint,\tCONSTRAINT pk_employee PRIMARY KEY(사번))  이러한 둘 이상의 개체과 관련성을 말한다면 이를 관계로 연계하고 합하는 것을 관계 집합 이라고 한다.  만약 관계로 매핑한다면?  개체 집합처럼 관계집합도 관계로 매핑된다.          참여하는 각 개체 집합의 기본키 속성 (외래 키 필드의 자격)      관계 집합 자체의 설명형 속성            DDL      CREATE TABLE 근무 (  \t사번 int,  \t부서번호 int,  \t근무시작일 date,      \tCONSTRAINT pk_근무 PRIMARY KEY(사번, 부서번호),  \tCONSTRAINT fk_근무_직원 FOREIGN KEY(사번) REFERENCES 직원(사번),  \tCONSTRAINT fk_근무_부서 FOREIGN KEY(부서번호) REFERENCS 부서(부서번호)  )          CREATE TABLE 보고 (  \t상급자_사번\tint,  \t하급자_사번\tint,  \tCONSTRAINT pk_보고 PRIMARY KEY(상급자_사번, 하급자_사번),  \tCONSTRAINT fk_보고_상급자 FOREIGN KEY(상급자_사번) REFERENCES 직원(사번),  \tCONSTRAINT fk_보고_하급자 FOREIGN KEY(하급자_사번) REFERENCES 직원(사번)  )      대응 수  참여 제약 조건(Participation Constraint)을 이루는 관계 비율  대응 수(Mapping Cardinality) 또는 수비율(Cardinality Ratio)                  One-to-One        A의 한 개체는 B의 한 개체와 연관을 가지고 B의 한 개체는 A의 한 개체 연관을 가진다.                    One-to-Many        A의 한 개체는 임의의 수 (0 또는 그 이상)의 B 개체와 연관을 가진다. 그러나 B의 개체는 A의 한 개체만 연관을 가진다.                    Many-to-One        A의 한 개체는 B의 한 개체와 연관을 갖는다. 그러나 B의 개체는 A의 임의의 수 (0또는 그 이상)의 개체와 연관을 갖는다.                    Many-to-Many        A의 한 개체는 임의의 수(0 또는 그 이상)의 B 개체와 연관을 갖고 B의 한 개체도 임의의 수 (0 또는 그 이상)의 A 개체와 연관을 갖는다              수 비율이라도 불리며 관계집합을 통하여 다른 개체와 관련 될 수 있는 개체의 수를 나타낸다.키 제약 조건      키 제약 조건에 따라 대응수가 정해짐              각 부서에 한명의 부서장이 있다 → 키 제약조건      한 직원이 부서장으로 여러 부서와 관련있을 수 있지만, 각 부서는 한명의 직원만 부서장으로 관련되는것 → 일대다      한명의 직원이 여러 부서 근무 가능, 부서에는 여러명의 직원이 근무 가능 → 다대다      약 개체 집합  키가 존재하지 않는 개체집합          자신의 일부 속성과 다른 개체의 Primary Key를 조합하여야 유일하게 식별 됨      다른 개체를 식별 소유자(Identity Owner)라고 함        다음 조건들을 만족할 때 성립          식별 소유자와 약 개제 집합 사이에는 One-to-Many 관계 집합이 성립      약 개체 집합은 식별 관계집합에 전체적으로 참여하여야 함      소유자 개체에 대해 약 개제 하나를 유일하게 식별해 주는 속성 집합을 약 개체집합에 대한 구별자(discriminator) 또는 부분 키(Partial Key)라고 함        예를 들어 직원들에 대한 가족에 대한 보험증권 구매의 경우 피 부양자를 약 개체 집합 이라고 부른다.  자기 자신의 일부 속성과 다른 개체의 기본키를 조합해야만 식별 가능한 것 이때 사용되는 다른 개체를 식별 소유자 라고 불린다. 그리고 자기 자신의 일부 속성을 부분 키 라고 불린다.Specialization와 Generalization  하나의 개체 집합은 집합내의 다른 개체들과 구분되는 개체들의 하위집합을 가질 수 있음          개체 집합 내의 어떤 부분집합은 개체 집합내의 모든 개체들과 공유되지 않는 속성들을 가질 수 있음      개체 집합에 속한 세부 개체들을 세부 부류(subclass)로 분류        포함 제약 조건(Inclusion Constraint)                  중첩 제약 조건(Overlap Constraints)        두 서브 클래스에 같은 개체가 포함될 수 있는가를 결정                    포괄 제약 조건(Covering Constraints)        서브 클래스의 모든 개체를 모으면 수퍼 클래스의 모든 개체가 되어야 하는가를 결정              ISA 계층 구조 → 자바의 상속과 비슷함  만약 일반 직원 개체와 시간제 직원 개체를 만든다면 일반 개체에 시간제 직원을 자식으로 일반적인 직원의 정보와 시간제 직원 개체만의 특성을 갖는다. (상속) → 임원도 마찬가지지  하지만 Java 와 다른 포함 제약조건 이 따른다.개념적 설계 고려사항ER 모델을 이용한 개념적 설계  ER 다이어그램 개발 과정은 선택의 연속  ER 다이어그램은 데이터를 최대한 비슷하게 설명할 뿐, 모든 의미를 다 표현할 수 없음  ER 모델링은 스키마 설계에 대한 완벽한 방법이 아님개체 or 속성  속성으로 모델링 하는 경우  한 개체가 속성을 단일 값으로 가지는 경우  요구 사항에서, 수직, 수평적으로 분리될 수 없는 값인 경우  개체로 모델링하는 경우  한 개체가 여러 개의 값을 가지는 경우      ER 다이어그램에서 주소의 구조를 표현해야 하는 경우    어떤 개체 집합에 있어 속성으로 표현할 것인지 관계집합으로 표현할 것인지는 요구사항에 따라 달라진다.  만약 주소를 하나의 개체 집합으로 만들고 관계를 할 수도 있다. → 만약 직원들이 여러 주소를 가지고 있을 경우          이럴 경우 주소에 대한 질의를 작성하기도 가능하다.      개체 or 관계  개체로 모델링하는 경우          관계가 관계로 생성되는 한 개체에 국한되는 속성을 가짐      A 개체집합의 개체가 정확히 B 개체집합의 한 개체에만 해당        관계로 모델링 하는 경우          관계집합에서 중복이 발생하는 경우      두 개체 사이에 일어나는 동작을 기술하는 경우      "
  },
  
  {
    "title": "4. 과제1",
    "url": "/learninghub/nhn%20academy/database/4.-%EA%B3%BC%EC%A0%9C1/",
    "categories": "NHN Academy, DataBase",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "4. 과제(23. 10. 20)      https://github.com/gikpreet/class-relational_database/blob/main/Module%2006%20SQL/01_introduction.adoc        DatamotionMovieDatabase에서, 아래 질의들을 SQL Query 식으로 작성후 Query를 제출해주...",
    "content": "4. 과제(23. 10. 20)      https://github.com/gikpreet/class-relational_database/blob/main/Module%2006%20SQL/01_introduction.adoc        DatamotionMovieDatabase에서, 아래 질의들을 SQL Query 식으로 작성후 Query를 제출해주세요  1. 영화 ‘퍼스트 맨’의 제작 연도, 영문 제목, 러닝 타임, 플롯을 출력하세요.select ReleaseYear, Title, RunningTime, plotfrom moviewhere KoreanTitle = \"퍼스트 맨\";2. 2003년에 개봉한 영화의 한글 제목과 영문 제목을 출력하세요select Title, KoreanTitlefrom moviewhere ReleaseYear = 2003;3. 영화 ‘글래디에이터’의 작곡가를 고르세요SELECT Name from personwhere personID in (select personID\t\t\t\t\t\t\tfrom appear\t\t\t\t\t\t\twhere MovieID in ( select MovieID\t\t\t\t\t\t\t\t\t\t\t\tfrom movie\t\t\t\t\t\t\t\t\t\t\t\twhere koreanTitle = '글래디에이터') and roleID in (select roleID\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfrom role                                                                where RolekorName = '작곡'\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t));4. 영화 ‘매트릭스’ 의 감독이 몇명인지 출력하세요SELECT count(Name) from personwhere personID in (select personID\t\t\t\t\t\t\tfrom appear\t\t\t\t\t\t\twhere MovieID in ( select MovieID\t\t\t\t\t\t\t\t\t\t\t\tfrom movie\t\t\t\t\t\t\t\t\t\t\t\twhere koreanTitle = '매트릭스') and roleID in (select roleID\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfrom role                                                                                                where RolekorName = '감독'\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t));5. 감독이 2명 이상인 영화를 출력하세요select titlefrom moviewhere MovieID in (select movieid\t\t\tfrom appear\t\t\twhere RoleID in (select roleID \t\t\t\t\t\t\t from Role\t\t\t\t\t\t\t where RoleKorName = '감독')\t\t\tgroup by(MovieID)\t\t\thaving count(movieid) &gt;= 2);6. ‘한스 짐머’가 참여한 영화 중 아카데미를 수상한 영화를 출력하세요select koreantitlefrom moviewhere movieid in (select movieid\tfrom appear\twhere personid = (SELECT personid FROM DatamotionMovieDatabase.person where koreanname = '한스 짐머'))    and    movieid in (select movieid\tfrom appear\twhere appearid in (SELECT distinct(appearid) FROM DatamotionMovieDatabase.awardinvolve))7. 감독이 ‘제임스 카메론’이고 ‘아놀드 슈워제네거’가 출연한 영화를 출력하세요select Titlefrom moviewhere movieid in (select movieid\t\t\t\t   from appear\t\t\t\t\twhere (personid in (SELECT personid FROM DatamotionMovieDatabase.person where koreanname = '제임스 카메론')) and (roleID in (select roleID from role where RolekorName = '감독')))\tand    movieid in (select movieid\t\t\t\tfrom appear\t\t\t\twhere personid in ((SELECT personid FROM DatamotionMovieDatabase.person where koreanname = '아놀드 슈워제네거')) and  (roleID in (select roleID from role where RolekorName = '배우')));8. 상영시간이 100분 이상인 영화 중 레오나르도 디카프리오가 출연한 영화를 고르시오select Titlefrom moviewhere  RunningTime &gt; 100 and movieid in (select movieid\t\t\t\t   from appear\t\t\t\t\twhere (personid in (SELECT personid FROM DatamotionMovieDatabase.person where koreanname = '레오나르도 디카프리오')));9. 청소년 관람불가 등급의 영화 중 가장 많은 수익을 얻은 영화를 고르시오select koreantitlefrom moviewhere  BoxOfficeUSGross + BoxOfficeWWGross = (select MAX(BoxOfficeUSGross + BoxOfficeWWGross) from movie where GradeInKoreaID = 4 );10. 1999년 이전에 제작된 영화의 수익 평균을 고르시오select avg(BoxOfficeUSGross + BoxOfficeWWGross)from moviewhere releaseYear &lt;= 1999;11. 가장 많은 제작비가 투입된 영화를 고르시오.select max(Budget)from movie;12. 제작한 영화의 제작비 총합이 가장 높은 감독은 누구입니까?select Namefrom personwhere personid =(select a.personidfrom movie as m join appear as a on m.MovieID = a.MovieIDwhere a.roleid = 2group by PersonID limit 1)13. 출연한 영화의 모든 수익을 합하여, 총 수입이 가장 많은 배우를 출력하세요.select koreannamefrom personwhere personid = (select a.personid, m.BoxOfficeWWGross + m.BoxOfficeUSGross\t\t\t\t  from appear as a \t\t\t\t\tjoin movie as m on a.movieid = m.movieid\t\t\t\t  order by (m.BoxOfficeWWGross + m.BoxOfficeUSGross) desc                  limit 1);14. 제작비가 가장 적게 투입된 영화의 수익을 고르세요. (제작비가 0인 영화는 제외합니다)select koreantitlefrom moviewhere budget = ( select MIN(Budget)\t\t\t\t from movie\t\t\t\t where budget != 0);15. 제작비가 5000만 달러 이하인 영화의 미국내 평균 수익을 고르세요select avg(BoxOfficeUSGross)from moviewhere Budget &lt;= 5000000016. 액션 장르 영화의 평균 수익을 고르세요select avg(BoxOfficeWWGross + BoxOfficeUSGross)from moviewhere MovieID in (select MovieID\t\t\t\t  from moviegenre                  where genreID in (select GenreID from genre where genreName = 'action'));17. 드라마, 전쟁 장르의 영화를 고르세요.select titlefrom moviewhere MovieID in (select MovieID\t\t\t\t  from moviegenre                  where genreID in( (select GenreID from genre where genreName = 'Drama'))\t\t\t\t\t\t\tor                           (select GenreId from genre where genreName = 'war'));**18. 톰 행크스가 출연한 영화 중 상영 시간이 가장 긴 영화의 제목, 한글제목, 개봉연도를 출력하세요.  아카데미 남우주연상을 가장 많이 수상한 배우를 고르시오**select p.koreannamefrom person p\tjoin appear a on p.personid = a.personid\tjoin awardinvolve as award on a.appearid = award.appearid\tjoin sector as s on award.sectorid = s.SectorIDwhere s.SectorKorName = '남우주연상' and award.WinningID = 2GROUP BY p.koreannameORDER BY count(p.koreanname) DESC;20. 아카데미상을 가장 많이 수상한 영화인을 고르시오 (‘수상자 없음’이 이름인 영화인은 제외합니다)select p.koreannamefrom person as p join appear as a on p.personid = a.personid\t\t\t\t join awardinvolve as award on a.AppearID = award.appearidwhere a.roleid in (select r.roleid\t\t\t\t\tfrom role as r\t\t\t\t\twhere roleid = 6 or roleid = 7)\tand    award.WinningID = 2group by p.koreannameorder by count(p.koreanname) desclimit 1;21. 아카데미 남우주연상을 2번 이상 수상한 배우를 고르시오select p.koreannamefrom person p\tjoin appear a on p.personid = a.personid\tjoin awardinvolve as award on a.appearid = award.appearid\tjoin sector as s on award.sectorid = s.SectorIDwhere s.SectorKorName = '남우주연상' and award.WinningID = 2GROUP BY p.koreannamehaving count(p.KoreanName) &gt;= 2;23. 아카데미상을 가장 많이 수상한 사람을 고르세요.select p.koreannamefrom person as p join appear as a on p.personid = a.personid\t\t\t\t join awardinvolve as award on a.AppearID = award.appearidwhere    award.WinningID = 2group by p.koreannameorder by count(p.koreanname) desclimit 1 offset 1;24. 아카데미상에 가장 많이 노미네이트 된 영화를 고르세요.select m.Titlefrom  movie as m join appear as a on m.movieid = a.movieid\t\t\t\t join awardinvolve as award on a.AppearID = award.appearidwhere award.SectorID in (select SectorID\t\t\t\t\t\t from sector                         where SectorKorName Like '%영화%') \tand    award.WinningID = 1group by m.titleorder by count(m.Title) desc25. 가장 많은 영화에 출연한 여배우를 고르세요.select p.koreanname,count(p.personid) from appear as a \t\tjoin person as p on p.personid = a.PersonIDwhere a.roleid = ( select roleid from role where rolename = 'actress' )group by p.personid, p.koreannameorder by count(p.personid) desclimit 1;26. 수익이 가장 높은 영화 TOP 10을 출력하세요.select koreantitlefrom movieorder by BoxOfficeWWGross + BoxOfficeUSGross desclimit 10;27. 수익이 10억불 이상인 영화중 제작비가 1억불 이하인 영화를 고르시오.select koreantitlefrom moviewhere BoxOfficeWWGross + BoxOfficeUSGross &gt; 1000000000 \t  and budget &lt; 10000000028. 전쟁 영화를 가장 많이 감독한 사람을 고르세요.select p.koreannamefrom person as p\tjoin appear as a on p.personid = a.personidwhere a.roleid in (select roleid from role where rolename = 'director')\t and      a.movieid in (select movieid from moviegenre where genreid in (select genreid from genre where genrename = 'war'))group by p.koreanname, p.personidorder by count(p.personid) desclimit 1;29. 드라마에 가장 많이 출연한 사람을 고르세요.SELECT p.KoreanName ,g.GenreKorName, COUNT(*) AS cntFROM person pJOIN appear a ON a.PersonID = p.PersonIDJOIN movie m ON m.MovieID = a.MovieIDJOIN moviegenre mg ON mg.MovieID = m.MovieIDJOIN genre g ON g.GenreID = mg.GenreIDWHERE g.GenreKorName = '드라마' AND NOT p.KoreanName = '수상자 없음'GROUP BY p.PersonIDORDER BY COUNT(*) DESCLIMIT 1;30. 드라마 장르에 출연했지만 호러 영화에 한번도 출연하지 않은 사람을 고르세요.select  distinct p.personid, p.koreannamefrom person as p\tjoin appear as a on p.personid = a.personidwhere a.roleid in (select roleid from role where rolekorname = '배우')\t and      a.movieid in (select movieid from moviegenre where genreid in (select genreid from genre where genrename = 'drama'))\t and     a.personid not in ( select p.personid\t\t\t\t\t\tfrom person as p\t\t\t\t\t\tjoin appear as a on p.personid = a.personid\t\t\t\t\t\twhere a.roleid in (select roleid from role where rolekorname = '배우')\t\t\t\t\t\t and \t\t\t\t\t\t a.movieid in (select movieid from moviegenre where genreid in (select genreid from genre where genrename = 'horror')));31. 아카데미 영화제가 가장 많이 열린 장소는 어디인가요?select locationfrom awardyeargroup by Locationorder by count(location) desclimit 1;33. 첫 번째 아카데미 영화제가 열린지 올해 기준으로 몇년이 지났나요?"
  },
  
  {
    "title": "3. sql",
    "url": "/learninghub/nhn%20academy/database/3.-SQL/",
    "categories": "NHN Academy, DataBase",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "3. SQL (23. 10. 19)SQL  SQL(Structured Query Language)는 가장 널리 사용되는 상용 관계 데이터베이스 언어  IBM에서 수행한 System-R 프로젝트의 수행 결과  SQL이 발표된 후 많은 RDBMS 벤더들이 SQL을 자사 제품에 구현, 현재는 표준으로 사용됨          RDBMS 뿐만 아닌 비 관계 데...",
    "content": "3. SQL (23. 10. 19)SQL  SQL(Structured Query Language)는 가장 널리 사용되는 상용 관계 데이터베이스 언어  IBM에서 수행한 System-R 프로젝트의 수행 결과  SQL이 발표된 후 많은 RDBMS 벤더들이 SQL을 자사 제품에 구현, 현재는 표준으로 사용됨          RDBMS 뿐만 아닌 비 관계 데이터베이스에서도 SQL을 구현      ANSI/ISO등의 표준 기관에서 SQL 표준을 정의        비 절차적 언어SQL 구성  데이터 조작어(Data Manipulation Language – DML)          데이터베이스의 데이터를 조회하거나 검색하기 위한 명령 및 데이터베이스 테이블의 데이터에 변형(삽입, 수정, 삭제)을 가하는 질의어        데이터 정의어(Data Definition Language – DDL)          테이블, 무결성 등의 데이터 구조를 정의하는데 사용되는 명령어들로 데이터 구조와 관련된 질의어        데이터 제어어(Data Control Language – DCL)          데이터베이스에 접근하고 개체들을 사용하도록 권한을 주고 회수하는 질의어        트랜잭션 제어어(Transaction Control Language – TCL)          논리적인 작업의 단위를 묶어서 DML에 의해 조작된 결과를 트랜잭션별로 제어하는 질의어      DDL      CREATE    릴레이션(테이블), 뷰, 인덱스, 저장 프로시저 등 데이터베이스 객체 생성        DROP    존재하는 데이터베이스 객체 삭제        ALTER    존재하는 데이터베이스 객체 수정        TRUNCATE    테이블 내 데이터의 완전 삭제  DML  SELECT          관계 대수에서 프로젝션(Projection - π) 연산과 일치, 결과에 나타날 속성을 나열하는데 사용됨        FROM          관계 대수의 카티션 프로덕트에 해당하며, 질의에서 조회할 릴레이션을 나열        WHERE          관계대수에서 셀렉션(Selection - σ) 연산과 일치, FROM 절에 나타나는 릴레이션 속성들의 조건으로 구성      Set operationUNION  일반적으로 합집합 연산  두 SQL 질의의 결과가 합병 가능 조건이면 UNION 연산 가능  SELECT 절과는 다르게 기본적으로 중복을 제거함INTERSECT  교집합  SELECT 절과는 다르게 기본적으로 중복을 제거함  중복을 유지하고자 한다면 INTERSECT ALL 을 사용  MySQL은 릴레이션 집합 간의 교집합을 산출하는 INTERSECT 연산을 지원하지 않는다.EXCEPT  차집합  두 SQL 질의의 결과가 합병 가능 조건이면 EXCEPT 연산 가능  SELECT 절과는 다르게 기본적으로 중복을 제거함  EXCEPT ALL을 사용하여 모든 중복을 유지할 수 있음Subquery  단일 질의 안에 질의가 포함된 형태의 쿼리          관계 대수 질의 결과는 릴레이션을 반환함      서브 쿼리의 결과를 주 쿼리에서 받아서 처리는 형식으로, 포함된 쿼리(Nested Query) 라라고도 부름        서브 쿼리 (Subquery)          가장 많이 사용되는 형태로, WHERE 절에서 셀렉션 연산의 값을 산출하기 위해 사용하는 질의        인라인 뷰(Inline View)          FROM 절에서 질의의 결과를 테이블처럼 사용하는 용도의 질의        스칼라 서브 쿼리(Scala Subquery)          SELECT 문에서 사용되는 서브 쿼리로, 주로 계산 결과값을 쿼리 결과에 포함시키는데 사용되는 질의        연관 서브 쿼리          서브 쿼리에서 주 쿼리의 필드값과 연관되어 사용하는 질의      ORDER BY  데이터베이스 질의의 결과는 테이블 내의 투플의 위치(삽입된 순서)대로 산출됨  ORDER BY 절에 사용되는 컬럼을 기준으로 데이터를 정렬          오름차순(DESC)와 내림차순(ASC – 기본 값)으로 데이터를 정렬 함        limit 1 등으로 최댓값을 추출가능  offset 2 등으로 몇번 부터 출력할지도 조절 가능"
  },
  
  {
    "title": "2. 관계 모델",
    "url": "/learninghub/nhn%20academy/database/2.-%EA%B4%80%EA%B3%84-%EB%AA%A8%EB%8D%B8/",
    "categories": "NHN Academy, DataBase",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "2. 관계 모델(23.10.12)  관계 모델은 IBM 연구소의 Dr. Codd가 제안  계층형 모델과 네트워크 모델의 자리를 빠르게 대체Dr.Codd의 12법칙  규칙 0. 시스템은 데이터베이스뿐만 아니라 관리 시스템으로 서도 관계 모델의 자격을 얻어야 한다.  규칙 1. “정보 규칙” – 데이터베이스 내의 모든 정보는 한 가지 방법으로만 표시되어야...",
    "content": "2. 관계 모델(23.10.12)  관계 모델은 IBM 연구소의 Dr. Codd가 제안  계층형 모델과 네트워크 모델의 자리를 빠르게 대체Dr.Codd의 12법칙  규칙 0. 시스템은 데이터베이스뿐만 아니라 관리 시스템으로 서도 관계 모델의 자격을 얻어야 한다.  규칙 1. “정보 규칙” – 데이터베이스 내의 모든 정보는 한 가지 방법으로만 표시되어야 한다.  규칙 2. “보장된 접근 규칙” – 모든 데이터는 모호함이 없이 접근되어야 한다.  규칙 3. “널 값의 체계적인 처리” – DBMS는 각 필드에 대해 null을 처리할 수 있어야 한다.  규칙 4. “관계형 모델에 기반한 액티브 온라인 데이터베이스 카탈로그” – 시스템은 관계형 형태의 온라인 카탈로그를 제공해야 한다.  규칙 5. “종합적인 데이터 보조언어 규칙” – 시스템은 적어도 하나의 관계형 언어를 지원해야 한다.  규칙 6. “뷰 갱신 규칙” – 뷰는 시스템에 의해 갱신 가능해야 한다.  규칙 7. “고급 삽입, 갱신, 제거” – 시스템은 집합에 대해 한번에 삽입, 갱신, 제거를 지원해야 한다.  규칙 8. “물리적 데이터 독립성” – 물리적 레벨에서 변경이 일어나더라도 그 구조에 기반한 응용 프로그램은 변경되어서는 안된다.  규칙 9. “논리적 데이터 독립성” – 논리적 레벨에서 변경이 일어나더라도 그 구조에 기반한 응용 프로그램은 변경되어서는 안된다.  규칙 10. “무결성 독립성” – 무결성 제약조건들은 데이터베이스 카탈로그에 저장되어야 하며 응용 프로그램들과는 별도로 규정되어야 한다.  규칙 11. “분산 독립성” – 데이터베이스의 분산은 데이터베이스 사용자에게 영향을 주지 않는다.  규칙 12. “무전복 규칙” – 시스템이 저급 인터페이스를 제공하더라도, 그 인터페이스는 시스템을 파괴할 수 없어야 한다.Relation Schema  관계형 모델에서 데이터베이스의 구조와 제약조건에 대한 Specification          Relation 이름      필드(Field) 또는 열(Column) , 또는 속성(Attribute) 의 이름      도메인(Domain) 의 이름        개체(Entity) 와 개체의 특성을 나타내는 속성(Attribute) , 개체 간의 관계(Relation) , 이들의 제약 조건(Constraint) 을 기술한 것      명세 예시    $학생 ( 학번 : 문자열, 이름 : 문자열, 나이 : 정수 )$  Relation Instance  레코드(Record) 라고도 불리는 투플(Tuple) 의 집합  투플(Tuple)          릴레이션 스키마에서 정의된 각 속성(필드) 로 정의되며, 하나의 데이터 묶음을 나타냅      릴레이션 인스턴스에서는 각 투플을 하나의 행(row) 으로 구성        릴레이션 인스턴스의 투플 수: 카디널리티(Cardinality)  릴레이션 인스턴스의 속성(필드) 수: 차수(Degree 또는 Arity)  릴레이션 인스턴스의 투플 순서는 중요하지 않음Domain  하나의 속성이 가질 수 있는 동일한 유형의 원자값들의 집합  릴레이션 스키마는 릴레이션 인스턴스의 각 필드의 도메인을 명세(도메인 제약조건)  프로그래밍 언어 관점에서 필드의 데이터 타입을 의미      R(fi:D1, … fn:Dn) 을 릴레이션 스키마라고 하고, 각 fi, 1 ≤ i ≤ n 에 대한 이름이 Di 인 도메인에 대한 집합을 Domi 이라고 할 때, 도메인 제약조건을 만족하는 R의 인스턴스는 다음과 같이 n개의 필드를 가진 투플의 한 집합이 됨    { &lt;fi: di, … fn: dn&gt; | d1 ∈ Dom1, … dn ∈ Dom  lab  MySQL과 MySQLWorkbench 를 설치  Relation 생성          Category(CategoryNo: Integer, CategoryName: String)      Product(ProductNo: Integer, ModelNumber: String, ProductName: String, Price: float, CategoryNo: Integer)        Relation 수정          필드 데이터 수정, 테이블 이름 변경      mysql&gt; select * from Category;+------------+--------------+| CategoryNo | CategoryName |+------------+--------------+|          1 | Novel        ||          3 | History      |+------------+--------------+2 rows in set (0.00 sec)무결성 제약조건  저장된 정보의 품질에 따라 데이터베이스의 품질이 결정됨  DBMS는 부정확한 정보가 입력되는 것을 방지하는 수단을 가지고 있어야 함  무결성 제약조건(Integrity Constraint)          데이터베이스 스키마에 명세 되어 있는 조건      데이터베이스 인스턴스에 저장될 수 있는 데이터를 제한            적법한(Legal) 인스턴스    데이터베이스 스키마에 명세 된 무결성 제약조건들을 모두 만족하는 데이터베이스 인스턴스    DSBMS는 무결성 제약조건들을 집행(enforce)하여 데이터베이스를 접합하게 만듦개체 무결성  한 개체(투플)는 다른 개체들과 명확히 구분되어야 함  모든 릴레이션에 속한 필드들의 최소 부분집합이 각 투플에 대해 고유 식별자가 되어야 함  키 제약조건(Key Constraint)으로 개체 무결성을 유지          릴레이션에 속한 필드들의 최소 부분 집합이 각 투플에 고유한 식별자가 되어야 함      키 제약조건에서 투플을 식별하는 부분집합을 키(Key)라고 함        키(Key)          적법한 인스턴스의 서로 다른 두 투플은 한 키에 속하는 모든 필드 전체에 대해 동일한 값을 가질 수 없음      키를 구성하는 필드 집합의 어떠한 부분집합도 투플에 대해 유일한 식별자가 될 수 없음            수퍼 키(Super Key)    유일성을 만족하는, 필드들의 부분 집합        후보 키(Candidate Key)    유일성과 최소성을 만족하는 수퍼키 집합의 부분 집합        기본 키(Primary Key)    특정 투플을 구별하기 위해 후보 키에서 선택된 고유한 식별자  참조 무결성  한 릴레이션에 저장된 정보와 다른 릴레이션에 저장된 정보가 연결되는 경우가 대부분  참조 관계에 있는 두 릴레이션의 데이터는 항상 일관된 값으로 유지되어야 함          한 릴레이션의 데이터가 수정될 경우 참조 관계에 있는 데이터 역시 수정되어야 함      한 릴레이션의 데이터가 삭제될 경우 참조 관계에 있는 데이터 역시 삭제되어야 함        외래 키 제약조건(Foreign Key Constraint)으로 참조 무결성을 유지          한 릴레이션의 필드가 다른 릴레이션의 키를 참조      참조하는 릴레이션의 데이터 변경에 따른 무결성을 유지        외래 키(Foreign Key)          한 릴레이션의 키 중에서 다른 릴레이션의 투플을 유일하게 식별할 수 있는 키      한 릴레이션의 투플에서 다른 릴레이션의 투플을 참조하기 위해 사용            Product 테이블의 spec    Product(ProductNo: Integer, ModelNumber: String, ProductName: String, Price: float)        Category 테이블의 spec    Category(CategoryNo: Integer, CategoryName: String)        Product → Category 로 참조 설정    Product(ProductNo: Integer, ModelNumber: String, ProductName: String, Price: float, CategoryNo: Integer)          Category 의 데이터 무결성을 위해 릴레이션에 존재하지 않는 데이터는 product 릴레이션에 존재하지 않아야함.      Category 에 Science 분류가 없다면 product 릴레이션에도 Science 없어야한다.      이걸 위반하면 데이터 무결성의 문제가 생긴다.      객체 무결성  릴레이션 스키마는 릴레이션 인스턴스의 각 필드에 저장될 수 있는 데이터의 범위인 도메인을 명세  릴레이션의 각 속성(필드) 에는 범위에 지정된 일관된 데이터만 저장되어야 하며, 이를 도메인 무결성(Domain Integrity)SQL  구조적 쿼리 언어  관계형 데이터베이스 관리 시스템의 데이터를 관리하기 위해 설계  SQL 문법의 3가지 분류                  데이터 정의 언어(DDL, Data Definition Language)        데이터 정의 언어는 테이블과 인덱스 구조를 관리합니다. DDL의 가장 기본적인 요소는 CREATE, ALTER, DROP 등입니다.                    데이터 조작 언어(DML, Data Manipulation Language)        데이터 검색, 등록, 삭제, 갱신을 위해 사용되며, 가장 기본적인 요소는 SELECT, INSERT, UPDATE, DELETE 입니다. 가장 많이 사용되는 데이터베이스 언어 요소입니다.                    데이터 제어 언어(DCL, Data Control Language)        데이터베이스에서 데이터에 대한 액세스를 제어하기 위한 데이터베이스 언어 또는 데이터베이스 언어 요소이며, 기본적인 요소는 GRANT, DENY, REVOKE 입니다.            "
  },
  
  {
    "title": "11. sql 프로시저",
    "url": "/learninghub/nhn%20academy/database/11.-SQL-%ED%94%84%EB%A1%9C%EC%8B%9C%EC%A0%80/",
    "categories": "NHN Academy, DataBase",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "SQL 프로시저(23. 12. 15)SQL 루틴  SQL 프로시저 언어 구문을 포함하여 SQL로만 로직이 구현된 루틴  작성시 사용되는 CREATE 내에 해당 루틴-본문 로직을 포함함  SQL 프로시저, SQL 함수 등을 작성할 수 있음  모두 SQL에서 구현되지만 각 루틴 함수 타입에는 다른 기능이 있음  SQL 루틴은 CREATE 문을 사용  SQ...",
    "content": "SQL 프로시저(23. 12. 15)SQL 루틴  SQL 프로시저 언어 구문을 포함하여 SQL로만 로직이 구현된 루틴  작성시 사용되는 CREATE 내에 해당 루틴-본문 로직을 포함함  SQL 프로시저, SQL 함수 등을 작성할 수 있음  모두 SQL에서 구현되지만 각 루틴 함수 타입에는 다른 기능이 있음  SQL 루틴은 CREATE 문을 사용  SQL 루틴에서 함수는 반드시 값을 반환해야 한다.  ALTER 문을 사용하여 SQL 루틴 수정          DBMS에 따라 ALTER를 허용하지 않는 경우가 있음        DROP 문을 사용하여 SQL 루틴 삭제SQL 프로시저SQL 루틴은 SQL 프로시저 언어(SQL Procedural Language) statement를 포함하여 SQL로만 로직이 구현되어 있는 루틴  SQL 루틴은 SQL 호출 루틴(SQL Invoked-routine)은 프로시저(Procedure) 또는 함수(Function)의 일반적인 이름  SQL 에서 제공하는 프로그래밍 기능  쿼리문을 마치 하나의 메소드 형식으로 제작루틴의 장점  유연성  효율성  깔끔  공유MySQL  MySQL 에서 파라미터를 사용하는 저장 프로시저의 예CREATE PROC GetAricraft (\t\t\t@id int)AS\t\t\tSELECT * \t\t\tFROM Aircraft\t\t\tWHERE\t\t\t\t\t\tAircraftNo = @id  사용자 추가 저장 프로시저CREATE PROCEDURE AddUser\t@userid\tvarchar(10),\t@username varchar(10),\t@useremail varchar(50),\t@usernickname varchar(15)ASDECLARE @maxno intSELECT @maxno = MAX(UserNo) FROM UsersINSERT INTO Users VALUES(@maxno + 1, @userid, @username, @useremail, @usernickname)GO  가장 큰 UserNo를 return 하는 프로시저CREATE FUNCTION GetMaxUserNo()RETURNS intASBEGIN\tRETURN(SELECT max(UserNo) FROM Users)ENDGO  출력 파라미터를 사용하는 저장 프로시저DELIMITER $$CREATE PROCEDURE GetArticle(\tIN m_ArticleNo\tint,\tOUT m_Title\tvarchar(300),\tOUT m_Contents text,\tOUT m_WriterNickName varchar(15),\tOUT m_WriteDate datetime)BEGIN\tSELECT\t\tTitle, Contents, UserNickName, WriteDate        INTO m_Title, m_Contents, m_WriterNickName, m_WriteDate\tFROM\t\tArticle AS a INNER JOIN Users AS u ON a.WriterNo = u.UserNo\tWHERE\t\tArticleNo = m_ArticleNo;END $$DELIMITER ;저장 프로시저의 단점  처리성능이 낮다  디버깅 어려움  DB확장이 매우 힘들다."
  },
  
  {
    "title": "10. 병행성 제어",
    "url": "/learninghub/nhn%20academy/database/10.-%EB%B3%91%ED%96%89%EC%84%B1-%EC%A0%9C%EC%96%B4/",
    "categories": "NHN Academy, DataBase",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "병행성 제어(23. 12. 05)Transaction  트랜잭션(Transaction)은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미DML      SUID의 조합      예시) 사용자 A가 사용자 B에게 만원을 송금한다.      * 이때 DB 작업  - 1...",
    "content": "병행성 제어(23. 12. 05)Transaction  트랜잭션(Transaction)은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미DML      SUID의 조합      예시) 사용자 A가 사용자 B에게 만원을 송금한다.      * 이때 DB 작업  - 1. 사용자 A의 계좌에서 만원을 차감한다 : UPDATE 문을 사용해 사용자 A의 잔고를 변경  - 2. 사용자 B의 계좌에 만원을 추가한다 : UPDATE 문을 사용해 사용자 B의 잔고를 변경      현재 작업 단위 : 출금 UPDATE문 + 입금 UPDATE문  → 이를 통틀어 하나의 트랜잭션이라고 한다.  - 위 두 쿼리문 모두 성공적으로 완료되어야만 \"하나의 작업(트랜잭션)\"이 완료되는 것이다. `Commit`  - 작업 단위에 속하는 쿼리 중 하나라도 실패하면 모든 쿼리문을 취소하고 이전 상태로 돌려놓아야한다. `Rollback`          트랜잭션의 특징      원자성    모두 반영되거나 반영되지 않아야 한다.        일관성    언제나 작업의 처리 결과는 같아야한다.        독립성    둘 이상의 트랜잭션이 실행되더라도 서로에 연산에 끼어 들수 없다.        지속성    한번 처리가 되었다면 영구적으로 반영  트랜잭션의 스케줄  어떤 트랜잭션에 있는 단위작업의 리스트  DBMS가 보는 트랜잭션의 단위 작업들을 기술  각 트랜잭션에 Abort와 Commit 연산을 넣은 스케줄을 완전한 스케줄(Complete Schedule)로 부름  다른 단위 작업이 인터리빙 되지 않는 경우 직렬 스케줄(Serial Schedule)로 부름직렬 스케줄  일관적인 데이터베이스 인스턴스에 대한 효과가 완결된 트랜잭션 집합 S에 대대한 완전한 직렬 스케줄의 효과와 동등함이 보장되는 스케줄  주어진 스케줄을 수행해서 나온 데이터베이스 인스턴스는 해당 트랜잭션들을 직렬 순서대로 수행해서 나온 데이터베이스 인스턴스와 동등충돌기록 - 판독 충돌  미 완결 데이터를 읽는 경우  트랜잭션 T1이 수정한 DB 객체 A를 T1이 commit되기 전에 트랜잭션 T2가 판독 하는 경우  오손 판독이라고도 불린다.판독 - 기록 충돌  반복 불가능한 읽기를 수행  T1이 객체 A의 값을 판독 중에 T2가 A의 값을 변경하는 이유기록 - 기록 충돌  미완결 데이터를 덮어 쓰는 경우  T1이 어떤 객체 A를 수정하고 그걸 진행중인 R2가 덮어 쓰는 경우  맹목 기록이라고 부른다.Lock Mode  직렬성 보장을 위한 방법으로 데이터 객체들이 상호 베타적으로 엑세스 되도록 한다.  한 트랜잭션이 한 데이터 객체에 액세스 했을 때 다른 트랜잭션이 해당 객체를 수정하지 못하도록 함  다중 트랜잭션 환경에서 데이터베이스의 일관성과 무결성을 유지하기 위한 순차적 진행을 보장Shared Lock Mode  한 트랜잭션이 객체 A에 Shared Lock을 가지고 있으면, 다른 트랜직션에대해서도 읽기 허용  하지만 다른 트랜잭션이 Exclusive Lock을 허용하진 않는다,.  즉 독점 Lock을 불가능하게 하고 공유 공간이라고 선언Exclusive Lock  다른 트랜잭션에서 데이터를 읽을 수도, 쓸 수도 없는 잠금 모드  트랜잭션 T1이 객체 A에 Exclusive Lock을 가지고 있을 경우, Ti는 A에서 Shared Lock을 가질 수 없음  트랜잭션 T1이 객체 A에 Exclusive Lock을 가지고 있을 경우, Ti는 A에서 Exclusive Lock을 가질 수 없음  즉 Java의 Synchorized와 비슷하다.Strict 2 Phase Lock  가장 널리 사용되는 잠금 규약으로, 두 가지 규칙을 사용          트랜잭션 T가 어떤 객체를 판독(수정)하려면, 그 객체에 대해 공유(배타적) 잠금을 요청      트랜잭션이 종료될 때 가지고 있던 모든 잠금을 풀어줌        잠금 규약은 안전한 인터리빙만을 어용함Concurrency Control(DB)  DBMS는 잠금 관리자(Lock Manager)를 제공          잠금 관리자는 잠금 테이블(Lock Table)과 트랜잭션 테이블(Transaction Table)을 유지      잠금 테이블 엔트리(Lock Table Entry)로 객체에 대한 잠금 정보 관리      Deadlock  두 트랜잭션이 잠금 해제를 기다리는 관계에 사이클이 생기는 경우  논리적으로 교착상태를 막을 수 있는 방법은 없음          예방으로 프로세스의 시작을 막음      탐지로 교착상태를 검출하여 프로세스를 Kill      교착 상태 예방  트랜잭션마다 우선순위를 부여해주고 우선 순위가 낮은 트랜잭션은 우선순위가 높은 트랜잭션을 기다릴 수 없도록 하여 예방  우선 순위 지정에는 타임 스탬프를 사용          가장 오래된 트랜잭션이 가장 높은 우선순위를 가짐      교착 상태 탐지  Deadlock은 매우 드물게 발생되며, 몇 안되는 트랜잭션만 관련됨  발생 후 탐지해서 해결하는 것이 좋을 수 있음          DBMS는 주기적으로 Deadlock인지를 점검      "
  },
  
  {
    "title": "1. 데이터베이스 개요",
    "url": "/learninghub/nhn%20academy/database/1.-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EA%B0%9C%EC%9A%94/",
    "categories": "NHN Academy, DataBase",
    "tags": "sw-engineering, SW공학",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "1. 데이터베이스 개요(23.10.12)데이터와 정보  데이터 : 현실 세계로부터 단순한 관찰이나 측정을 통해서 수집된 사실이나 값  정보 : 적절한 의사결정을 위한 지식으로서 유효한 데이터의 해석 또는 데이터간의 관계  정보는 데이터를 처리해서 얻어진 결과  $I = P(D)$  데이터에서 정보를 추출하는 방법을 데이터처리, 넓은 의미로 정보처리라고...",
    "content": "1. 데이터베이스 개요(23.10.12)데이터와 정보  데이터 : 현실 세계로부터 단순한 관찰이나 측정을 통해서 수집된 사실이나 값  정보 : 적절한 의사결정을 위한 지식으로서 유효한 데이터의 해석 또는 데이터간의 관계  정보는 데이터를 처리해서 얻어진 결과  $I = P(D)$  데이터에서 정보를 추출하는 방법을 데이터처리, 넓은 의미로 정보처리라고 함데이터베이스 관리 시스템  DBMS(Database Management System)  데이터의 방대한 집합체를 유지 관리하고 이용하는데 도움을 주도록 설계된 소프트웨어  데이터의 종속성과 중복성의 문제를 해결하기 위해 제안된 시스템데이터베이스 관리 시스템의 기능  데이터 정의(Data Definition) 기능          데이터 모델과 데이터베이스를 물리적 저장 장치에 저장하는데 필요한 명세 포함      논리적 구조와 물리적 구조의 매핑을 명세        데이터 조작(Data Manipulation) 기능          사용자와 데이터베이스 사이의 인터페이스를 위한 수단 제공      사용하기 쉽고 자연스러워야 하며, 명확하고 완전해야 함      공용이라는 이유로 접근이나 처리가 비효율적 이어서는 안됨        데이터 제어(Data Control) 기능          데이터의 갱신, 삽입, 삭제 작업이 정확히 실행되며, 무결성 제공      보안과 권한 검사      동시 사용자에 대한 병행성 제어      데이터 모델  개념적 데이터 모델  논리적 데이터 모델  물리적 데이터 모델데이터 독립성  외부 스키마          각각의 사용자 수준에서 데이터 접근을 개별화하기 위한 권한을 부여      모든 데이터를 저장하는 테이블은 하나이기 때문에 개념 스키마와 물리적 스키마도 하나이지만, 같은 물리적 스키마를 기반으로 여러 개의 외부 스키마를 만들고 서로 다른 접근 권한을 설정하여 각 사용자 또는 업무 그룹별 업무 형태에 맞는 데이터만을 사용할 수 있도록 하는 스키마        논리적 스키마          개념 스키마(Conceptual Schema) 는 논리적 스키마(Logical Scheme) 라고도 부르며, 해당 데이터베이스 관리 시스템의 데이터 모델이 따라 저장될 데이터를 기술하는 스키마        물리적 스키마          물리적 스키마는 사용할 파일 조직과 검색을 위한 인덱스 등의 보조 데이터 구조등 상세한 저장 내역을 담고 있다.      물리적 스키마는 개념 스키마에 명세되어 있는 테이블들이 디스크에 어떻게 실제로 저장될 지를 요약        각 추상화 단계 별로 응용 프로그램의 데이터 구성 및 저장 방식으로부터 격리  논리적 데이터 독립성(Logical Data Independency)          데이터의 논리적인 구조, 저장 방식/공간의 변화로부터 보호        물리적 데이터 독립성(Physical Data Independency)          디스크 파일 내부에서 데이터가 실제로 어떻게 배치되어 있는지 등의 정보를 감춤      데이터 베이스 질의  데이터베이스로부터 정보를 얻는 방식의 쉬움 정도에 따라 데이터베이스의 가치가 좌우됨  데이터를 얻기 위한 일반적인 질문(Query)의 전산학적인 구현  DBMS는 일반적으로 질의(Query)를 만들 수 있는 질의어(Query Language)를 제공          데이터 조작어(DML: Data Manipulation Language)      데이터 정의어(DDL: Data Definition Language)      데이터 제어어(DCL: Data Control Language)      데이터 베이스 병행성  데이터베이스에는 수 많은 사용자가 동일한 데이터에 동시 접근함          각 사용자의 요구사항을 상호 독립적으로 수행      DBMS는 다른 사용자가 동일한 데이터에 접근하고 있다는 것을 사용자 관점에서 무시해도 되도록 동작        시스템의 장애 순간에도 일관성을 유지할 수 있도록 동작          장애 발생 순간에 동작에 참여중이던 데이터에 대한 일관성 유지      시스템이 재시동된 후 모든 데이터를 일관성 있는 상태로 유지해야 함      Transaction  분해가 불가능한 프로그램의 실행단위  ACID                  Atomicity (원자성)        관련 작업이 전부 처리되거나 아예 처리되지 않아야 함                    Consistency(일관성)        트랜잭션 이전과 이후에 데이터베이스의 상태는 이전과 같이 유효해야 함                    Isolation(격리성)        모든 트랜잭션은 다른 트랜잭션들로부터 독립되어 동작해야 함                    Durability(지속성)        트랜잭션이 성공적으로 수행되었다면 완료의 효과는 지속되어야 함              원자성과 지속성을 위해 데이터베이스 로그(Log)와 로그 우선 기록(Write Log Ahead)을 사용  격리성을 위해 잠금 규약(Locking Protocol)을 사용  일관성을 위해 제약 조건(Constraint)을 사용"
  },
  
  {
    "title": "Thread   thread state",
    "url": "/learninghub/nhn%20academy/cs/Thread-thread-state/",
    "categories": "NHN Academy, CS",
    "tags": "CS, NHN Acedemy, Thread",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Thread - Thread State (23. 10. 19)Thread의 상태 6가지| 상태 | 설명 || — | — || NEW | thread가 실행 준비를 완료한 상태로, start() 함수를 호출하기 전 상태 || RUNNABLE | start()가 호출되어 실행될 수 있는 상태 || RUNNING | 해당 thread가 동작중인 상태 || ...",
    "content": "Thread - Thread State (23. 10. 19)Thread의 상태 6가지| 상태 | 설명 || — | — || NEW | thread가 실행 준비를 완료한 상태로, start() 함수를 호출하기 전 상태 || RUNNABLE | start()가 호출되어 실행될 수 있는 상태 || RUNNING | 해당 thread가 동작중인 상태 || WAITING | 다른 thread가 통지할 때까지 기다리는 상태 || TIMED_WAITING | 정해진 시간 동안 기다리는 상태 || BLOCKED | 사용하고자 하는 객체의 잠금(lock)이 풀릴 때까지 대기하는 상태 || TERMINATED | 실행이 종료된 상태 |  new새로운 Thread 객체가 생성 되었지만 실행되기전Thread thread = new Thread();System.out.println(thread.getState());NEW  RUNNABLE언제든지 실행준비가 된 threadr을 start() 시키고 getState() 한다.RunableCounter r = new RunableCounter(\"ddd\", 5);r.start();System.out.println(r.getThread().getState());RUNNABLEddd : 1ddd : 2ddd : 3ddd : 4...  RUNNUNG한 thread가 RUNNING이라면 다른 thread는 RUNNABLE, WATING등을 실행이 아닌 상태를 갖는다.  BLOCKEDSynchronized block을 다른 thread가 점유하고 있는 경우 기다리고 있는 상태  TERMINATEDThread가 종료된 상태  TIMED_WAITINGWAITING과 동일하지만, 제한시간 설정이 가능BLOCKED vs WATING            WAITING      BLOCKED                  thread는 wait() 또는 join()을 호출할 때 WAINTING 상태가 된다. thread는 다른 thread가 notify() 또는 notifyAll()을 호출할 때까지 WAITING 상태를 유지한다.      thread는 다른 thread에서 알림을 받았지만, 아직 object 잠금이 설정되지 않은 경우 이 상태가 된다.              WAITING thread는 다른 thread의 알림을 기다리고 있다.      BLOCKED thread는 다른 thread가 잠금을 해제하기를 기다리고 있다.              WAITING thread가 중단될 수 있다.      BLOCKED thread는 중단될 수 없다      Thread 상태 제어  interrupt() :  WAITING → RUNNABLE  notify() : wait() 에 의한 WAITING → RUNNABLE  sleep() : 주어진 시간동안 thread를 TIMED_WAITING      join() : join()을 요청할 thread가 종료 할 때까지 대기      counter1.start();  counter2.start();  counter1.getThread().join();  counter2.getThread().join();        wait() : Synchonized block에서 thread를 WAITING 상태로 만든다."
  },
  
  {
    "title": "Thread   synchronization",
    "url": "/learninghub/nhn%20academy/etc/Thread-synchronization/",
    "categories": "NHN Academy, ETC",
    "tags": "CS, NHN Acedemy, Thread",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Thread - synchronization(23. 10. 18)Thread 멈추기  Thread() 는 run() 에 의해 시작되지만 종료 명령어는 없다.  과거에는 stop() 이 있었지만 데드락, 내부 리소스 정리 등 문제로 삭제  Thread의 안전한 종료를 위해 안전하게 스스로 종료할 수 있게 구현상태 제어 이용하기  Thread 안에서 내부...",
    "content": "Thread - synchronization(23. 10. 18)Thread 멈추기  Thread() 는 run() 에 의해 시작되지만 종료 명령어는 없다.  과거에는 stop() 이 있었지만 데드락, 내부 리소스 정리 등 문제로 삭제  Thread의 안전한 종료를 위해 안전하게 스스로 종료할 수 있게 구현상태 제어 이용하기  Thread 안에서 내부 상태 제어가 가능하다  안전하게 종료하는법                  flag 변수로 제어하기          boolean runnuingflag = true;              RunableCounter(String str, int counter) {          this.str = str;          this.maxCount = counter;      }              @Override      public void run() {          while (runnuingflag) {              try {                  if (counter == 59)  \t\t\t\t\t\t...  \t\t\t\t}  \t}                            interrupt() 를 활용          public void run() {          while (!Thread.currentThread().isInterrupted()) {              try {                        System.out.println(str + \" : \" + counter++);  \t\t\t\t\t\t\t\t...  \t\t\t}  }                    Thread 동시성 제어  하나의 Process내에서 자원을 공유하는 여러 스레드의 문제점은 어떤게 있을까  Race Condition          둘 이상의 thread가 동시에 공유 자원에 접근 할 시 발생              [SharedCounter.java](http://SharedCounter.java)          public class SharedCounter extends Thread {      SharedCount sharedCount;      int count;      int maxCount;              public SharedCounter(String name, int maxCount, SharedCount sharedCount) {          setName(name);          this.sharedCount = sharedCount;          this.maxCount = maxCount;          count = 0;      }              @Override      public void run() {          while (count &lt; maxCount) {              count++;              sharedCount.increment();          }      }  }                  public class SharedCount {      int count;              public int getCount() {          return count;      }              public void setCount(int count) {          this.count = count;      }              public void increment() {          setCount(getCount() + 1);      }  }                  SharedCount sharedCount = new SharedCount();          SharedCounter counter1 = new SharedCounter(\"counter1\", 10000, sharedCount);          SharedCounter counter2 = new SharedCounter(\"counter2\", 10000, sharedCount);                  counter1.start();          counter2.start();          sharedCount : 14047  ...  sharedCount : 14375                    결과는 20000을 예상하지만 실행할때마다 다른 결과가 나타난다.      counter1 이 1을 추가하고 메모리에 적었지만 counter2 가 곧이어 다시 써버려서 counter1이 덮어진다      이러한 구역을 임계 구역 이라고 부른다.      이러한 문제를 해결하기 위해 상호 배제 를 사용 → 공유 자원의 접근을 나의 process나 thread로 제한        Deadlock          공유 자원의 접근 권한 등으로 통제하던 도중 반환 관계가 꼬임으로써 발생      Hold and Wait                  P1이 R1 을 기다리고 있는 도중 P2가 R1를 실행하던 도중 R2도 사용할 필요가 있음 하지만 P3이 R3을 사용하고 있을 경우… R1은 언제 P1을 사용할 수 있을까…                    Circular Wait                  위의 Hold and Wait가 순환 형태를 이루고 있는 경우          식사하는 철학자가 대표적인 문제                    Starvation                  다른 process나 thread가 지속적으로 한 resource를 가짐으로써 다른 thread가 계속해서 접근 권한을 얻지 못할 경우에 발생 → 무한한 대기 상태                    Licelock                  접근이 없는 권한의 경우 해당 자원 대신에 다른 자원을 수행하고 있는 것          해당 작업만 처리되지 못하고 나머지 작업은 처리 되는 것의 차이를 가지고 있다.                    SynchronizedJava에서 thread 동기화를 위해 synchronized 적용 가능한 곳  Instance methods  Static methods  Code blocks위의 SharedCount.java에 Synchronized 키워드를 적용synchronized public void increment() {        setCount(getCount() + 1);    }sharedCount : 20000  정상적으로 sharedCount가 나타남을 볼 수 있다.      static 을 사용해서 싱글톤 패턴 흉내      public class SharedCount {      static int count;          public static int getCount() {          return count;      }          public static void setCount(int count) {          SharedCount.count = count;      }          static synchronized public void increment() {          setCount(getCount() + 1);      }  }        thread safety가 더 강화됨을 확인할 수 있다.  Synchronization Control  이러한 병행성의 제어를 위해 wait 과 notify 지원  wait()          어떠한 thread가 자신의 제어권을 양보하고 WATING 상태에서 대기하는 명령어      notify() 를 호출함으로써 RUNNABLE 상태로 변경        notify()          WAITING 상태에 있는 영역을 RUNNABLE로 변경 하는 역할      멀티 스레드 환경에서는  Java는 multi-thread 언어이므로, 이러한 동기화는 상호배제를 달성하는 좋은 방법이다.  변수에는 synchronized 를 적용할 수 없다.  synchronized block의 object가 null인 경우는 null point exception을 발생  Java 동기화는 동시 읽기를 허용하지 않는다.  synchronized method는 매우 느리다."
  },
  
  {
    "title": "Thread   pool, daemon",
    "url": "/learninghub/nhn%20academy/cs/Thread-pool,-daemon/",
    "categories": "NHN Academy, CS",
    "tags": "CS, NHN Acedemy, Thread",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Thread - pool, daemon (23. 10. 19)Thread Pool  자바 thread pool은 여러개의 thread를 만들어 놓고 재사용되는 thread 그룹을 말한다.  task가 있다면 pool 에 넣고 모든 pool의 thread가 가득 찼다면 빈 thread가 생길 떄까지 대기한다.      Thread pool 생성 및 실행...",
    "content": "Thread - pool, daemon (23. 10. 19)Thread Pool  자바 thread pool은 여러개의 thread를 만들어 놓고 재사용되는 thread 그룹을 말한다.  task가 있다면 pool 에 넣고 모든 pool의 thread가 가득 찼다면 빈 thread가 생길 떄까지 대기한다.      Thread pool 생성 및 실행    ExecutorService threadpool = Executors.newCachedThreadPool();    threadpool.execute(w);  Thread Pool의 장점  Thread 생성과 삭제에 따른 시간과 자원을 줄일 수 있음Thread Pool 사용 시 주의할 점  Deallock          다양한 thread가 돌아가기에 교착 상태 발생 가능성        Thread Leakage          비정상 종료에 의한 종료        Resource Thrasing          너무 큰 thread pool의 경우 context 전환 비용 증가      Thread Group  Java는 단일 Object에서 여러 thread를 그룹화 가능      group 전체를 pasue, resume 가능      ThreadGroup threadGroup = new ThreadGroup(\"Group\");      RunableCounter runableCounter1 = new RunableCounter(threadGroup, \"run1\", 5);  RunableCounter runableCounter2 = new RunableCounter(threadGroup, \"run2\", 5);      runableCounter1.start();  runableCounter2.start();      Thread.sleep(2999);  threadGroup.interrupt(); // 그룹의 모든 스레드 일괄 종료       DaemonUser Thread vs Daemon Thread  java에서 thread는 user thread 와 daemon thread로 나뉜다.  User thread는 특별히 daemon thread로 설정하지 않은 thread로서 일반적으로 생성해서 사용되는 thread이다.  JVM은 모든 user thread가 종료될 때까지 프로그램을 실행한다.  Daemon thread는 백그라운드에서 동작하는 thread로, user thread가 종료될 때 자동으로 종료된다.  주로 main thread나 다른 user thread의 보조 역할을 수행하거나, 특정 작업을 주기적으로 처리하는 thread 등에 사용된다.      JVM은 모든 user thread가 종료되면 daemon thread를 강제로 종료합니다.      ThreadGroup threadGroup = new ThreadGroup(\"Group\");      RunableCounter runableCounter1 = new RunableCounter(\"run1\", 5);  RunableCounter runableCounter2 = new RunableCounter(\"run2\", 5);      runableCounter2.getThread().setDaemon(true);  runableCounter1.start();  runableCounter2.start();      runableCounter1.getThread().interrupt();              runableCounter2 를 daemon으로 설정 한다.              runableCounter1 은 유일한 thread가 되었고 곧이어 interrupt 할시 유일한 user thread가 종료되었기에 데몬도 종료된다.          RunableCounter runableCounter1 = new RunableCounter(\"run1\", 5);  RunableCounter runableCounter2 = new RunableCounter(\"run2\", 5);  RunableCounter runableCounter3 = new RunableCounter(\"run3\", 5);          runableCounter2.getThread().setDaemon(true);  runableCounter1.start();  runableCounter2.start();  runableCounter3.start();                    이렇게 수정할 경우 user thread가 아직 존재하기에 daemon thread가 죽지 않는다.      정리  모든 thread의 생성과 종료를 직접 관리하지 않을 수도 있다.  Deamon thread의 우선 순위는 낮으나 조정 가능하다."
  },
  
  {
    "title": "Thread   basic thread",
    "url": "/learninghub/nhn%20academy/etc/Thread-basic-thread/",
    "categories": "NHN Academy, ETC",
    "tags": "CS, NHN Acedemy, Thread",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Thread - basic thread(23.10.17)  Process vs Thread  Thread 클래스 만들기  Runnable 인터페이스 활용  Pipe 구현Process vs Thread  Process          실행 중인 프로그램      스케줄링의 대상이 되는 작업과 같은 의미      프로그램이 실행하는데 필요한 모든 자원들을...",
    "content": "Thread - basic thread(23.10.17)  Process vs Thread  Thread 클래스 만들기  Runnable 인터페이스 활용  Pipe 구현Process vs Thread  Process          실행 중인 프로그램      스케줄링의 대상이 되는 작업과 같은 의미      프로그램이 실행하는데 필요한 모든 자원들을 개별적으로 가지고 있음      개별 메모리로 통신에 어려움        Thread          각 thread별로 Stack과 Register 를 가지고 있음      개별적으로 분리 가능한 최소한의 자원만 가지고 있음      공유 메모리 사용으로 통신에 용이      Single Thread Vs. Multi Thread  Single Tread          Main 쓰레드에서 작업 진행      하나의 Process에 오직 하나의 Thread      동시성에 관리        Multi Thread          프로그램 내에서 두 개 이상의 동작을 동시에 실행      하나의 프로세스를 다수의 실행 단위로 구분하여 자원 공유      수행 능력 향상      Thread 클래스 확장  목표      단일 스레드 환경에서 여러 작업 실행해 문제점을 확인    Thread 클래스를 확장 시켜 스레드로 동작하는 클래스 생성    확장된 Thread 클래스를 통해 여러 작업을 동시 실행  실습      연습 1-1. Counter클래스인 인스턴스를 동시에 2개 실행해 확인하기      public class myThread {      public static void main(String[] args) {          Counter counter1 = new Counter(\"Counter1\");          Counter counter2 = new Counter(\"Counter2\");              counter1.run();          counter2.run();                  }  }          public class Counter  {                String name;          int count = 0;              public Counter(String name) {              this.name = name;              count++;          }              public void run() {              while (!Thread.interrupted()) {                      delay(1);                  System.out.println(this.name + \" : \" + count++);                }          }              public void delay(int time) {              try {                  Thread.sleep(time);              } catch (InterruptedException e) {                  e.printStackTrace();              }          }          }          Counter1 : 1346  Counter1 : 1347  Counter1 : 1348  Counter1 : 1349  ...              왜 Counter1 만 실행될까?                  하나의 프로그램은 하나의 main()만 실행된다고 한다. Counter1.run()의 메소드가 점유하고 있기에 이러한 현상이 나타난다고 생각…                          실습 1-2. CounterThread 클래스를 만들어 스레드 동작 확인하기      public class myThread {      public static void main(String[] args) {          Counter counter1 = new Counter(\"Counter1\");          Counter counter2 = new Counter(\"Counter2\");              counter1.start(); // run() -&gt; start()로 변경          counter2.start();      }  }          public class Counter extends Thread {                String name;          int count = 0;              public Counter(String name) {              this.name = name;              count++;          }              public void run() {              while (!Thread.interrupted()) {                      delay(1);                  System.out.println(this.name + \" : \" + count++);                }          }              public void delay(int time) {              try {                  Thread.sleep(time);              } catch (InterruptedException e) {                  e.printStackTrace();              }          }          }          Counter2 : 1616  Counter1 : 1616  Counter2 : 1617  Counter1 : 1617  ...              두 쓰레드가 병행 실행됨을 확인            실습 1-3. Counter 클래스의 인스턴스와 CounterThread 클래스의 인스턴스를 동시에 실행해 확인하기      public class myThread {      public static void main(String[] args) {          CounterThread counterThreead = new CounterThread(\"CounterThread\");          Counter counter = new Counter(\"no Thread\");          counterThreead.start();          counter.run();      }  }          public class Counter {                String name;          int count = 0;              public Counter(String name) {              this.name = name;              count++;          }              public void run() {              while (!Thread.interrupted()) {                      delay(1);                  System.out.println(this.name + \" : \" + count++);                }          }              public void delay(int time) {              try {                  Thread.sleep(time);              } catch (InterruptedException e) {                  e.printStackTrace();              }          }          }      class CounterThread extends Thread {                String name;          int count = 0;              public CounterThread(String name) {              this.name = name;              count++;          }              public void run() {              while (!Thread.interrupted()) {                      delay(1);                  System.out.println(this.name + \" : \" + count++);                }          }              public void delay(int time) {              try {                  Thread.sleep(time);              } catch (InterruptedException e) {                  e.printStackTrace();              }          }          }          no Thread : 1072  CounterThread : 1073  no Thread : 1073  no Thread : 1074  CounterThread : 1074  no Thread : 1075  CounterThread : 1075  no Thread : 1076  CounterThread : 1076  no Thread : 1077  CounterThread : 1077  no Thread : 1078  CounterThread : 1078  ...              CounterThread와 no Thread가 병행 실행됨.      정리. Thread 클래스의 활용  Thread 클래스를 확장하여 스레드를 생성할 수 있다.  Thread 클래스 인스턴스는 실행시 개별 스레드를 생성하여 동작하여, 하나 이상의 스레드 생성이 가능하다.  프로그램이 시작되는 main 함수도 하나의 스레드로 동작한다Runnable 인터페이스 구현  클래스 상속 외에 Runnable 인터페이스로도 구현 가능      자바는 단일상속이기에  Thread 사용시 다른 클래스를 상속 받지 못함        실습 2-1 RunnableCounter 인터페이스 구현      public class RunableCounter implements Runnable {      int counter = 0;      int maxCount = 0;      String str = \"\";          RunableCounter(String str, int counter) {          this.str = str;          this.maxCount = counter;      }          @Override      public void run() {          while (counter &lt; maxCount) {              System.out.println(str + \" : \" + counter++);          }      }  }          public class myThread {      public static void main(String[] args) {          System.out.println(\"Thread 생성! \");          Thread thread = new Thread (new RunableCounter(\"runnableCounter\" , 10));          thread.start();      }  }            실습 2-1 CounterRunnable 클래스의 인스턴스를 동시에 2개 실행해 확인하기      public class myThread {      public static void main(String[] args) {          CounterRunnable counterRunnabl1 = new CounterRunnable(\"CounterRunnable1\");          CounterRunnable counterRunnabl2 = new CounterRunnable(\"CounterRunnable2\");              Thread thread1 = new Thread(counterRunnabl1);          Thread thread2 = new Thread(counterRunnabl2);              thread1.start();          thread2.start();      }  }          public class CounterRunnable implements Runnable  {      String name;      int count;          public CounterRunnable(String name) {          this.name = name;      }          public void run() {          while (!Thread.interrupted()) {              delay(1000);              System.out.println(this.name + \" : \" + count++);          }      }          public void delay(int time) {          try {              Thread.sleep(time);          } catch (InterruptedException e) {              e.printStackTrace();          }      }  }          CounterRunnable1 : 0  CounterRunnable2 : 0  CounterRunnable1 : 1  CounterRunnable2 : 1  CounterRunnable1 : 2  ...            연습 2-2. CounterRunnable 클래스를 CounterThread 클래스와 동일하게 구성 후 결과 확인하기      public class myThread {      public static void main(String[] args) {          CounterRunnable counterRunnabl1 = new CounterRunnable(\"CounterRunnable1\");          CounterRunnable counterRunnabl2 = new CounterRunnable(\"CounterRunnable2\");              counterRunnabl1.start();          counterRunnabl2.start();      }  }          public class CounterRunnable implements Runnable  {      String name;      int count;      Thread thread;          public CounterRunnable(String name) {          this.name = name;          thread = new Thread(this);      }          public void start() {          thread.start();      }          @Override      public void run() {          while (!Thread.interrupted()) {              System.out.println(this.name + \" : \" + ++count);              delay(1000);          }      }          public void delay(int time) {          try {              Thread.sleep(time);          } catch (InterruptedException e) {              e.printStackTrace();          }      }  }          CounterRunnable1 : 1  CounterRunnable2 : 1  CounterRunnable1 : 2  CounterRunnable2 : 2  ...              Thread를 Runnable 객체에 Thread 인스턴스 변수를 사용해서 관리      Start는 객체 메소드로 선언 후 해당 Thread를 start() 하게 관리      문제점  main() 이 먼저 종료 한다.                  thread.join() 을 활용해서 main 을 대기시킨다.          try {          thread.start();          thread.join();          } catch (InterruptedException e) {              e.printStackTrace();          }                          Thread의 실행 순서는 어떻게 결정되는걸까?      thread1.start();  thread2.start();  thread3.start();  thread4.start();      mycounter4 : 0  mycounter3 : 0  mycounter2 : 0  mycounter1 : 0  mycounter4 : 1  mycounter1 : 1  mycounter2 : 1  mycounter3 : 1        아마 랜덤 인것 같다….          join 사용          try {          thread1.start();          thread1.join();          thread2.start();          thread2.join();          thread3.start();          thread3.join();          thread4.start();          thread4.join();          } catch (InterruptedException e) {              e.printStackTrace();          }      mycounter1 : 0  mycounter1 : 1  mycounter1 : 2  mycounter1 : 3  mycounter1 : 4        → 실행 순서 보장 완료!  Class 내에서 Thread를 field로 포함  Runnable interface를 구현하는 class가 필요함 이걸 class내에 Thread Instance로 관리  자신이 Thread를 관리하므로 더 많은 처리가 가능      예시 소스 코드 (SelfRunnableCounter.java)```javapublic class SelfRunnableCounter implements Runnable {  int count;  int maxCount;  Thread thread;    SelfRunnableCounter(String name, int maxCount) {      this.maxCount = maxCount;      count = 0;      thread = new Thread(this, name);  }    public void start() {      thread.start();  }    @Override  public void run() {      while (count &lt; maxCount) {          try {              System.out.println(count++);              thread.sleep(1000);          } catch (InterruptedException e) {              Thread.currentThread().interrupt();          }      }  }}  Thread의 Interrupt  Interrupt에 대해서 더 알아보기…          Thread는 여러 상황에서 Interrupt 를 통해 통제한다.      특정 스레드에게 작업을 멈춰달라고 요청하는 기능      Interrupt를 다룰 수 있는 메소드                  interrupt : 해당 스레드에게 인터럽트를 검.          isInturrupted : 해당 스테드가 인터럽트가 걸려 있는지를 확인          static interrupted : 현재 해당 스레드의 인터럽트를 해제하고 해제하기 이전의 값이 무엇인지를 return 또한 인터럽트를 해제할 수 있음.                    while (!Thread.interrupted()) 같은 경우 이전에 Thread가 인터럽트 상태였다면 True를 반환 그리고 스레드의 인터럽트를 해제하고 반복문은 종료, 하지만 인터럽트 상태가 아니였다면 False를 반환 반복문은 멈추지 않는다.              만약에 어디서 누군가가 interrupt를 건다면…?          public class CounterRunnable implements Runnable  {      String name;      int count;      Thread thread;              public CounterRunnable(String name) {          this.name = name;          thread = new Thread(this);      }              public void start() {          thread.start();      }              @Override      public void run() {          while (!Thread.interrupted()) {              System.out.println(this.name + \" : \" + ++count);              delay(1000);          }          System.out.println(\"Interrupted!\");      }              public void delay(int time) {          try {              Thread.sleep(time);              thread.interrupt(); // 쓰레드에게 인터럽을 걸어버림! 작업을 멈춰라.          } catch (InterruptedException e) {              e.printStackTrace();          }      }  }                    정리. Runnable 인터페이스의 활용  CounterRunnable 인터페이스를 이용해 스레드 활용이 가능하다.  실제 활용은 인터페이스 구현시 Thread 클래스와 동일하게 run() 함수 재정의로 구현한다.  Thread 클래스 확장과는 달리 별도의 Thread 인스턴스 생성이 필요하지만, 클래스 구현 단계에서 해결 가능하다.스레드 상태| 상태 | 설명 || — | — || NEW | 생성되었지만 아직 start() 메소드가 호출되지 않은 상태 || RUNNABLE | 실행 대기 중인 상태 || BLOCKED | 락(lock)을 획득하지 못해 실행을 멈춘 상태 || WAITING | 다른 스레드에 의해 특정 조건이 충족될 때까지 대기하는 상태 || TIMED_WAITING | 일정 시간 동안 대기하는 상태 || TERMINATED | 실행이 종료된 상태 |  스레드간의 상태 확인은 Pipe로 연결된다.  Pipe를 통해 데이터는 임의의 시간 간격으로 데이터를 집어넣는다.          만약 Pipe가 채워져 있다면 대기한다.        Pipe를 통해 데이터를 받는다.          만약 Pipe가 비워져 있다면 대기한다.        두 스레드간 Pipe 로 데이터를 전송하는 클래스          Pipe.java          package Thread;      import java.util.LinkedList;  import java.util.Queue;      public class Pipe {      private int data;      private boolean empty = true;  //    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();          public synchronized int receive() {              if (empty) { // 비어있으니 wait()              try {                wait();              } catch (InterruptedException e) { }          }               empty = true;          notifyAll();              try {              Thread.sleep(1000);          } catch (InterruptedException e) {              Thread.currentThread().interrupt();          }          System.out.println(\"파이프의 \" + this.data + \" 내보냄 \");        \treturn data;      }          public synchronized void send(int data) {              if (!empty) { // 뭐가 있으니깐 wait()              try {                wait();              } catch (InterruptedException e) { }          }                      empty = false;          notifyAll();              try {              Thread.sleep(1000);          } catch (InterruptedException e) {              Thread.currentThread().interrupt();          }          this.data = data;          System.out.println(\"파이프에 \" + this.data + \" 저장 \");      }  }              Reciver.java          package Thread;      import java.lang.Thread.State;  import java.time.LocalDateTime;  import java.util.concurrent.ThreadLocalRandom;  import javax.sound.midi.Track;      public class Receiver implements Runnable {      final Pipe pipe;  \t\tint endData = 10;      Thread thread;            public Receiver(Pipe pipe, int endData) {          this.pipe = pipe;          thread = new Thread(this);      }          public void start() {          thread.start();      }          public State getState() {        return thread.getState();      }          public void run() {        // Pipe에서 데이터를 기다리며, 수신된 데이터가 endData이면 종료한다.       \t// 수신된 데이터가 endData가 아닌 경우, 임의의 시간을 기다린다.             while (!Thread.interrupted()) {            int data = pipe.receive();            if (endData == data) {                /*                 try {                  System.out.print(\"모든 데이터 수신 완료\");                  thread.join();                                    } catch (InterruptedException e) {                  e.printStackTrace();                }                */                thread.interrupt();                System.out.print(\"reciver는 모든 데이터를 수신하였습니다. reciver 스레드 종료.\");            } else {                  try {                    System.out.println(\"데이터 \" + data + \" 도착\");                    Thread.sleep(1000);                  } catch (InterruptedException e) {                    Thread.currentThread().interrupt();                  }              }          }            }  }              Sender.java          package Thread;      import java.lang.Thread.State;  import java.util.concurrent.ThreadLocalRandom;      public class Sender implements Runnable {      final Pipe pipe;      int[] data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};      int dataIndex = 0;      Thread thread;          public Sender(Pipe pipe) {          this.pipe = pipe;          thread = new Thread(this);      }          public void start() {          thread.start();      }          public State getState() {        return thread.getState();      }          public void run() {        // pipe를 통해서 데이터를 전송한다.            while (!Thread.interrupted()) {                        pipe.send(data[++dataIndex]);            if (dataIndex == 10) {              thread.interrupt();              System.out.println(\"sender는 모든 데이터를 전송하였습니다. sender 쓰레드 종료\");            }          try {               Thread.sleep(1000);          } catch (InterruptedException e) {               Thread.currentThread().interrupt();          }         }                // 전송에 성공하면 일정시간 기다린다.      }  }      "
  },
  
  {
    "title": "Socket",
    "url": "/learninghub/nhn%20academy/etc/Socket/",
    "categories": "NHN Academy, ETC",
    "tags": "CS, NHN Acedemy",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Socket(23. 10. 23 ~ 24)Socket이란?  Network에서 정보가 전송되는 고유 식별자  송신 또는 수신 프로세서가 위치한 host에 의해 식별  운영 체제에서 스풀링되는 물리적인 장치로의 I/O  기본 특성이 변경되지 않았지만, 액세스가 제한되고 mapping 알고리즘(예: 디바이스 주소 매핑 또는 가상 미니 디스크에서의 실린더 ...",
    "content": "Socket(23. 10. 23 ~ 24)Socket이란?  Network에서 정보가 전송되는 고유 식별자  송신 또는 수신 프로세서가 위치한 host에 의해 식별  운영 체제에서 스풀링되는 물리적인 장치로의 I/O  기본 특성이 변경되지 않았지만, 액세스가 제한되고 mapping 알고리즘(예: 디바이스 주소 매핑 또는 가상 미니 디스크에서의 실린더 이동)에 의해 변환된 물리적인 장치  운영 체제에서 유지 관리되는 디렉터리와 액세스 방법을 통해 파일 시스템에 액세스  프로세스 간 통신을 위한 절차  Network protocol에서 정의된 기계 간 통신을 위한 절차Socket TypeDatagram Sockets  UDP(User Datagram Protocol)를 사용하는 무연결 socket  Datagram socket에서 보내거나 받은 packet은 개별적으로 주소가 지정되고 라우팅됨  Datagram socket에서는 순서와 신뢰성이 보장되지 않으므로 한 기계 또는 프로세스에서 다른 기계로 전송되는 여러 packet이 임의의 순서로 도착하거나 전혀 도착하지 않을 수 있음Stream Sockets  Connection-oriented Sockets  TCP(Transmission Control Protocol)  SCTP(Stream Control Transmission Protocol)  DCCP(Datagram Congestion Control Protocol)  오류 없는 데이터 전송, packet 순서, 흐름 제어 보장  인터넷에서 일반적으로 TCP를 사용하여 구현되므로 응용 프로그램이 TCP/IP 프로토콜을 사용하여 네트워크를 통해 실행될 수 있음  송신된 순서에 따라 중복되지 않게 데이터를 수신함으로 이에 따른 overhead 발생Raw Sockets  프로토콜별 전송 계층 형식 없이 IP packet을 직접 보내고 받을 수 있음  전송 계층 프로토콜(예: TCP, UDP)에 상관없이 IP packet으로 주고 받음  Berkeley sockets[1]을 기반으로 하는 API는 raw sockets을 지원하며, 윈도우 XP는 2001년 윈삭 인터페이스에 구현된 raw sockets 지원을 통해 출시되었으나, 3년 후 마이크로소프트는 보안상의 문제로 row sockets 지원을 제한  Nmap[2]과 같은 보안 관련 응용 프로그램에서 사용  일반적으로 네트워크 장비에서 사용할 수 있으며 IGMP[3]와 OSPF[4]와 같은 라우팅 프로토콜에 사용  ping[5] 유틸리티에 의해 사용되는 인터넷 제어 메시지 프로토콜(ICMP)에도 사용Socket 통신Server socketServer socket은 client socket의 연결 요청을 대기하고, 연결 요청이 오면 client socket을 생성하여 통신이 가능하도록 제공한다.Server socket의 동작 과정은 다음과 같다.  socket() 함수를 이용하여 소켓 생성  bind() 함수를 이용해 대기 소켓의 IP 주소와 port를 설정  listen() 함수로 클라이언트 소켓 연결 요청 대기  Client socket 연결 요청이 오면 accept() 함수를 이용해 연결을 승인하고, 요청은 client socket과 통신을 위한 소켓을 생성  Server socket은 listen() 함수를 통해 추가적인 연결 요청에 대비하고, 생성된 socket은 연결된 client socket과 데이터를 주고받음  Client socket이나 생성된 socket을 닫으면 연결되어 있던 상대 socket도 닫힘Client SocketClient socket은 client 프로그램이나 server에서 생성할 수 있다. 위 server socket 설명에서 accept 후 새로운 socket이 생성되는데 이 또한 client socket으로 실질적인 socket 간 통신은 client socket 간에 이루어진다.Client socket의 동작 과정은 다음과 같다.  socket() 함수를 이용하여 socket 생성  connect() 함수를 이용해 지정된 sever에 연결 요청 전송  Server에서 연결을 받아들이면 데이터 송수신 시작  데이터 송수신이 완료되거나 상대 socket의 닫힘이 감지되면 socket을 닫음Java Socket 통신  Java에서는 socket 통신을 위해 Socket class와 서버 구성을 위한 ServerSocket class를 지원한다.Class SocketSocket 생성과 함께 server 연결에 연결 요청을 한다. 이를 위해 Socket constructor에는 연결을 위한 server 정보가 제공 되어야 한다.Socket socket = new Socket(hostIp, port)Server에 성공적으로 연결되면, server와 통신을 위한 socket이 생성되어 반환되며 연습 문제를 통해 확인&gt; nc -l 12345 로 nc 서버 오픈try {    Socket socket = new Socket(\"localhost\", 12345);    System.out.println(\"서버에 연결되었습니다.\");    socket.close();} catch (IOException e) {    System.err.println(e);}$ 서버에 연결되었습니다.→ 서버와 연결됨을 확인할 수 있다.Try-with-resources  try 는 하나 이상의 자원을 관리하고 있다가 해당 Statement가 끝날 때, 각각의 자원을 반환 하는 것을 목표로 한다.      아래의 예제는 파일을 읽는 코드이다. 이러한 FileReader 나 BufferdReader 는 해당 자원을 반환할 의무가 있다.      static String readFirstLineFromFile(String path) throws IOException {  try (FileReader fr = new FileReader(path);  \t         BufferedReader br = new BufferedReader(fr)) {  \t        return br.readLine();  \t    }  \t}        이러한 자원의 선언문은 try 문 즉시 나타난다.    try 문이 끝난다면 해당 자원들은 자동으로 닫히게 된다. (정상적이던 정상적이지 않던)    기존에 존재하던 try-catch-finally **의 경우 error stacktrace의 누락등으로 정상적인 추적에 있어 실수를 할 위험이 있다.  모든 메모리를 반환할 경우 try-with-resources 를 사용하자.  기존의 Closeable 에 부모 인터페이스인 AutoCloseable 을 추가하여 기존의 모든 자원 Class에 사용가능하다.      try - with - resourses 를 사용한 다른 예제      public static void viewTable(Connection con) throws SQLException {          String query = \"select COF_NAME, SUP_ID, PRICE, SALES, TOTAL from COFFEES\";          // try-with-resources 구문 사용      try (Statement stmt = con.createStatement();            ResultSet rs = stmt.executeQuery(query)) {              while (rs.next()) {              String coffeeName = rs.getString(\"COF_NAME\");              int supplierID = rs.getInt(\"SUP_ID\");              float price = rs.getFloat(\"PRICE\");              int sales = rs.getInt(\"SALES\");              int total = rs.getInt(\"TOTAL\");                  System.out.println(coffeeName + \", \" + supplierID + \", \" +                                  price + \", \" + sales + \", \" + total);          }      } catch (SQLException e) {          JDBCTutorialUtilities.printSQLException(e);      }  }            위의 서버 연결 코드를 try - with - resourses 를 사용하여 변경      try(Socket socket = new Socket(\"localhost\", 12345)) {      System.out.println(\"서버에 연결되었습니다.\");      } catch (IOException e) {      System.err.println(e);  }      Ex 01 : Socket class의 함수를 이용해 client와 server 접속 정보(host, port)를 확인import java.io.IOException;import java.net.Socket;public class Main {    public static void main(String[] args) throws Exception {        try(Socket socket = new Socket(\"localhost\", 12345)) {            System.out.println(\"서버에 연결되었습니다.\");                        System.out.println(\"Local address : \" + socket.getInetAddress());            System.out.println(\"Local port : \" + socket.getLocalPort());            System.out.println(\"Remote address : \" + socket.getRemoteSocketAddress());            System.out.println(\"Remote port : \" + socket.getPort());        } catch (IOException e) {            System.err.println(e);        }    }}Ex 02 : Clinet Socket을 server에 연결하여 data 보낸다.      지정된 server에 연결하여 socket을 생성한다.Socket socket = new Socket(host, port);        Server에 연결되면, socket을 반환하고 계속 진행한다.System.out.println(\"서버에 연결되었습니다.\");        그렇지 않으면, IOException을 발생시킨다.} catch (ConnectException e) { System.err.println(host + \":\" + port + \"에 연결할 수 없습니다.\");}        연결된 socket에서 output stream을 얻어서 데이터를 전송한다.socket.getOutputStream().write(\"Hello World!\".getBytes()); → OutputStream class의 write() 함수는 byte [] 를 받아 전송하므로, 문자열은 byte []로 변환한다.        데이터 송/수신이 끝나면 연결을 끊고, socket을 닫는다.socket.close();  Source Codeimport java.io.IOException;import java.net.ConnectException;import java.net.Socket;public class Exam02 {    public static void main(String[] args) {        String host = \"localhost\";        int port = 1234;        if (args.length &gt; 0) {            host = args[0];        }        try {            if (args.length &gt; 1) {                port = Integer.parseInt(args[1]);            }        } catch (NumberFormatException ignore) {            System.err.println(\"Port가 올바르지 않습니다.\");            System.exit(1);        }        try {            // tag::newSocket[]            Socket socket = new Socket(host, port);            // end::newSocket[]            // tag::connected[]            System.out.println(\"서버에 연결되었습니다.\");            // end::connected[]            // tag::outputWrite[]            socket.getOutputStream().write(\"Hello World!\".getBytes());            // end::outputWrite[]            // tag::socketClose[]            socket.close();            // end::socketClose[]            // tag::connectException[]        } catch (ConnectException e) {            System.err.println(host + \":\" + port + \"에 연결할 수 없습니다.\");        }        // end::connectException[]        // tag::IOException[]        catch (IOException e) {            System.err.println(e);        }        // end::IOException[]    }}데이터를 받고 싶다면socket.getOutputStream().write(\"Hello World!\".getBytes()); 를while ((ch = socket.getInputStream().read()) &gt;= 0) {                System.out.write(ch); }로 변경한다.Q4. Server에 exit가 입력 될 때까지 data 입력하기while (true) {                BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));                String input = bf.readLine();                if (input.equals(\"exit\"))                     break;                                socket.getOutputStream().write(input.getBytes());            }Q5. server에서 보내는 문자열을 출력 하기BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));            String line;            while ( (line = reader.readLine()) != null) {                if (line.equals(\"exit\")) {                    System.out.println(\"종료합니다...\");                    break;                }                   System.out.println(line);                        }            socket.close();→ BufferedReader 를 활용해서 String 으로 처리하기!Q6. Echo 서버 연결해 문자열 보내고 받기  Server.java 와 Client.java 로 echo 통신 구현      Server.java      import java.io.*;  import java.net.*;  import java.util.Scanner;      public class Server {  \tpublic static void main(String args[]) throws IOException {  \t\tSocket socket = null;  \t\tServerSocket server_socket = null;\t  \t\tBufferedReader in = null;            //Client로부터 데이터를 읽어들이기 위한 입력스트림          PrintWriter out = null;   \t\t\t//Client로 에코 해줄 출력 스트          String input = null;              try{  \t            server_socket = new ServerSocket(7787); // 포트번호로 연결   \t            System.out.println(\"서버 실행 \");  \t         \tsocket = server_socket.accept(); // 자식 소켓에게 연결                   System.out.println(\"클라이언트 연결 완료 \");  \t        }catch(IOException e)  \t        {  \t            System.out.println(\"해당 포트가 열려있습니다.\");  \t        }                                  while(true) {              System.out.println(\"서버 대기중...\");              in = new BufferedReader(new InputStreamReader(socket.getInputStream()));    //입력스트림 생성              out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()))); //출력스트림 생성              \t        try {  \t            input = in.readLine();                //Client로부터 데이터를 읽어옴      \t            System.out.println(\"Client로 부터 보낸 메세지 : \" + input);    \t              \t            out.println(input); // 에코 해줄 데이터 Client로 보냄  \t            out.flush(); // 버퍼링 제거     \t              \t        }  \t        catch(IOException e)  \t        {  \t        \tSystem.out.println(\"서버 통신 오류 발생. \");  \t        }    \t            \t                  }      \t}  }            Client.java      import java.io.*;  import java.net.*;  import java.util.*;      import javax.swing.*;      public class Client {  \t public static void main(String[] arg)  \t    {  \t        Socket socket = null;            //Server와 통신하기 위한 Socket 선언   \t        PrintWriter out = null;            //서버로 내보내기 위한 출력 스트림  \t        InetAddress ia = null;\t\t\t// 클라이언트의 ip 주소   \t        String echo = null;\t\t\t\t// 에코를 출력할 스트              BufferedReader reader = null;  \t        Scanner s = new Scanner(System.in);  \t        try {  \t        \tia = InetAddress.getLocalHost();  //ip 할당   \t            System.out.println(ia);  \t            socket = new Socket(ia,7787); // 서버와 연결                       \t            System.out.println(socket.toString()); // 연결 정보 출력                   System.out.println(\"서버 연결 완료 \");  \t        } catch(IOException e) {                  throw new IllegalAccessError(\"echo\");  \t        }    \t          \t        while(true) {  \t        try {                  out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()))); //출력스트림 생성                  reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));  \t            System.out.print(\"서버로 보낼 메세제 : \");  \t            String data = s.nextLine();            //키보드로부터 입력  \t            if(data.equals(\"exit\")) {  // 종료   \t            \tSystem.out.println(\"Client 종료\");  \t            \tsocket.close();                      s.close();  \t            \tSystem.exit(0);  \t            }                      out.println(data); // 문자열을 소켓을 통해 전송                  out.flush(); // 버퍼를 비워서 데이터를 전송                      System.out.println(\"서버에서 보낸 echo 메세지: \" + reader.readLine());  \t        } catch(IOException e) {  \t        \tSystem.out.println(\"통신 오류 발생! \");  \t        }  \t        }                  \t    }  }      Socket Vs Server Socket  Socket          호스트간 통신을 위한 양쪽의 끝        ServerSocket          서버 프로그램에서 사용하는 소켓      Socket → ServerSocket → Socket      클라이언트 → ServerSocket → 서버      살짝 문…같은거…      Multi - Connection Server  동시에 다수의 client가 연결할 수 있도록 thread를 통해 분리해 보도록 만든다.      Server socket은 대기 상태에서 client 연결이 이루어지면 이를 처리하기 위한 thread를 생성하여 생성된 socket을 넘겨주고 server socket은 다시 새로운 연결을 기다리도록 한다.        [Server.java](http://Server.java)      public class Server {  \tpublic static void main(String args[]) throws IOException {  \t\tServerSocket server_socket = null;\t              while (true) {              server_socket = new ServerSocket(7787); // 포트번호로 연결               System.out.println(\"서버 실행 \");                              ClientServer childserver = new ClientServer(server_socket.accept());              childserver.start();              server_socket.close();              }  \t}  }            ClientServer.java      public class ClientServer implements Runnable{              Thread thread;      BufferedReader in = null;            //Client로부터 데이터를 읽어들이기 위한 입력스트림      PrintWriter out = null;   \t\t\t//Client로 에코 해줄 출력 스트      String input = null;      Socket socket;          public ClientServer(Socket s) {          System.out.println(\"자식 서버로 이동\");          this.socket = s;          thread = new Thread(this);      }          public void start(){          thread.start();      }          @Override      public void run() {              while (true) {              try {                  in = new BufferedReader(new InputStreamReader(socket.getInputStream()));    //입력스트림 생성                  out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()))); //출력스트림 생성                  input = in.readLine();                //Client로부터 데이터를 읽어옴                      System.out.println(\"Client로 부터 보낸 메세지 : \" + input);                                      if (input.equals(\"exit\")) {                      socket.close();                  }                  out.println(input); // 에코 해줄 데이터 Client로 보냄                  out.flush(); // 버퍼링 제거                                   }              catch(IOException e)              {                  System.out.println(\"서버 통신 오류 발생. \");              }          }      }  }      Multi -  client chat  Client 끼리 @를 사용해 귓속말을 사용할 수 있도록 만든다.      [Server.java](http://Server.java)      import java.io.*;  import java.net.*;  import java.util.ArrayList;  import java.util.List;  import java.util.Scanner;      public class Server {      static List&lt;ClientServer&gt; serverlist = new ArrayList&lt;&gt;();\t  \tpublic static void main(String args[]) throws IOException {  \t\tServerSocket server_socket = null;          Scanner scanner = new Scanner(System.in);          while (true) {              server_socket = new ServerSocket(7787); // 포트번호로 연결                               ClientServer childserver = new ClientServer(server_socket.accept(), scanner);              childserver.start();              serverlist.add(childserver);              server_socket.close();              }      \t}          public static void findUser(String id, String message) throws IOException {          for (ClientServer clientServer : serverlist) {              if (clientServer.getID().equals(id)) {                      System.out.println(clientServer.getID() + \"를 찾음!\");                          PrintWriter out = clientServer.getPrintWriter();                      out.println(message);                      out.flush();                                  }          }      }  }            ClientServe.java      import java.io.*;  import java.net.*;  import java.util.Scanner;  import java.util.StringTokenizer;      public class ClientServer implements Runnable{              private Thread thread;      private BufferedReader in = null;            //Client로부터 데이터를 읽어들이기 위한 입력스트림      private PrintWriter out = null;   \t\t\t//Client로 에코 해줄 출력 스트      private String input = null;      private Socket socket;      private String id;                  public ClientServer(Socket s, Scanner scanner) {          System.out.println(\"자식 서버로 이동\");           System.out.print(\"유저 이름 입력: \");                      this.id = scanner.nextLine();          this.socket = s;          thread = new Thread(this);      }          public void start(){          thread.start();      }          @Override      public void run() {              while (true) {              try {                  in = new BufferedReader(new InputStreamReader(socket.getInputStream()));    //입력스트림 생성                  out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()))); //출력스트림 생성                  input = in.readLine();                //Client로부터 데이터를 읽어옴                      if(input.charAt(0) == '@') {                      StringTokenizer st = new StringTokenizer(input.substring(1));                      String userid = st.nextToken();                                  Server.findUser(userid, input.substring(userid.length() + 1));                      continue;                  }                      System.out.println( id + \"로 부터 보낸 메세지 : \" + input);                                      if (input.equals(\"exit\")) {                      socket.close();                  }                                      }              catch(IOException e) {                  System.out.println(\"서버 통신 오류 발생. \");              }          }      }          public String getID() {          return id;      }          public PrintWriter getPrintWriter() throws IOException{          return new PrintWriter(new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()))); //출력스트림 생성;      }                  }            [Client.java](http://Client.java)      import java.io.*;  import java.net.*;  import java.util.*;      import javax.imageio.IIOException;  import javax.swing.*;      public class Client {  \t public static void main(String[] arg) throws IOException  \t    {  \t        Socket socket = null;            //Server와 통신하기 위한 Socket 선언   \t        PrintWriter out = null;            //서버로 내보내기 위한 출력 스트림  \t        InetAddress ia = null;\t\t\t// 클라이언트의 ip 주소               BufferedReader in = null;  \t        Scanner s = new Scanner(System.in);  \t        try {  \t        \tia = InetAddress.getLocalHost();  //ip 할당   \t            System.out.println(ia);  \t            socket = new Socket(ia,7787); // 서버와 연결   \t\t\t\tout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()))); //출력스트림 생성  \t\t\t\tin = new BufferedReader(new InputStreamReader(socket.getInputStream()));                  Reciver reciver = new Reciver(socket, in);  \t\t\t\treciver.start();  \t            System.out.println(socket.toString()); // 연결 정보 출력                   System.out.println(\"서버 연결 완료 \");  \t        } catch(IOException e) {                  throw new IOException(\"서버 연결 오류\");  \t        }    \t          \t        while(true) {  \t\t\t\ttry {  \t\t\t\t\tString data = s.nextLine();            //키보드로부터 입력  \t\t\t\t\tif(data.equals(\"exit\")) {  // 종료   \t\t\t\t\t\tSystem.out.println(\"Client 종료\");  \t\t\t\t\t\tsocket.close();  \t\t\t\t\t\ts.close();  \t\t\t\t\t\tSystem.exit(0);  \t\t\t\t\t}      \t\t\t\t\tout.println(data); // 문자열을 소켓을 통해 전송  \t\t\t\t\tout.flush(); // 버퍼를 비워서 데이터를 전송        \t\t\t\t\t  \t\t\t\t} catch(IOException e) {  \t\t\t\t\tSystem.out.println(\"통신 오류 발생! \");  \t\t\t\t}  \t        }                  \t    }       }      class Reciver extends Thread {  \tSocket socket = null;  \tBufferedReader in = null;  \tString message = \"\";        \t      \tReciver(Socket s, BufferedReader pr) {  \t\tthis.socket = s;  \t\tthis.in = pr;  \t}      \t@Override  \tpublic void run()  {      \t\twhile (true) {  \t\t\ttry {  \t\t\t\tmessage = in.readLine();  \t\t\t} catch (IOException e) {}    \t\t\t  \t\t\tSystem.out.println(\"수신된 메세지 : \" + message);      \t\t\ttry {  \t\t\t\tThread.sleep(2000);  \t\t\t} catch (InterruptedException e) {  \t\t\t\te.printStackTrace();  \t\t\t}  \t\t}\t      \t}  }              Client 에 Reciver Thread를 추가하여 송신과 수신을 나눠서 해결      "
  },
  
  {
    "title": "L4, l7",
    "url": "/learninghub/nhn%20academy/cs/L4,-L7/",
    "categories": "NHN Academy, CS",
    "tags": "CS, NHN Acedemy",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "L7 응용계층 / L4 전송 계층 (23. 10. 25)L7 응용 계층  데이터를 사용자에게 전달하는 계층  하위 세 개의 계층(Host-to-Network, Internet, Transport)은 모두 데이터가 한 컴퓨터에서 다른 컴퓨터로 어떻게 전송되는지를 정의하는 데 협력  Application layer은 데이터가 전송된 후에 어떻게 처리할지를...",
    "content": "L7 응용계층 / L4 전송 계층 (23. 10. 25)L7 응용 계층  데이터를 사용자에게 전달하는 계층  하위 세 개의 계층(Host-to-Network, Internet, Transport)은 모두 데이터가 한 컴퓨터에서 다른 컴퓨터로 어떻게 전송되는지를 정의하는 데 협력  Application layer은 데이터가 전송된 후에 어떻게 처리할지를 결정한다.          예를 들어, HTTP와 같은 protocol은 웹 브라우저가 그래픽 이미지를 숫자의 긴 스트림이 아닌 그림으로 표시하도록 보장      L4 전송 계층  TCP / UDP 로 나뉜다.UDP  TCP에 비해 빠르다.          checksum 정도의 error checking 제공        올바른 순서로 전달되는지는 보장할 수 없음  신뢰성 없는 프로토콜TCP  Sender 포트 번호, Reciver 포트번호  reciver는 포트번호로 프로세스를 식별  높은 overhead로 손실된 데이터 감지와 재전송을 허용  신뢰성이 높은 프로토콜  TCP에 사용되는 필드          Sequence Number - 순서번호      Acknowledge Number - 어디까지 잘 받았는지, 다음 번 보낼 패킷의 Sequence Number 를 응답      Flags      ACK      RST      SYN      FIN      Window Size        3 Way Handshake  데이터 재전송          수신측 → ACK 전송      송신측                  timeout 시에          ACK 미 도달..          등등..                    TIME_WAITING  FIN 패킷을 전송하고 그에 반하는 ACK 패킷을 받음으로써 TIME_WAIT 상태로 변경  추후에 SYN 패킷을 전송해 다시 복귀  지연 패킷 문제를 해결          이전 연결에서 지연된 패킷을 식별 가능      Flow Control  TCP 헤더의 윈도우 크기  수신측에서 수신 가능한 버퍼의 크기, 해당 크기에 맞게 데이타를 보내면 됨  수신 애플리케이션의, 데이타 수신 속도와 관계가 있음.  한쪽이 너무힘들지 않게 조절 하는 기능Congestion Control  flow control 과는 다름  network 의 문제 (도로의 문제 )  TCP 가 열심히 추측해야 함.  네트워크 상황이 나쁜데, TCP 패킷이 쏟아지면 …  상황이 악화됨 - retransmission  Sliding window 적용Well-Known 프로토콜  HTTP 80 - 브라우저에 주소창에 명시하지 않아도 http 프로토콜은 80 포트를 사용  DNS 53  SMTP 25"
  },
  
  {
    "title": "L2, l3 ",
    "url": "/learninghub/nhn%20academy/etc/L2,-L3/",
    "categories": "NHN Academy, ETC",
    "tags": "CS, NHN Acedemy",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "L3 네트워크  / L2 연결 계층(23. 10. 25)L3 Network LayerIP Internet Protocol - IPv4(32비트)  데이터를 어떻게 전송할 것인가?  데이터를 어떤 경로로 결정한것인가?  주요 용어          TTL- Time To Live      Protocol      6 TCP      17 UDP      ...",
    "content": "L3 네트워크  / L2 연결 계층(23. 10. 25)L3 Network LayerIP Internet Protocol - IPv4(32비트)  데이터를 어떻게 전송할 것인가?  데이터를 어떤 경로로 결정한것인가?  주요 용어          TTL- Time To Live      Protocol      6 TCP      17 UDP      Checksum      IP        Subnet Mask          라우터를 통하지 않는 내부 주소 계산을 위한 Mask        라우터          데이터를 전달        라우팅          포워딩 테이블 만든다.      NAT  ip 고갈 될까봐 만들어낸 기능  조직 내부 주소  다른 서버 입장에서는 모든 IP가 동일하게 보이는 현상  단점          서버 운영 불가      다른 환경의 NAT은 직접 통신의 불가      ICMP  네트워크 상태를 보고하기 위한 메세지  TTL로 인한 패킷 로스가 대표적라우팅 알고리즘  IGP          link-state 알고리즘      distance-vector 알고리즘      AS (내부 네트워크) 에서 주로 사용됨                  AS의 대표적 예시 → SK, U+, KT                      EGP          AS내의 다른 네트워크 그룹끼리의 통신      외부 연결을 위한 라우팅 경로 설정        BGP          AS간의 라우팅에 사용됨 (서로 다른 조직의 네트워크 연결)      "
  },
  
  {
    "title": "Json",
    "url": "/learninghub/nhn%20academy/etc/JSON/",
    "categories": "NHN Academy, ETC",
    "tags": "NHN Acedemy",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "JSONOverview  JSON 이란 가벼운 데이터 교환 형식으로 인간이 읽기 쓰기 편하며 기계도 구문 분석 하기 좋은 JacaScript 기반으로 만들어짐  JSON은 완전히 언어 독립적인 텍스트 형식이지만 C를 비롯한 C++, C#, Java, JavaScript, Perl, Python 및 기타 여러 가지 C 계열 언어의 프로그래머에게 익숙한 ...",
    "content": "JSONOverview  JSON 이란 가벼운 데이터 교환 형식으로 인간이 읽기 쓰기 편하며 기계도 구문 분석 하기 좋은 JacaScript 기반으로 만들어짐  JSON은 완전히 언어 독립적인 텍스트 형식이지만 C를 비롯한 C++, C#, Java, JavaScript, Perl, Python 및 기타 여러 가지 C 계열 언어의 프로그래머에게 익숙한 규칙을 사용  Json은 두가지 기반으로 작동한다.          name/value 쌍의 모음                  다양한 언어에서 이것은 object , 레코드, 구조체, 사전, 해시 테이블, 키 목록 또는 연관 배열로 구현된다.                    정렬된 값 목록                  대부분의 언어에서 이것은 배열 , 벡터, 목록 또는 시퀀스로 구현된다.                    JSON 구성 요소Object  이름/ 값 쌍의 정렬되지 않은 집합  { 로 시작하여 } 로 끝난다.      각 이름 뒤에는 : 가 오고 , 로 구분한다.              { }      { “name” : “삼각형” }      { “name” : “삼각형”, “내각” : [ 30, 60, 90 ] }      { “name” : “삼각형”, “내각” : [ 30, 60, 90 ] , “추가” : { “색” : “파랑” }}      Array  정렬된 값의 모임  [(왼쪽 대괄호)로 시작하여 ](오른쪽 대괄호)로 끝난다      값은 ,(쉼표)로 구분 된다              [1, 2, 3]      [1, “2”, 3.0]      [1, “2”, {“type” : “vlaue” } ]      [1, [10, [100, 101]]]      Value  “(큰따옴표)로 묶인 문자열  숫자  true 또는 false  null  object  배열String  ’'(백 슬래시 이스케이프)를 사용하여 “(큰따옴표)로 묶인 0개 이상의 유니코드 문자 시퀀스  문자는 단일 문자열로 표시된다  C 또는 Java 문자열과 매우 유사하다Number  8진수 및 16진수 형식이 사용되지 않는다  º이외에 C 또는 Java 숫자와 매우 유사하다"
  },
  
  {
    "title": "Json in java",
    "url": "/learninghub/nhn%20academy/etc/JSON-in-Java/",
    "categories": "NHN Academy, ETC",
    "tags": "CS, NHN Acedemy, Java",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "JSON in Java(23. 10. 27)  Maven 에서 JSON in Java 설치  lib 폴더에 넣어서 사용한다.      json 모듈의 계층 구조      classDiagram    Object &lt;|-- CDL    Object &lt;|-- Cookie    Object &lt;|-- CookieList    Object &lt...",
    "content": "JSON in Java(23. 10. 27)  Maven 에서 JSON in Java 설치  lib 폴더에 넣어서 사용한다.      json 모듈의 계층 구조      classDiagram    Object &lt;|-- CDL    Object &lt;|-- Cookie    Object &lt;|-- CookieList    Object &lt;|-- HTTP    Object &lt;|-- JSONArray    Object &lt;|-- JSONML    Object &lt;|-- JSONObject    Object &lt;|-- JSONPointer    Object &lt;|-- JSONString    Object &lt;|-- JSONTokener    Object &lt;|-- JSONWriter  \tJSONObject  \tJSONString  \tJSONTokener &lt;|-- HTTPTokener  \tJSONTokener &lt;|-- XMLTokener  \tJSONWriter &lt;|-- JSONStringer  \tThrowable &lt;|-- Exception  \tException &lt;|-- RuntimeException  \tRuntimeException &lt;|-- JSONException  \tJSONException &lt;|-- JSONPointerException      Constructor      JSONObject 를 사용해서 json 객체를 생성      public static void main(String args[]) {          JSONObject jsonObject = new JSONObject();          jsonObject.put(\"name\", \"nhn\");          System.out.println(jsonObject.toString());      }            다른 json 객체를 value로 넣은 예제      public static void main(String args[]) {          JSONObject jsonObject = new JSONObject();          JSONObject addressJsonObject = new JSONObject();          addressJsonObject.put(\"code\", 13487);          addressJsonObject.put(\"city\", \"Seongnam\");          jsonObject.put(\"address\", addressJsonObject);          jsonObject.put(\"name\", \"nhn\");          System.out.println(jsonObject.toString());      }      JSON 문자열  Json을 이종 시스템간 주고 받을 경우 문자열 형태로 많이 사용된다.      문자열로 표현된 JSON Object    \"{\\\"name\\\" : \\\"nhn\\\"}”        이러한 문자열을 이종 시스템에서 받아 object를 생성하는 생성자도 존재    JSONObject(String source)      public static void main(String args[]) {          String jsonText = \"{\\\"name\\\" : \\\"nhn\\\"}\";              try {          JSONObject object = new JSONObject(jsonText);              System.out.println(object.toString());          } catch (JSONException e) {              e.printStackTrace();          }            문자열 뿐만 아니라 객체로도 json 객체 생성 가능      public class Person {      String name;          public Person(String name) {          this.name = name;      }          public String getName() {          return name;      }          public void setName(String name) {          this.name = name;      }  }      Person person = new Person(\"nhn\");          try {          JSONObject object = new JSONObject(person);              System.out.println(object);          } catch (JSONException e) {              e.printStackTrace();          }        값을 변경 할때에도 put 을 활용한다          이미 있는 name이라면 값을 변경          JSONObject object = new JSONObject(person);      object.put(\"name\", \"academy\");              System.out.println(object + \" | \" + person.getName());      {\"name\":\"academy\"} | nhn              객체의 값은 변하지 않고 json 값만 변하였다.            값을 가져올 때에는 get 을 활용한다.      JSONObject customer = new JSONObject();          customer.put(\"name\", \"nhn\");          customer.put(\"age\", 20);          System.out.println(customer);              Object name = customer.get(\"name\");          System.out.println(name.getClass().getTypeName());          System.out.println(name);              Object age = customer.getInt(\"age\");          System.out.println(age.getClass().getTypeName());          System.out.println(age);              getInt 를 활용하여 받아올 data type을 지정 가능하다.            option 을 활용해서 초기 타입을 지정 가능      try {            String jsonString = \"{\\\"model\\\":\\\"K2\\\",\\\"power\\\":10}\";            JSONObject jsonObject = new JSONObject(jsonString);            System.out.println(jsonString.toString());            System.out.println(jsonObject.optBoolean(\"flyable\", false));        } catch (JSONException e) {            System.err.println(e);        }              optBoolean 을 참조      Json Array      Json array를 활용해 국내 주요 도시를 나열      public static void main(String args[]) {              String[] cities = new String[] { \"서울\", \"부산\", \"광주\", \"대구\", \"대전\", \"인천\", \"울산\" };              JSONArray jsonArray = new JSONArray();          for (String city : cities) {              jsonArray.put(city);          }              JSONObject object = new JSONObject();          object.put(\"도시\", jsonArray);              System.out.println(object.toString());      }      Q1. JSON으로 동물 분류 및 나열  동물          조류                  갈매기          참새          펭귄                    포유류                  사자          호랑이          말                      JSON 문자열을 사용하지 말고, JSONObject default constructor로 object를 생성 후 put method를 이용해 추가하라.public static void main(String args[]) {        String[] Birds = new String[] {\"갈매기\", \"참새\",\"팽귄\"};        String[] mammalias =  new String[] {\"사자\", \"호랑이\", \"말\"};        JSONArray birdsArray = new JSONArray();        JSONArray mammaliasArray = new JSONArray();        for (String Bird : Birds) {            birdsArray.put(Bird);        }        for (String mamalia : mammalias) {            mammaliasArray.put(mamalia);        }        JSONObject jsonmammalias = new JSONObject();        JSONObject jsonbirds = new JSONObject();        jsonbirds.put(\"조류\", birdsArray );        jsonmammalias.put(\"포유류\", mammaliasArray);        JSONArray animalsArray = new JSONArray();        animalsArray.put(jsonbirds);        animalsArray.put(jsonmammalias);        JSONObject object = new JSONObject();        object.put(\"동물\", animalsArray);        System.out.println(object.toString());    }{\"동물\":[{\"조류\":[\"갈매기\",\"참새\",\"팽귄\"]},{\"포유류\":[\"사자\",\"호랑이\",\"말\"]}]}Q2. 숫자 1의 인덱스를 출력 {”true”, “1”, “true}public static void main(String[] args) {        try {            JSONArray jsonArray = new JSONArray();            jsonArray.put(\"true\");            jsonArray.put(1);            jsonArray.put(true);            int index = 0;            for (Object entity : jsonArray) {                if (entity instanceof Integer &amp;&amp; (int) entity == 1) {                    break;                } index++;            }            if (index &lt; 0) {                System.out.println(\"1을 찾을 수 없습니다.\");            } else {                System.out.println(\"1은 \" + (index + 1) + \"번째에 위치합니다.\");            }        } catch (JSONException e) {            System.err.println(e);        }    }1은 2번째에 위치합니다.Q3. JSON을 이용해 사용자/아이템/전적 관리를 위한 파일 기반의 데이터베이스를 만들어라.관리 정보  사용자          아이디      닉네임        아이템          아이디      모델      체력(0 ~ 10000)      공격력(0 ~ 100)      방어력(0 ~ 50)      이동속도(0 ~ 100)      공격속도(0 ~ 100)        전적          대전 횟수      승리 횟수        변경 이력요구 사항  구성 요소별로 class를 정의하라.  생성된 데이터는 JSON 문자열로 파일에 저장한다.  파일에서 JSON 문자열을 읽어 들여서 각 object를 생성한다.  데이터를 저장할 때마다 변경 이력을 추가하라 ◦ 변경 이력에는 시간과 변경 내용이 포함된다.    public class Json extends Object{  private static String user1 = \"{\\\"userid\\\" : \\\"unggu\\\" , \\\"username\\\" : \\\"unggu \\\"}\"; private static String item1 =  \"{\\\"itemname\\\" : \\\"ak\\\", \\\"model\\\" :  \\\"ak-47\\\", \\\"hp\\\" : 13 , \\\"pow\\\" : 26 , \\\"def\\\" : 23 , \\\"spd\\\" : 123 , \\\"dps\\\" : 11}\"; private static String record1 =  \"{\\\"recordcount\\\" : 12 , \\\"wincount\\\" : 8}\"; private static String user2 = \"{\\\"userid\\\" : \\\"adfs123\\\" , \\\"username\\\" : \\\"junggu \\\"}\"; private static String item2 =  \"{\\\"itemname\\\" : \\\"m\\\", \\\"model\\\" : \\\"m16\\\", \\\"hp\\\" : 21 , \\\"pow\\\" : 23 , \\\"def\\\" : 53 , \\\"spd\\\" : 313 , \\\"dps\\\" :52}\"; private static String record2 =  \"{\\\"recordcount\\\" : 21 , \\\"wincount\\\" : 6}\"; public static void main(String[] args) {     try {                  JSONObject userObject = new JSONObject(user1);             JSONObject itemObject = new JSONObject(item1);             JSONObject recordObject = new JSONObject(record1);             User user1 = new User(userObject.getString(\"userid\"),userObject.getString(\"username\"), LocalTime.now());             Item item1 = new Item(itemObject.getString(\"itemname\"), itemObject.getString(\"model\"), itemObject.getInt(\"hp\"), itemObject.getInt(\"pow\"), itemObject.getInt(\"def\"), itemObject.getInt(\"spd\"), itemObject.getInt(\"dps\"), LocalTime.now());             Record record1 = new Record(recordObject.getInt(\"recordcount\"), recordObject.getInt(\"wincount\"), LocalTime.now());             userObject = new JSONObject(user2);             itemObject = new JSONObject(item2);             recordObject = new JSONObject(record2);             User user2 = new User(userObject.getString(\"userid\"),userObject.getString(\"username\"), LocalTime.now());             Item item2 = new Item(itemObject.getString(\"itemname\"), itemObject.getString(\"model\"), itemObject.getInt(\"hp\"), itemObject.getInt(\"pow\"), itemObject.getInt(\"def\"), itemObject.getInt(\"spd\"), itemObject.getInt(\"dps\"), LocalTime.now());             Record record2 = new Record(recordObject.getInt(\"recordcount\"), recordObject.getInt(\"wincount\"), LocalTime.now());         } catch (JSONException e) {         System.err.println(e);     } }}          import java.sql.Time;import java.time.LocalTime;public class Record {    private int battlecont;    private int wincount;    private LocalTime time;    Record(int b, int w, LocalTime t) {        this.battlecont = b;        this.wincount = w;        time = t;    }}    import java.time.LocalTime;public class User {    private String userid;    private String username;    private LocalTime time;    private String olduserid;    private String oldusername;    private LocalTime oldtime;    public User(String u, String u2, LocalTime t) {        this.userid = u;        this.username = u2;        this.time = t;    }    @Override    public String toString() {        return userid + \" \" + username + \" \" + time;    }}      import java.time.LocalTime;public class Item {    private String itemname;    private String model;    private int hp;    private int pow;    private int def;    private int spd;    private int dps;    private LocalTime time;     Item(String itemname, String model, int h, int p, int d, int s, int dps, LocalTime t) {        itemname = itemname;        model = model;        hp = h;        pow = p;        def = d;        spd = s;        dps = dps;        this.time = t;    }}"
  },
  
  {
    "title": "Java concepts",
    "url": "/learninghub/nhn%20academy/cs/JAVA-Concepts/",
    "categories": "NHN Academy, CS",
    "tags": "CS, NHN Acedemy, Java",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "JAVA 개념 정리 (09.04 ~ 09.08)Java의 특징객체 지향 언어 (OOP)  객체란 무엇인가          현실 세계의 Entity를 객체로 지정해 이 객체로 프로그래밍을 하는 기법      객체는 필드와 메소드를 통해 노출 됨      이러한 방식을 통해 내부 상태는 숨기고 객체간의 상호작용 → 데이터 캡슐화      모듈성, 정보 은...",
    "content": "JAVA 개념 정리 (09.04 ~ 09.08)Java의 특징객체 지향 언어 (OOP)  객체란 무엇인가          현실 세계의 Entity를 객체로 지정해 이 객체로 프로그래밍을 하는 기법      객체는 필드와 메소드를 통해 노출 됨      이러한 방식을 통해 내부 상태는 숨기고 객체간의 상호작용 → 데이터 캡슐화      모듈성, 정보 은닉, 코드 재사용, 디버깅 용이성 등의 기능을 제공함        클래스란?          객체를 생성하기 위한 Blueprint      클래스를 기반으로 얼마든지 객체를 찍어낼 수 있음        상속이란?          자식 객체는 부모 객체의 함수를 사용가능하다      클래스는 하나의 슈퍼 클래스를 가지며 무한의 서브 클래스 생성 가능        객체 지향의 설계 원칙          단일 책임 원칙 : 한 클래스는 하나의 책임      개방 폐쇄 원칙 : 확장에는 Open, 수정에는 Close      리스코프 치환 원칙 : 하위 타입은 항상 상위 타입을 대체 가능      인터페이스 분리 원칙 : 인터페이스의 메소드는 최소한일 수록 좋다.      의존관계 역전 원칙 : 변하치 않은 불변 클래스와 관계를 맺을것.        패키지 → 기능별로 클래스와 인터페이스를 구성하는 것들을 묶은것  API → Application Programming Interface  자바는 완전한 객체 지향은 아니다… 대신에 아름다운 객체지향  JDK → 자바 개발 도구 (컴파일 기능 있음)  JRE → 자바 실행 머신 (컴파일 기능이 없음)JVM  Java Byte Code를 OS에 맞게 변환 → OS에 독립적  컴파일 하면 바이트코드 생성  스택 기반 동작  가비지 컬렉션을 통한 메모리 관리          동적으로 할당됐던 메모리 영역 중 필요 없는 메모리 영역을 회수해서 관리      메모리 영역  메소드 영역 : 전역 변수와 Static을 저장  스택 영역 : 지역 변수와 매개변수를 저장, 메소드 호출시 할당 및 종료시 반환, LIFO의 구조를 가짐  힙 영역 : new 키워드로 관리 객체, 배열이 저장됨 가비지 컬렉션으로 관리Synchronized  여러개의 Thread가 한개의 자원을 이용할때 나타나는 교착 상태(Deadlock)을 방지  하나의 Thread가 접근지 다른 Thread의 접근을 막음  남발하면 성능 저하String  java.lang.String  String 생성시 new String()과 리터럴 방식으로 구분  new String은 Heap 영역에 저장  리터럴 방식은 String Constatnt Pool 영역에 저장  리터럴은 객체를 생성하지 않고 그대로 저장하는 방법 → 가독성, 최적화 우수final  클래스, 메소드, 변수 등을 한 번만 할당  한번 초기화 되면 변경할수 없으며 오버라이딩과 상속을 금지함Java 자료형 / Collections정수형  byte - 1 , short -2 , int - 4, long - 8실수형  float - 4, double - 8문자형  char - 2논리형  boolean - 1배열  Scan에 빠름 바이트 수에 맞게 입력List  ArrayList → 배열 형식으로 데이터를 저장 스캔에 유리  LinkedList → 자료 삽입에 유리 순차 접근만 가능하기에 스캔에 불리TreeSet  검색에 메우 최적화  일반적인 트리 구조HashSet  Tree 구조보다 검색에 빠름JAVA 개념자바 접근 제어자  Public, Protected, default, private  객체들간의 관계에 있어 권한을 부여 가능  데이터의 부적절한 사용으로부터 보호 가능다형성  같은 자료형에 여러가지 타입의 데이터를 대입하여 다양한 결과를 얻어낼 수 있는 성질업 캐스팅  자식 클래스가 부모 클래스 타입으로 캐스팅  해당 클래스는 부모 클래스의 멤버만 접근 가능  하나의 인스턴스로 묶어서 관리 가능 → 다운 캐스팅이 필수적다운 캐스팅  부모 클래스가 자식 타입으로 캐스팅 되는것  주로 업케스팅한 객체를 되돌리는데 쓰임추상 클래스  추상 메소드가 하나 이상 포함된 클래스  abstract로 정의된 경우  하위 메소드의 기능 확장을 추구  다중상속이 불가능  하위 클래스에서 추상 메서드의 구현을 강제함  Overrriding인터페이스  모든 메소드가 추상 메소드로만 이루어져 있음  하위 메소드가 구현시 특정 메소드가 반드시 있어야함  다중 상속이 가능  Overrriding  서브타이핑이라고도 불림  리스코프 치환 원칙(LSP)를 만족함 → 자식이 부모의 행동 호환성을 유지, 부모 클래스를 대체 가능함.  추상클래스와 차이 → 다중 상속이 가능하기에 기능에 따른 인터페이스를 상속해 기능 확장→ 인터페이스 분리 원칙(ISP)라고 함상속  extends          부모의 변수, 메소드 사용가능      다중 상속 X        implements          부모 메소드를 반드시 재정의 해야함      다중 상속이 가능      Overrriding  하위 클래스에서 상위 클래스의 메소드를 재 정의해서 사용  코드 중복을 줄이고 기능 확장에 이점Overloading  같은 이름을 가지지만 매개변수가 다른 여러 개의 메소드를 선언  메소드 이름의 중복으로 가독성 증가싱글톤 패턴, Static싱글톤 패턴  인스턴스의 불필요한 생성을 방지하고 오직 한개만 생성  메모리 낭비 방지  데이터 공유의 용이Static  인스터스가 아닌 클래스에 고정  객체 인스턴스 생성하지 않고 사용 가능  JVM에 Static 영역에 바로 배치  Static 변수 선언시 클래스 변수라고도 함차이  Static은 다형성을 사용할수 없음  Static은 프로그램 실행시 초기화, 싱글톤은 getInstance 호출 시에 생성"
  },
  
  {
    "title": "Http",
    "url": "/learninghub/nhn%20academy/cs/HTTP/",
    "categories": "NHN Academy, CS",
    "tags": "Web, NHN Acedemy, CS",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "HTTP(23. 10 .27)WWW(World Wide Web)  1989년 3월 팀 버너스리 외 n 명의 과학자들의 제안으로 시작  Web 브라우저가 Web Server의 HTML로 기술된 리소스를  URL을 통해 요청하여  HTTP를 사용하여 받아서 표현하는 것HTML (HyperText Markup Language)  자원들 사이를 쉽게 항해 할...",
    "content": "HTTP(23. 10 .27)WWW(World Wide Web)  1989년 3월 팀 버너스리 외 n 명의 과학자들의 제안으로 시작  Web 브라우저가 Web Server의 HTML로 기술된 리소스를  URL을 통해 요청하여  HTTP를 사용하여 받아서 표현하는 것HTML (HyperText Markup Language)  자원들 사이를 쉽게 항해 할 수 있는 언어          HTML 3.2, 4.0, 4.1, 5.0, 5.1, 5.2 ..      URL (Uniform Resource Locator)  통일된 웹 자원(Resource)의 위치 지정 방법HTTP (HyperText Transfer Protocol)  HyperText (HyperMedia)를 클라이언트와 서버 사이에 주고 받을 수 있게 정의한 프로토콜  TCP/IP 프로토콜 위에서 동작하는 Text Based 프로토콜인증, 쿠키, 세션쿠키  서버가 클라이언트에 붙인 일종의 스티커  클라이언트는 서버에게 보내는 요청 해더에 쿠키를 표시해서 전송  웹 브라우저와 웹 서버 간의 상태 정보를 유지하기 위해 사용되는 데이터 (사용 세션 관리)  민감한 개인정보를 가지고 있기에 보안 취약점으로 사용될 위험 있음  Session Cookie(세션 쿠키)          사용자가 브라우저를 사용하는 동안만 유효함.      브라우저는 사용자가 브라우저를 사용하는 동안 Cookie 정보를 서버로 전달.        Persistent Cookie(지속 쿠키)          사용자가 브라우저를 종료하더라도 유지되는 쿠키      HTTPS  보안이 강화된 HTTP  일반적인 HTTP 계층해서 SSL/TLS 가 추가된 형태          대칭, 비대칭키 암호화 알고리즘      SSL 인증서      키 교환 알고리즘…      "
  },
  
  {
    "title": "Computer_architecture",
    "url": "/learninghub/nhn%20academy/cs/Computer_Architecture/",
    "categories": "NHN Academy, CS",
    "tags": "CS, NHN Acedemy",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Computer Architecture (23.09.04)CPU의 동작Memory  보조 기억장치 ( HDD, SDD ), 주 기억장치( RAM ), Cache MemoryCache Memory  L1 → L2 → L3 → RAM 순으로 저장 장소 탐색Register  저장된 주소의 데이터 저장, 로드등의 정보 저장CPU의 4가지 동작  Fetch (...",
    "content": "Computer Architecture (23.09.04)CPU의 동작Memory  보조 기억장치 ( HDD, SDD ), 주 기억장치( RAM ), Cache MemoryCache Memory  L1 → L2 → L3 → RAM 순으로 저장 장소 탐색Register  저장된 주소의 데이터 저장, 로드등의 정보 저장CPU의 4가지 동작  Fetch (인출)  Decode (해석)  Execute (실행)  Store (저장)프로그램의 동작원리16bit vs 32 bit vs 64 bit  xx 비트 → 한번에 xx개의 비트를 처리량을 뜻함. ( 32 → 4, 64 → 8 )Native Code의 동작  PC(Program counter) 가 주소를 전달, AP(Address Register) 가 명령어 해석 BR(Buffer Regitster) 이 Fetch IR(Instruction Register)가 CU(Control Uinit)에 전달 그리고 ALU에서 각자 명령 수행 (ADD, LOAD, STORE) 등등…"
  },
  
  {
    "title": "Computer network",
    "url": "/learninghub/nhn%20academy/cs/Computer-Network/",
    "categories": "NHN Academy, CS",
    "tags": "CS, NHN Acedemy",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Computer Network (23. 10. 25)Computer NetworkComputer network 이란?  서로 데이터를 교환하고 리소스를 공유할 수 있는 상호 연결된 Computing device의 집합  프로토콜을 사용하여 통신  다양한 형태로 구성(Topology)Node  Computer device간 메세지 전달을 위해 중간 역할...",
    "content": "Computer Network (23. 10. 25)Computer NetworkComputer network 이란?  서로 데이터를 교환하고 리소스를 공유할 수 있는 상호 연결된 Computing device의 집합  프로토콜을 사용하여 통신  다양한 형태로 구성(Topology)Node  Computer device간 메세지 전달을 위해 중간 역할 수행하는 디바이스들          Switch                  OSI 7 계층의 data link 층에서 작동          두 network를 연결해 하나의 network로 동작                    Firewall                  네트워크의 보안 및 엑세스 규칙 제어위한 SW          허용되지 않은 접근은 원칙적 차단                    Modem                  아날로그 to 디지털                    Router                  OSI 7계층의 network층에서 작동          Packet 전달에 이용          Routing의 경로 결정                    등등등…      Protocol  네트워크를 통해 정보 교환을 위한 일련의 규칙  Protocol 종류          IEEE 802.11 (Wi-fi 프로토콜)      HTTP (IP / TCP 프로토콜)      OSI 7계층  Physical Layer: 이 계층은 실제 데이터 전송을 다룹니다(전선, 광섬유 등). 하드웨어 특성, 신호 및 전송 속도를 정의한다.  Data Link Layer계층: 이 계층은 직접 연결된 두 노드 간의 신뢰할 수 있는 링크를 만듭니다. 프레임 형식, 오류 감지 및 흐름 제어와 같은 문제를 처리한다. Ethernet은 데이터 링크 계층 기술의 예입니다.  Network Layer: 네트워크 계층은 다중 연결된 네트워크를 통해 패킷을 출발지에서 목적지로 라우팅한다. IP(Internet Protocol)가 이 계층에서 작동한다.  Transport Layer: 이 계층은 발신자와 수신자 간의 종단 간 통신을 보장한다. 데이터 분할, 흐름 제어 및 오류 정정을 관리한다. TCP(Transmission Control Protocol) 및 UDP(User Datagram Protocol)는 전송 계층 프로토콜입니다.  Session Layer: 이 계층은 통신 세션을 설정, 관리 및 종료한다. 세션 동기화 및 대화 제어를 처리한다.  Presentation Layer: 데이터 번역, 압축 및 암호화를 담당한다. 데이터가 발신자와 수신자 양쪽에서 읽을 수 있는 형식으로 제공됨을 보장한다.  Application Layer: 가장 상위 계층으로 응용 프로그램별 프로토콜 및 데이터 형식을 처리한다. 웹 브라우저, 이메일 클라이언트 및 파일 전송 소프트웨어와 같은 사용자 수준 응용 프로그램이 작동하는 곳입니다.TCP / IP 4계층Host-to-Network LayerHost-to-Network(네트워크 인터페이스라고도 함)는 가장 낮은 TCP/IP 계층로, 패킷을 수신하고 특정 네트워크를 통해 전송하는 역할을 담당한다. Network interface는 장치 드라이버 또는 자체 데이터 링크 프로토콜을 사용하는 복잡한 서브시스템으로 구성될 수 있다.Internet Protocol(IP) LayerInternet protocol layer는 한 대의 기계에서 다른 대의 기계로의 통신을 처리한다. 이 layer는 transport layer에서 데이터를 전송하도록 요청을 수락하며, 데이터를 전송할 기계의 식별 정보와 함께 받는다. 그런 다음 데이터를 IP 데이터그램으로 래핑하고 데이터그램 헤더를 채우며, 데이터그램을 전달 방법을 결정하기 위해 라우팅 알고리즘을 사용하고 데이터그램을 전송하기 위해 적절한 장치 드라이버에 전달한다.Transport LayerTransport layer의 주요 목적은 한 응용 프로그램에서 다른 응용 프로그램으로의 통신을 제공하는 것이다. 소프트웨어는 전송되는 데이터 스트림을 ISO 용어로 패킷이라고 하는 더 작은 조각으로 나누고 각 패킷과 목적지 정보를 다음 레이어로 전달한다.Application LayerApplication layer는 TCP/IP 인터넷 전체에서 사용 가능한 서비스에 접근하는 사용자 호출 응용 프로그램으로 구성된다. 응용 프로그램은 데이터를 전송 레이어로 전달하기 위해 필요한 형식으로 전달한다.Network Issue  충돌 회피          여러기기가 동시에 데이터 전송시의 충돌을 회피      CSMA/CD, CSMA/CA와 같은 방식으로 해결        디지털 to 아날로그  Error Detection and Correction          CheckSUM , 패리티 비트 등으로 전송 중 오류를 감지        Routing          OSPF, BGF, RIP 등등 경로 지정 프로토콜 사용        Network Protocol          TCP/IP, UDP, FTP 등등      각 프로토콜의 속도 및 신뢰성        Security  Qos          서비스 품질은 얼마나?      DNS  컴퓨터 네트워크에서 사용되는 계층화된 분산 데이터베이스 시스템이다.  도메인 이름 → IP 주소 / IP 주소 → 도메인 이름으로 변환"
  },
  
  {
    "title": "Command line arguments",
    "url": "/learninghub/nhn%20academy/servlet-jsp/Command-Line-Arguments/",
    "categories": "NHN Academy, Servlet-JSP",
    "tags": "NHN Acedemy, Java",
    "date": "2024-12-15 15:10:00 +0900",
    





    
    "snippet": "Command Line Arguments(23. 10. 30)      Java 응용 프로그램은 명령줄에서 여러 인수를 받아들일 수 있고, 이를 통해 사용자는 응용 프로그램이 시작될 때 구성 정보를 지정할 수 있다.      public static void main(String[] args) {          for (String arg : arg...",
    "content": "Command Line Arguments(23. 10. 30)      Java 응용 프로그램은 명령줄에서 여러 인수를 받아들일 수 있고, 이를 통해 사용자는 응용 프로그램이 시작될 때 구성 정보를 지정할 수 있다.      public static void main(String[] args) {          for (String arg : args) {              try {                  int value = Integer.parseInt(arg);                  System.out.println(\"int : \" + value);              } catch (NumberFormatException ignore) {                  System.out.println(\"String : \" + arg);              }          }    }      % java Main 2023 NHN Academy backend  int : 2023  String : NHN  String : Academy  String : backend      빌더형(Builder style)빌더형은 객체를 생성하고 명령줄에서 사용 가능한 인수들을 객체에 추가하여 함으로써 구분 분석에 필요한 인수들의 묶음을 만드는 것이다.Apache Commons CLIApache Commons CLI 라이브러리는 프로그램에 전달된 명령줄 옵션을 구문 분석하기 위한 API를 제공한다. 또한 명령줄 도구에 사용할 수 있는 옵션을 자세히 설명하는 도움말 메시지를 출력할 수도 있다.옵션 만들기는 크게 2가지로 구분할 수 있다.  Boolean Option  Argument Option모듈 추가하기&lt;dependency&gt;    &lt;groupId&gt;commons-cli&lt;/groupId&gt;    &lt;artifactId&gt;commons-cli&lt;/artifactId&gt;    &lt;version&gt;1.5.0&lt;/version&gt;&lt;/dependency&gt;Boolean option 추가하기org.apache.commons.cli 에서 제공하는 Options 를 적용// create Options objectOptions options = new Options();// add t optionoptions.addOption(\"v\", \"version\", false, \"print the version\");  addOption 메소드에는 두가지 매개변수가 있다.          첫 번째 매개변수는 String 타입의 옵션을 나타낸다.      두 번째 매개변수는 옵션에 대한 설명      값을 갖는 option 추가하기// create options objectOptions options = new Options();//add logfile optionOption logfile = Option.builder(\"logfile\")                       .argName(\"file\")                       .hasArg()                       .desc(\"use given file for log\")                       .build();options.addOption(logfile);  인수를 갖는 옵션은 Option 클래스의 빌더를 이용해 생성 가능  builder 를 이용해 빌더 객체를 생성, 여기에 선택적으로 설정하여 원하는 옵션 생성명령줄 인수 구문 분석CommandLineParser parser = new DefaultParser();CommandLine cmd = parser.parse(options, args);  CommandLineParser의 parse 메소드는 명령줄 인수를 구문 분석하는 데 사용된다.  CommandLineParser 인터페이스 구현은 여러 가지가 있을 수 있으며 권장되는 것 중 하나는 DefaultParser이다.Option 값 가져오기  command line argument에 ‘c’ 를 추가  options.addOption(\"c\", true, \"국가 코드\");          hashArg 가 true → 인자가 필요하다.      -c 10 인 경우                  cmd.getOptionValue() 로 옵션을 가져올 수 있다.                          만약 명령어에 대한 정보를 알고 싶은 -? 를 추가하여 설명서를 보이고 싶다면      if (cmd.hasOption(\"?\")) {       HelpFormatter formatter = new HelpFormatter();       formatter.printHelp(Exam03.class.getSimpleName(), options);   }              이렇게 처리 할 수 있다.      "
  },
  
  {
    "title": "Git",
    "url": "/learninghub/git/",
    "categories": "",
    "tags": "",
    "date": "2024-12-15 00:00:00 +0900",
    





    
    "snippet": "Git(23.08.28)버전 관리  로컬 버전 관리 시스템          파일 다른 이름으로 저장      간단 하지만 실수 발생      DB를 활용해서 변경 사항을 기록하는 로컬 시트템 제작        중앙집중식 버전 관리 시스템          파일을 저장하는 하나의 서버      서버를 사용하는 다수의 클라이언트(서버 접속하는 프로그램)  ...",
    "content": "Git(23.08.28)버전 관리  로컬 버전 관리 시스템          파일 다른 이름으로 저장      간단 하지만 실수 발생      DB를 활용해서 변경 사항을 기록하는 로컬 시트템 제작        중앙집중식 버전 관리 시스템          파일을 저장하는 하나의 서버      서버를 사용하는 다수의 클라이언트(서버 접속하는 프로그램)      누가 무엇을 하는지 추적 가능      중앙 서버에 의존하는 형태 → 중앙 서버 다운시 치명적      서버 다운시 모든 사람이 업무 중단        분산 버전 관리 시스템          클라이언트가 저장소를 통쨰로 복사함      서버에 비의존적임 (서버가 이상이더라도 로컬에 저장)      git의 역사  리눅스가 사용하던 DVCS가 유료화 됨으로써 자체 도구 제작  리눅스가 분산 저장소 설계 함          빠른속도      단순 구조      비 선형적 개발      완벽한 분산        2005년 Git 탄생git의 특성  대부분의 명령은 로컬에서 실행          서버와 통신 비용이 없기에 빠른 조회 가능        각 파일의 변화를 시간순으로 관리          델타를 저장 → 버전에 따른 변경 사항을 저장      특정 버전으로 돌아갈떈 속도가 느림        git은 스냅샷으로 저장          파일이 달라지지 않으면 이전 버전의 링크만 저장      특정 버전으로 되돌아갈때 속도가 빠름        git은 무결성 하다          데이터를 저장하기전 체크섬을 구하고 해당 체크 섬으로 데이터 관리      SHA-1 해시 사용 → 고유한 값을 가지기에 해당 파일의 해시로 저장        git의 상태          Committed → DB에 안전하게 저장      Modified → 파일만 수정 아직 커밋 되지 않음      Staged → 곧 커밍 할거다.        깃은 어떻게 데이터를 저장하는가?          커밋이 깃은 커밋 개체를 생성      이런식으로 파일 저장  tree → blob → …      결국 커밋을 가리키는 포인터 → 브랜치      브랜치와 머지  branch → 가상의 작업 공간  이슈 발생시 새 브랜치를 하나 생성해 작업 진행 → hotfix 발생시 브랜치 새로 생성해 수정하고 머지git-flow  feature 브랜치          특정 기능 하나에 대한 브랜치 그리고 개발 완료되며 다시 머지      fast-forward 사용하지 않음, 기능별로 개발한 커밋 분류하기 위해서      prefix/        release 브랜치          배포를 위한 브랜치      develop 브랜치 부터 시작됨      소소한 버그 픽스      release 준비 완료시 develop / master 에 머지      이 브랜치를 통해 develop은 바로 다음 기능      release/        hotfix 브랜치          master로 부터      긴급한 이슈 해결      release와 비슷함 ( 출발 브랜치의 차이 )      hotfix와 상관 없다면 develop은 개발 계속함      hotfix/      원격 저장소      main 과 origin/main은 다르다    원격 저장소의 변경사항을 내려 받는것을 fetch라고 함      fetch와 머지는 다르다.    pull = fetch + 머지"
  },
  
  {
    "title": "Jekyll 이미지 관리하기",
    "url": "/learninghub/tech/jekyll-blog/jekyll%EC%9D%B4%EB%AF%B8%EC%A7%80%EA%B4%80%EB%A6%AC/",
    "categories": "Tech, jekyll-blog",
    "tags": "writing",
    "date": "2024-12-14 21:10:00 +0900",
    





    
    "snippet": "Jekyll에서는 일반적으로 글은 _posts 에 이미지는 assets 에 저장한다.하지만 이러한 방식의 경우 추후 image가 많아 질경우 두가지 디렉토리에 관리를 해줘야하는 불편함이 예상되었다..일반적인 jekyll의 이미지 리소스 관리learninghub/                 # 프로젝트의 루트 디렉토리├── _config.yml    ...",
    "content": "Jekyll에서는 일반적으로 글은 _posts 에 이미지는 assets 에 저장한다.하지만 이러한 방식의 경우 추후 image가 많아 질경우 두가지 디렉토리에 관리를 해줘야하는 불편함이 예상되었다..일반적인 jekyll의 이미지 리소스 관리learninghub/                 # 프로젝트의 루트 디렉토리├── _config.yml              # Jekyll 설정 파일├── _posts/                  # 블로그 게시글을 저장하는 디렉토리│   ├── 2024-12-14-ubuntu-upgrade.md    # 블로그 포스트│   └── ...                  # 다른 포스트들├── _site/                   # 빌드 후 생성되는 사이트 파일├── assets/                  # 정적 파일들 (이미지, CSS, JavaScript)│   ├── images/              # 이미지 파일들│   │   ├── image1.png       # 이미지 파일1│   │   ├── image2.jpg       # 이미지 파일2│   │   └── ...              # 다른 이미지들└── ...만약 카테고리와 포스트가 많아지게 된다면… 이미지가 너무 복잡해 질거라 예상했다.만약 _post 에 .md 와 image를 같이 저장한다면?learninghub/                     # 프로젝트의 루트 디렉토리├── _config.yml                   # Jekyll 설정 파일├── _posts/                       # 블로그 게시글을 저장하는 디렉토리│   ├── 2024-12-14-ubuntu-upgrade.md    # 블로그 포스트 파일│   ├── 2024-12-14-ubuntu-upgrade/      # 해당 포스트의 이미지 폴더│   │   ├── ubuntu-runner-upgrade.png   # 이미지1│   │   └── ubuntu-runner-upgrade2.jpg  # 이미지2│   │   └── ...              # 다른 이미지들└── ...게시글에 대한 마크다운과 이미지가 같이 관리 된다면 더욱 편하다고 생각했다.Jekyll에서 이미지를 관리하는 방법CDN(Content Delivery Network)# The CDN endpoint for media resources.# Notice that once it is assigned, the CDN url# will be added to all media resources (site avatar, posts' images, audio and video files) paths starting with '/'## e.g. 'https://cdn.com'cdn: \"https://unggu0704.github.io/learninghub\"  CDN은 웹 콘텐츠를 여러 데이터 센터(엣지 서버)에서 복제  사용자가 이미지를 요청할 때 가장 가까운 서버에서 전송.. .하는 개념하지만 jekyll에서 블로그 호스팅으로 쓰기에 현재로써는 image를 호스팅하는 서버 즉 내 블로그 url을 적어둔다.이렇게 되면 jekyll은 이미지를 가져올 때 내 블로그의 url을 찾아간다.baseurl# The base URL of your sitebaseurl: \"/learninghub\"  일반적인 baseurl을 사용하여 로컬 환경에서도 url이 통일 될 수 있게 설정한다.시도 방법플러그인 - jekyll-postfiles를 사용 (X)https://github.com/nhoizey/jekyll-postfiles  permalink의 설정에 맞춰 폴더를 생성해 이미지 경로를 쉽게 해주는 플러그인… 이지만  Github Page에서는 동작하지 않는다고 한다…CDN을 통한 사용법 (X)  이미지 경로를 ![tt](/_posts/image/apple-touch-icon.png)_test_ 로 설정  cdn 설정을 통해 deploy 작업을 거치면          \"https://unggu0704.github.io/learninghub\" 가 추가로 붙는다.        https://unggu0704.github.io/learninghub/_posts/image/apple-touch-icon.png)_test_test) 가 완성하지만.. 해당 방법은 확장성이 낮으며 로컬 환경에서 이미지 테스트를 해볼 수가 없다.해결permalink와 site.url을 사용결국 중요한건 이미지가 있는 경로까지 url 설정을 해야한다. (배포/로컬 환경 동일하게!)└─Tech    └─jekyll-blog        │  2024-12-15-Jekyll-로컬-환경-구축.md        │        └─2024-12-15-Ubuntu에러                2024-12-15-Ubuntu에러.md                image 1.png                image.png  본래는 _post 에 모든 .md 파일을 넣어야하지만 카테고리 관리를 위해 내부에 별도의 폴더를 디렉토리 이름으로 설정해 관리하고 있다.  불러와야할 url          {환경에따른 주소}/learninghub/categories/tech/jekyll-blog/Ubuntu에러/image경로      /learninghub  baseurl 설정으로 가져올 수 있다.기존의 permalink 설정permalink: /posts/:title/  post에 접근시 접근 url은          https://unggu0704.github.io/learninghub/posts/post 제목        해당 디렉토리 경로를 가져오기 위해 permalink를 실제 디렉토리 이름과 동일하게 작업변경된 permalink 설정permalink: /:categories/:title/  실제 _post 안에서 카테고리 이름과 동일하게 폴더를 만들어 관리하여 url을 통일  이럴 경우 실제 url과 디렉토리 구조와 동일하게 맞추어진다.baseurl과 permalink의 조합![image.png](/learninghub/tech/jekyll-blog/jekyll%EC%9D%B4%EB%AF%B8%EC%A7%80%EA%B4%80%EB%A6%AC//image.png)  baseurl + page.url (현재 접속url) 을 하여 이미지 경로를 설정  Liquid 템플릿 구문을 사용하기 위해서 render_with_liquid: true` 작업이 필수적이미지가 정상적으로 로드 되는 것을 확인할 수 있었다."
  },
  
  {
    "title": "Ubuntu runner가 업그레이드 됨",
    "url": "/learninghub/tech/jekyll-blog/Ubuntu%EC%97%90%EB%9F%AC/",
    "categories": "Tech, jekyll-blog",
    "tags": "writing",
    "date": "2024-12-14 18:10:00 +0900",
    





    
    "snippet": "Github의 Runner서버 중 (*Ubuntu-24-04-64x)* 가 기존의 Action에 맞지 않다고 에러가 발생기존의 Workflow 설정(Asis)jobs:  # Build job  build:    runs-on: ubuntu-latest  ubuntu-latest를 설정하고 있음          2024년 1월 부터 *Ubuntu-24-...",
    "content": "Github의 Runner서버 중 (*Ubuntu-24-04-64x)* 가 기존의 Action에 맞지 않다고 에러가 발생기존의 Workflow 설정(Asis)jobs:  # Build job  build:    runs-on: ubuntu-latest  ubuntu-latest를 설정하고 있음          2024년 1월 부터 *Ubuntu-24-04-64x)* 가 Ubuntu Runner 서버로 설정된다고 안내      https://github.com/actions/runner-images/issues/10636        현재 jekyll는 *Ubuntu-22-04-64x)* 에 맞춰져 있기에 해당 에러가 발생  더이상 *Ubuntu-22-04-64x)* 는 최신 버전이 아니기에… lastes가 아닌 명시적 작성Ubuntu 버전을 명확히 yml에 작성jobs:  # Build job  build:    runs-on: ubuntu-22.04정상적으로 Action Job들이 완료되었다."
  },
  
  {
    "title": "Jekyll 로컬환경 구축하기",
    "url": "/learninghub/tech/jekyll-blog/Jekyll-%EB%A1%9C%EC%BB%AC-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95/",
    "categories": "Tech, jekyll-blog",
    "tags": "writing",
    "date": "2024-12-14 18:10:00 +0900",
    





    
    "snippet": "1. Ruby 설치Chirpy의 테마를 설치하기 위해서는 Ruby 3.1.x를 설정해야한다.2-1. Window 설치https://rubyinstaller.org/downloads/에 방문하여 3.1.6(with DEVKIT)과 함께 다운받는다.2-2. MACbrew를 통해 설치한다.brew install rbenv ruby-buildrbenv glo...",
    "content": "1. Ruby 설치Chirpy의 테마를 설치하기 위해서는 Ruby 3.1.x를 설정해야한다.2-1. Window 설치https://rubyinstaller.org/downloads/에 방문하여 3.1.6(with DEVKIT)과 함께 다운받는다.2-2. MACbrew를 통해 설치한다.brew install rbenv ruby-buildrbenv global 3.1.4rbenv rehash3. Bundler 설치gem install bundler루비의 gem 명령어를 통해 bundler 설치4. 프로젝트 의존성 설치 및 로컬 서버 실행bundler install bundler exec jekyll s정상적으로 4000번 포트에 로컬서버가 기동되는 것을 볼 수 있었다."
  },
  
  {
    "title": "3. transaction",
    "url": "/learninghub/nhn%20academy/jdbc/3.-Transaction/",
    "categories": "NHN Academy, JDBC",
    "tags": "DB, NHN Acedemy, JDBC",
    "date": "2024-12-13 15:10:00 +0900",
    





    
    "snippet": "Transaction (23. 12. 01)  트랜잭션(Transaction)은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미Transaction이 필요한 순간  A → B 에게 10,000원을 송금한다면?  A와 B는 동시에 Update 되어야한다.      계...",
    "content": "Transaction (23. 12. 01)  트랜잭션(Transaction)은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미Transaction이 필요한 순간  A → B 에게 10,000원을 송금한다면?  A와 B는 동시에 Update 되어야한다.      계좌에서 B계좌로 10,000 이체되는 과정은 다음과 같습니다.          데이터베이스에서 A의 은행계좌잔고 값을 메인 메모리로 읽어옵니다.                  읽어온 A의 잔고 값에서 10,000을 감소시킵니다.          데이터베이스에서 B의 은행계좌잔고 값을 메인 메모리로 읽어옵니다.          읽어온 B의 잔고 값을 10,000 증가시킵니다.          A의 계좌 값을 데이터베이스에 기록합니다.          B의 계좌 값을 데이터베이스에 기록합니다.                    Transaction 속성  원자성          트랜잭션의 수행결과는 전부 수행되거나 전부 수행되지 않아야한다.      작업 중 문제가 생기면 최초의 상태로 돌아가는 RollBack 이 작동되어야 한다.        일관성          트랜잭션 수행 후 모델의 모든 제약 조건을 만족해야 한다.      null, 정수 값… 등등 명시적 무결성 제약 조건 만족        고립성          트랜잭션은 다른 트랜잭션에 영향을 미치지 않아야한다.      임계 구역 처럼 두개의 트랜잭션이 한 데이터에 영향을 미친다면…?      connection.setAutoCommit(false); 로 고립성을 완성        지속성          트랜잭션의 성공 결과는 장애 등에도 변함없이 영구적으로 저장되어야한다.      "
  },
  
  {
    "title": "2. connection pool",
    "url": "/learninghub/nhn%20academy/jdbc/2.-Connection-Pool/",
    "categories": "NHN Academy, JDBC",
    "tags": "DB, NHN Acedemy, JDBC",
    "date": "2024-12-13 15:10:00 +0900",
    





    
    "snippet": "Connection Pool(23. 12. 01)  데이터 베이스에 접근하기 위한 패턴      미리 Connection 객체를 생성하여 Pool 또는 Container에 배치    • Application에서 Connection 객체가 필요할 때, 새로운 객체를 생성하는 대신 Pool에서 해당 객체를 가져와 사용하고 재사용을 위해서 사용된 객체는 P...",
    "content": "Connection Pool(23. 12. 01)  데이터 베이스에 접근하기 위한 패턴      미리 Connection 객체를 생성하여 Pool 또는 Container에 배치    • Application에서 Connection 객체가 필요할 때, 새로운 객체를 생성하는 대신 Pool에서 해당 객체를 가져와 사용하고 재사용을 위해서 사용된 객체는 Pool에 반납합니다.  장점  데이터베이스에 Connection을 생성할때 소요되는 시간 및 자원을 줄일 수 있습니다.  Connection 수를 제한 할 수 있어 과다한 접속으로 인한 서버 자원 고갈을 예방합니다.  메모리 영역에서 Connection을 관리하기 때문에 클라이언트가 데이터베이스 작업을 빠르게 진행할 수 있습니다.Connection Pool 구현?  *1. DataBase Driver를 사용하여 DataBase 연결      데이터 읽기/쓰기 위한 TCP/Socket Open    Socket을 통해서 데이터 읽기/쓰기    DataBase 연결 닫기    TCP/Socket Close*  이전까지는 close() 하면 Connection을 Close 했지만 이젠 자신을 반환(pool에) 하는 방식으로 바꾼다.connection.close() -&gt; PoolableConnection.close()Apache Commons DBCP  DBCP2 는 Apache Commons Pool 기반으로 한다.      Maven      &lt;dependency&gt;      &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;      &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt;      &lt;version&gt;2.11.0&lt;/version&gt;  &lt;/dependency&gt;      최적화WAS == Tomcat 은 Thread Pool을 사용  Default = 200개          즉 tomcat 기본설정을 사용한다면 동시에 최대 200개까지 처리할 수 있음      DBCP parameter를 WAS의 Thread Pool Size로 고정하여 최적화.          BasicDataSource basicDataSource = new BasicDataSource();      basicDataSource.setUrl(\"jdbc:mysql://133.186.241.167:3306/nhn_academy_100\");      basicDataSource.setUsername(\"nhn_academy_100\");      basicDataSource.setPassword(\"1jaOTakgkS1$dWl2\");      basicDataSource.setInitialSize(200);      basicDataSource.setMaxTotal(200);      basicDataSource.setMaxIdle(200);      basicDataSource.setMinIdle(200);          basicDataSource.setMaxWait(Duration.ofSeconds(2));      basicDataSource.setValidationQuery(\"select 1\");      basicDataSource.setTestOnBorrow(true);      DataSource  기존의 DriverManager를 통해 DB Connection을 얻는 것보다  더 좋은 기법          서버에서 관리하기에 DB 변경이 수월하다.      Connection, Statement 객체를 pooling 할 수 있다.            apache META-INF 의 context.xml 에 다음과 같은 코드 추가      &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;  &lt;Context&gt;          &lt;!-- Default set of monitored resources. If one of these changes, the    --&gt;      &lt;!-- web application will be reloaded.                                   --&gt;      &lt;WatchedResource&gt;WEB-INF/web.xml&lt;/WatchedResource&gt;      &lt;WatchedResource&gt;WEB-INF/tomcat-web.xml&lt;/WatchedResource&gt;      &lt;WatchedResource&gt;${catalina.base}/conf/web.xml&lt;/WatchedResource&gt;          &lt;Resource name=\"jdbc/test\" auth=\"Container\" type=\"javax.sql.DataSource\"                maxTotal=\"5\" maxIdle=\"5\" maxWaitMillis=\"10000\"                username=\"nhn_academy_0\" password=\"1234\"                driverClassName=\"com.mysql.cj.jdbc.Driver\"                url=\"jdbc:mysql://localhost:3306/nhn_academy_0\"                closeMethod=\"close\" /&gt;      &lt;/Context&gt;              context.xml 없으면 프로젝트 구조 가서 만들자.      "
  },
  
  {
    "title": "1. jdbc란",
    "url": "/learninghub/nhn%20academy/jdbc/1.-JDBC%EB%9E%80/",
    "categories": "NHN Academy, JDBC",
    "tags": "DB, NHN Acedemy, JDBC",
    "date": "2024-12-13 15:10:00 +0900",
    





    
    "snippet": "JDBC란?(23. 12. 01)  Java에서 관계형 데이터베이스에 저장된 데이터를 접근하게 해주는 API  Java Application이 일관된 API로 데이터를 연결, 검색 등을 가능하게 한다.  어떤 DBMS에 대해서 독립성을 가진다. → 모든 DB를 알지 못해도 JDBC API만 알면 동작 가능하다!JDBC의 구조  Java에서 DB에 접속...",
    "content": "JDBC란?(23. 12. 01)  Java에서 관계형 데이터베이스에 저장된 데이터를 접근하게 해주는 API  Java Application이 일관된 API로 데이터를 연결, 검색 등을 가능하게 한다.  어떤 DBMS에 대해서 독립성을 가진다. → 모든 DB를 알지 못해도 JDBC API만 알면 동작 가능하다!JDBC의 구조  Java에서 DB에 접속 할 수 있는 연결 기능 제공      JDBC의 구조                  구성요소      설명      역할                  Java Application      자바 응용프로그램, 자바 웹 애플리케이션 서버(tomcat, weblogic 등)      응용 프로그램 개발자, 웹 애플리케이션 서버 개발사              JDBC API      자바 응용프로그램에서 데이터베이스를 연결하고 데이터를 제어할 수 있도록 데이터베이스 연결 및 제어를 위한 인터페이스와 클래스들      JavaSE 개발사 (Sun microsystems, Oracle)              JDBC Driver Manager      자바 응용프로그램이 사용하는 데이터베이스에 맞는 JDBC 드라이버를 찾아서 로드합니다.      JavaSE 개발사 (Sun microsystems, Oracle)              JDBC Driver      각 데이터베이스 개발사에서 만든 데이터베이스 드라이버      데이터베이스 개발사(Oracle, MySql, PostgreSQL..      JDBC Type  JDBC는 네가지 타입이 있다.Type-1 Driver or JDBC-ODBC Bridge  JDBC와 ODBC 사이의 브릿지 역할을 수행  사용하기는 쉽지만 속도가 느린 단점이 있다.Type-2 Driver or Native API Partly Java Driver  type1 보다는 성능이 우수하지만 라이브러리 설치로 인해 비용이 증가  DB 제품의 변경에 취약Type-3 Network Protocal Driver ( fully java driver )  Type3 JDBC 드라이버는 JDBC 미들웨어 서버와 독점 프로토콜로 통신  JDBC 미들웨어는 요청된 프로토콜을 데이터베이스 호출로 변환  데이터 베이스 변경에 유연하지만 많은 네트워크를 호출함으로 속도가 느리다.Type-4 Thin Driver ( fully java driver )  가장 인기가 좋다  DB와 다이렉트로 통신 → 순수 자바 드라이버  라이브러리와 미들 웨어 서버가 필요 없다.  성능적으로 가장 우수하다.Java JDBC API  JDBC API는 java 언어 차원에서 데이터 엑세스 제공  JDBC API Package          java.sql      javax.sql                  Java EE 애 있던 jdbc 확장용 기능 → JDBC 3부터는 Java SE의 일부로 포함됨.          java.sql 의 확장, 추가적인 기능                    JDBC Architecture  JDBC를 사용하여 Two-Tier 또는 Three-Tier 아키텍쳐를 구성 할 수 있습니다.Two-Tier Architecture  Client Layer - Server Layer로 구성 됩니다.  특정 DB와 통신에 있어 JDBC 드라이버가 필요합니다.  Client 프로그램이 DB에 바로 접속하는 구성이라 확장성에 제한이 있을 수 있다.  클라이언트 - 서버 아키텍쳐라고 한다.Three-Tier Architecture  Three-tier 아키텍처는 비즈니스 로직을 담은 미들웨어가(Tomcat) 추가됩니다.  이 아키텍처는 사용자 PC에서 데이터베이스로 직접적인 통신은 없습니다.  사용자의 요청은 미들웨어로 전송됩니다.  데이터베이스의 처리 또한 결과를 미들웨어로 전송 시킨 뒤 사용자와 통신 \\JDBC 드라이버 로딩MySQL JDBC 드라이버 로딩 (Reflection 활용)Class.forName(\"com.mysql.cj.jdbc.Driver\");DB Connection 생성Connection connection = DriverManager.getConnection(URL, user, password);Statement  Java에서 SQL 문을 실행하기 위해서는 Statement 클래스를 이용  SQL 문의 결과를 얻어오는데에는 ResultSet 클래스를 이용Statement 사용      Connection 객체를 사용해 결과를 보낸다.      Statement statement = connection.createStatement();            PreparedStatement 를 사용하여 더 효율성을 높이기 가능      PreparedStatment psmt = connection.prepareStatement(\"SQL data\");  pstmt.setString(1, request.getParameter(\"username\");  pstmt.setString(2, request.getParameter(\"email\");      Statement의 MethodsexecuteQuery()  SELECT 쿼리를 실행할 때 사용합니다.  ResultSet 을 결과를 반환합니다.executeUpdate()  INSERT 등의 DDL을 실행하기 위해서 사용합니다.  int 타입으로 성공 여부나 처리된 데이터 수를 반환합니다.결과 받기  가져온 데이터를 처리하기 위해서는 ResultSet 객체가 필요하다.  ResultSet 은 커서를 다룰 수 있게 한다. (초기행은 첫번째 행 이전)JDBC 로딩  DbUtilspublic class DbUtils {    public DbUtils(){        throw new IllegalStateException(\"Utility class\");    }    public static Connection getConnection() {        Connection connection = null;        try {            //todo connection.            connection = DriverManager.getConnection(\"jdbc:mysql://133.186.241.167:3306/nhn_academy_3\",\"nhn_academy_3\",\"Jc1?tjnLZWi7LTIH\");        } catch (SQLException e) {            throw new RuntimeException(e);        }        return connection;    }}"
  }
  
]

